#include <iostream>
#include <bits/stdc++.h>
using namespace std;
#include <cmath>
#include <stdio.h>
#define ll long long
#define nd "\n"
#include <sstream>
#include <math.h>
#define FIO  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define all(x) (x).begin(), (x).end()
#define lol cout <<"i am here"<<nd;
#define py cout <<"YES"<<nd;
#define pp  cout <<"ppppppppppppppppp"<<nd;
#define pn cout <<"NO"<<nd;
#define ld long double
#define popcount(x)  __builtin_popcount(x)
#define make_unique(go)go.resize(unique(all(go))-go.begin())
#define clz(n) __builtin_clz(n)//31 -x
const  double PI = acos(-1.0);
double EPS = 1e-9;
#define sz(s)    (int)(s.size())
#define mem(v,d)    memset(v,d,sizeof(v));
#define print2(x , y) cout <<x<<' '<<y<<nd;
#define print3(x , y , z) cout <<x<<' '<<y<<' '<<z<<nd;
#define watch(x) cout << (#x) << " = " << x << nd;
#define mp make_pair
template<class container>
void print(container v) { for (auto& it : v) cout << it<< ' '; cout << '\n'; }

void printpr(priority_queue<ll>&arr){ while(!arr.empty()){ cout <<arr.top()<<" "; arr.pop();}cout <<nd;}
/*
 *
 *
#include <iostream>
#include <bits/stdc++.h>
#include <ext/numeric>
using namespace std;
using ll = long long;
using ld = long double;
template<class container>
void print(container v) { for (auto& it : v) cout << it<< ' '; cout << '\n'; }
#define all(c) c.begin() ,c.end()
#define clr(v , x) memset(v , x , sizeof v);
#define nd '\n'
 *
 *
 *
 *
 *
 * ///////////////
 * /*
    ll n; cin >>n;
    vector<node>arr;
    for (int i = 1; i <= n; ++i){
        ll b; cin >>b;ll R = 0;
        ll L = (i+1+b)/(b+1);
         R = b ? i/b : n;
        arr.emplace_back(L , R , i) ;
    }
    sort(all(arr)); int j = 0;
    vector<int>ans(n+1);

    priority_queue<pair<ll,ll>, vector<pair<ll,ll>> , greater<pair<ll,ll>>>q;
    for (int i = 1; i <= n; ++i){

        while (j < n && arr[j].L<= i){
            q.emplace(arr[j].R, arr[j].index); ++j;
        }
        while (!q.empty() &&q.top().first< i) q.pop();
        auto temp = q.top(); q.pop();
        ans[temp.second] = i;

    }
    for (int i = 1; i <= n; ++i) cout << ans[i]<<" \n"[i == n];
    */


*
 * */
 */
//https://www.youtube.com/watch?v=AOIndhgOS4k//highly recommended
struct hash_pair {
    template <class T1, class T2>
    size_t operator()(const pair<T1, T2>& p) const
    {
        auto hash1 = hash<T1>{}(p.first);
        auto hash2 = hash<T2>{}(p.second);

        if (hash1 != hash2) {
            return hash1 ^ hash2;
        }

        // If hash1 == hash2, their XOR is zero.
        return hash1;
    }
};

struct SpecialName {
    string name = "king";
    string& get_name(){
        return name;
    }
    void print(){
        cout<<name<<"\n";
    }
    /*
    SpecialName my_name;
    my_name.print();	//king

    string &str = my_name.get_name();
    str = "hahha";
    my_name.print();	//hahha

    my_name.get_name() = "killme";---->>> focus here it is a function not variable
    my_name.print();	//killme
     */

};
// int & ref = x // same location of x // ----> &x == &ref
// int* ptr = & x // ptr == &x== & ref // but & ptr is different
// *ptr = 20 // go and change the address which i point to to value equal = 20// ptr = nullptr or 0
// if(!ptr) cout <<null<<nd; // garbage of declare only // print(null)--->rte
//what i created i must deleted// be carefull from dangling pointers// crash

struct  employee{
    int *ptr = nullptr;
    employee(){
        ptr = new int [5] {1 , 2 , 3 , 4 , 5};
    }
    void print(){
        cout <<*ptr<<' '<<&ptr<<' '<<ptr<<' '<<nd;
    }
    // without destructor there is a memory leak ....be awake about what what u use
    ~employee(){
        cout <<"salam ybn el 3bit2  "<< ptr<<nd;
        delete [] ptr;
        ptr = nullptr;

    }
    // these two lines to warn me from memory leak// CE
    employee(const employee & e)= delete;// employe e3 = e1
    void operator = (const employee & e) = delete;// e2 = e1
    /*
    Emplyee e1, e2;
    e1.xPtr[0] = 20;

    // 20 0x19c 0x7fff
    e1.print();
    // 1 0xaaa 0xbb
    e2.print();

    e2 = e1;

    // 20 0x19c 0xbb
    e2.print();
    // Crash!
    // e2 lost its xPtr value of the created memory
    // the value of e1 copied

    // problem 1): memory leak as we lost e2 created memory
    // problem 2): e1 ptr will be deleted twice = dangling = crash

    Emplyee e3 = e1;	// same issue but more implicit
     */
};
/*
const int N = 3e6;
ll mod = (ll)1e9+7;
ll n , k;
ll arr[N] , dp[N];

ll dfs(ll sum){
    if (sum > k) return 0;
    if (sum == k) return 1;


    ll &ret = dp[sum]; if (~ret) return ret;
    ret = 0;
    for (int i = 0; i < n; ++i){
        ret+=dfs(sum+arr[i]); ret%=mod;
    }
    return ret%mod;
}
 */


int pooo(int*&ptr){
    lol;
    cout <<ptr<<' '<<*ptr<<' '<<&ptr<<' '<<*&ptr<<' '<<&*ptr<<nd;
}

void solve(){
    /*
    mem(dp, -1);
    cin >>n>>k;
    for (int i = 0;i < n; ++i) cin >>arr[i];
   cout <<dfs(0)<<nd;
     */
    // try to use pointers // null ptr // free memo

   /*
    int x = 100;
    int *ptr = &x;
    cout << x<<' '<<&x<<' '<<ptr<<' '<<&ptr<<nd;

    pooo(ptr);
   */


}
ll n;vector<ll> tree;
ll get(int node , int node_low  , int node_high , int query_low , int query_high){
    if ( query_low > node_high || node_low > query_high ) return -inf;
    if (node_low >= query_low && query_high >= node_high) return tree[node];
    int m = node_low + node_high >> 1;
    ll op1 = get(2* node , node_low , m , query_low , query_high);
    ll op2 = get(2* node+1 , m+1  , node_high, query_low , query_high);
    return max(op1 , op2);
}

void update(int i , int node , int node_low , int node_high ,ll val){
    if (node_low > i || i > node_high) return;
    if (node_high==node_low){
        tree[node] = val; return;
    }
    int mid = node_low + node_high >> 1;
    update(i , 2*node , node_low , mid , val); update(i , 2*node+1 , mid+1 , node_high , val);
    tree[node] = max(tree[node*2]  , tree[node*2+1]);
}
int main(){
    FIO;
    //create();
    // freopen("plants.in","r",stdin);
    // freopen("output.txt","w",stdout);
    int t =1;///cin >>t;
    while(t--)//while( cin >> hola)///
        solve();// // // burn();//
#ifndef ONLINE_JUDGE
    cout << "Running Time: " << 1.0 * clock() / CLOCKS_PER_SEC << " s .\n";
#endif
    return 0;
}

///////////////////////////////////////









class MinHeap{// look at ur capacity
private:
    int *arr {};
    int Size {};
    int capacity {1000};
    int lCHILD(int node){ return 2 * node+1 >= Size ? -1 : 2 * node+1 ; }

    int rCHILD(int node){ return 2 * node +2 >= Size ? -1 : 2 * node+2 ; }

    int parent(int node){ return !node ? -1 : (node-1) / 2 ; }

    void heapify_up(int child_pos){
        int par = parent(child_pos);
        if (par == -1 || arr[child_pos]>=arr[par]) return;// stop when i am the head or i am bigger than my parent

        swap(arr[child_pos] , arr[par]);
        return heapify_up(par);
    }
    void heapify_down(int cur){

        int child = lCHILD(cur);
        int rC = rCHILD(cur);
        if (!~child)return;
        if (~rC  && arr[child]>arr[rC]){
            child = rC;
        }
        if (arr[cur] > arr[child]){
            swap(arr[cur] , arr[child]);
            return heapify_down(child);
        }
    }

    void heapify(){
        for (int i = Size/2-1 ; ~i; --i){// leaf nodes o(1) or skip them
            heapify_down(i);
        }
    }

public:
    MinHeap(){
        arr = new int [capacity] {};
        Size =0;
    }
    /*
    MinHeap(const vector<int>& need_change){
        assert((int) need_change.size() <= capacity);
        arr = new int [capacity];
        Size = (int) need_change.size();
        for (int i = 0; i < Size; ++i){
            arr[i] = need_change[i];
        }
        heapify();
    }
     */
    ~MinHeap(){
        delete [] arr; arr = nullptr;
    }
    bool is_empty(){return !Size;}
    void push(int el){
        assert(Size+1 < capacity);
        arr[Size++] = el;
        heapify_up(Size-1);
    }
    int top(){
        assert(!is_empty());
        return arr[0];
    }

    void pop(){
        assert(!is_empty());
        arr[0] = arr[--Size];// last element in the left of the last level of my complete binary tree
        heapify_down(0);
    }

    int get_Size(){
        return Size;
    }
    void print_less(long long val , int node = 0){
        if(node == -1 || arr[node]>= val) return;
        cout <<arr[node]<<' ';
        print_less(val , lCHILD(node));
        return print_less(val , rCHILD(node));

    }

    void heapSort(int *ptr  , int n){
        int *old_arr = arr;
        int OldSize = Size;

        arr = ptr; Size = n;

        heapify();// o(n)
        while (Size--){// o(nlog n)
            swap(arr[0] , arr[Size]);
            heapify_down(0);
        }
        // make_ it increasing
        for (int i = 0; i < n/2; ++i){
            swap(arr[i] , arr[n-i-1]);
        }
        arr = old_arr; Size = OldSize;

    }

    /*
    struct kth_largest_number{
    private:
        int k;
        MinHeap go;
    public:
        kth_largest_number(int k):k(k){};
        int test(int num){
            if (go.get_Size()< k){
                go.push(num);
            }
            else if (go.top() > num){
                go.pop(); go.push(num);
            }
            return go.top();
        }
    };
     */

};


/////////////////////////////////////////
void sparta(vector<ll>&arr){
    vector<ll>go = arr;
    sort(all(go));
    go.resize(unique(all(go))-go.begin());
    int n = arr.size();
    for (int i =0;i <n; ++i){
        arr[i] =upper_bound(all (go) , arr[i])-go.begin();
    }
}
struct burn{
    vector<ll>arr;
    const int n;
    burn(int n):n(n) , arr(n){};

    void update(int I , ll val){
        for (int i = I ; i <=n; i += (i &-i)){
            arr[i]+=val;
        }
    }

    ll get(int i){
        ll res = 0;
        while (i >0){
            res+=arr[i];
            i-= (i & -i);
        }
        return res;
    }

    ll query(int l , int r){
        return get(r)- get(l-1);
    }
};
///////////////////////////////////////
struct monster{
    vector<ll>arr; int leader;
    vector<ll>operation;
    monster(int n){
        leader = n;
        while (popcount(leader)!= 1)++leader;
        arr.resize(2 *leader);
        operation.resize(2 *leader);
    }

    void propagate(int node_low , int node_high , int node ){
        if (!operation[node]) return;
        arr[node]+= (node_high-node_low) * operation[node];
        if (node_high-node_low > 1){
            operation[2*node+1]+= operation[node];
            operation[2* node+2]+= operation[node];
        }
        operation[node]= {};
        return;
    }


    void update(int query_low , int query_high , int node , int node_low , int node_high ,ll val){
        propagate(node_low , node_high , node );
        if (query_low >= node_high || node_low >= query_high) return;
        if (node_low >= query_low && query_high >= node_high){
            operation[node] = val;
            propagate(node_low , node_high , node);
            return;
        }
        int mid = node_low +node_high >> 1;
        update(query_low ,  query_high  , 2*node+1 , node_low , mid , val);
        update(query_low ,  query_high ,2*node+2 , mid ,  node_high , val);
        arr[node] = arr[node*2+1]  + arr[node*2+2];

    }

    void update(int l , int r  ,ll val){
        update(l , r+1  , 0 , 0 , leader , val);
    }
    void update(int i , int node , int node_low , int node_high ,ll val){
        if (node_high-node_low== 1){
            arr[node] = val ;
            return;
        }
        int mid = node_low + node_high >> 1;
        if (i < mid){
            update(i , 2*node+1 , node_low , mid , val);
        }else{
            update(i , 2*node+2 , mid , node_high , val);
        }
        arr[node] = max(arr[node*2+1]  , arr[node*2+2]);
    }
    void update(int i ,ll val){
        update(i , 0  , 0 , leader , val);
    }

    ll get(int query_low , int query_high , int node , int node_low , int node_high){
        propagate(node_low , node_high , node) ;
        if (query_low >= node_high || node_low >= query_high) return 0;
        if (node_low >= query_low && query_high >= node_high){
            return arr[node];
        }
        int mid = node_low +node_high >> 1;
        ll op1 = get(query_low ,  query_high , 2*node+1 , node_low , mid);
        ll op2 = get(query_low ,  query_high , 2*node+2 , mid ,  node_high);
        return op1+op2;
    }
    ll get(int l , int r) {
        return get(l ,r+1 , 0 , 0 , leader);
    }
    int suf( int node , int l , int r , int s, int e)
    {     propagate(l ,r , node) ;
        if ( l >= e || r <= s || arr[node] == 0)
            return -1;
        if ( (r-l)== 1)
            return l;
        int md = l + r >> 1 ;
        int ans1 = suf(2* node+2,md,r,s,e);
        if(ans1 != -1)
            return ans1;
        return suf(2*node+1,l,md,s,e);
    }
    int suf(int l , int r){
        return suf(0 , 0 , leader , l , r+1);
    }

    int pref( int node , int l , int r , int s, int e)
    {      propagate(l ,r , node) ;
        if ( l >= e || r <= s || arr[node] == 0)
            return -1;
        if ( (r-l)== 1)
            return l;
        int md = l + r >> 1 ;
        int ans1 = pref(2* node+1,l,md,s,e);
        if(ans1 != -1)
            return ans1;
        return pref(2* node+2,md,r,s,e);
    }
    int pref(int l , int r){
        return pref(0 , 0 , leader , l , r+1);
    }


};


class mapper{
private:
    map<string ,int > str;
    map<int , string> id;
public:


    int get_id(string arr){
        if (str.count(arr)){
            return str[arr];
        }

        int i = sz(str);
        str[arr] = i;
        id[i] = arr;
        return i;
    }

    string getS(int i){
        return id[i];
    }

};
/////////////////////////
/*


struct preef{
	vector<ll>arr,operation;
	int leader;
	preef(int n){
        this->leader = n;
		while (popcount(leader)!= 1){
			++leader;
		}
		arr.resize(2 * leader); operation.assign(2 * leader , -1);
	}

	void propagate(int node , int node_low , int node_high){
		if (~operation[node]){
			arr[node] = operation[node];
			if ((node_high- node_low) >1){// not a leaf
				operation[2 *node+1] = operation[2 *node+2] = operation[node];
			}
			operation[node] = -1;
		}
		return;
	}

	void update(int query_low , int query_high , int delta , int node , int node_low , int node_high){
		propagate(node , node_low , node_high);// make sure all propagation is done at this node
		if (node_low >= query_high || query_low >= node_high) return;
		if (query_high >= node_high && node_low >= query_low){
			operation[node] = delta;
			propagate(node , node_low , node_high);
			return;
		}

		int mid = node_low + node_high >>1;

		update(query_low , query_high , delta , 2 *node+1 , node_low , mid);
		update(query_low , query_high , delta , 2 *node+2 , mid , node_high);

		arr[node] = arr[2 *node+1] + arr[ 2 *node+2];
	}


	ll burn(ll query_low , ll query_high , ll node , ll node_low , ll node_high){
		propagate(node , node_low , node_high);
		if (node_low >= query_high || query_low >= node_high)
		return 0;
		if (node_low >= query_low && query_high >= node_high){
			return arr[node];
		}
        int mid = node_low + node_high >>1;
		ll op1 = burn(query_low , query_high , 2 *node+ 1, node_low , mid);
		ll op2 = burn(query_low , query_high , 2 *node+2,mid , node_high );
		return op1 + op2;
	}


	ll burn(int l , int r ){
        return burn(l , r , 0 , 0 , leader);
	}


	void update(int i , ll val){
		update(i , i+1 , val , 0 , 0 , leader);
	}
	void update(int l , int r , ll val ){
		update(l , r , val , 0 , 0 , leader);
	}

};



struct seg{
	vector<ll>arr,operation;
	int leader;
	seg(int n){
        this->leader = n;
		while (popcount(leader)!= 1){
			++leader;
		}
		arr.resize(2 * leader); operation.assign(2 * leader , -1);
	}

	void propagate(int node , int node_low , int node_high){
		if (~operation[node]){
			arr[node] = operation[node];
			if ((node_high- node_low) >1){// not a leaf
				operation[2 *node+1] = operation[2 *node+2] = operation[node];
			}
			operation[node] = -1;
		}
		return;
	}

	void update(int query_low , int query_high , int delta , int node , int node_low , int node_high){
		propagate(node , node_low , node_high);// make sure all propagation is done at this node
		if (node_low >= query_high || query_low >= node_high) return;
		if (query_high >= node_high && node_low >= query_low){
			operation[node] = delta;
			propagate(node , node_low , node_high);
			return;
		}

		int mid = node_low + node_high >>1;

		update(query_low , query_high , delta , 2 *node+1 , node_low , mid);
		update(query_low , query_high , delta , 2 *node+2 , mid , node_high);

		arr[node] = min(arr[2 *node+2] , arr[2 *node+1 ]);
	}


	ll burn(ll query_low , ll query_high , ll node , ll node_low , ll node_high){
		propagate(node , node_low , node_high);
		if (node_low >= query_high || query_low >= node_high)
		return LLONG_MAX;
		if (node_low >= query_low && query_high >= node_high){
			return arr[node];
		}
        int mid = node_low + node_high >>1;
		ll op1 = burn(query_low , query_high , 2 *node+ 1, node_low , mid);
		ll op2 = burn(query_low , query_high , 2 *node+2,mid , node_high );
		return min(op1 , op2);
	}


	ll burn(int l , int r ){
        return burn(l , r , 0 , 0 , leader);
	}


	void update(int i , ll val){
		update(i , i+1 , val , 0 , 0 , leader);
	}
	void update(int l , int r , ll val ){
		update(l , r , val , 0 , 0 , leader);
	}

};
*/
///////////////////////////////////////
/*
ll n;
vector<bool>vis(N);
vector<int>have(N);
void gen(int i){
    if (i == n){
        for (int x = 0; x < n; ++x) cout <<have[x]<<" \n"[x == n-1];
        return;
    }

    for (int j = 1; j <= n; ++j){
       if(vis[j]) continue;
        vis[   j   ]  = 1;
        have[  i  ] = j;
        gen(i+1);
        vis[have[i]] = 0;
    }

}

*/
/*
struct monster{
    vector<ll>arr; int leader;
    vector<ll>operation;
    monster(int n){
        leader = n;
        while (popcount(leader)!= 1)++leader;
        arr.resize(2 *leader);
        operation.resize(2 *leader);
    }

    void propagate(int node_low , int node_high , int node ){
       if(operation[node]) {
            arr[node] = (node_high-node_low) -arr[node];
            if (node_high - node_low > 1) {
              operation[2*node+1] = operation[2*node+2] = operation[node];
            }
            operation[node] = !operation[node];
        }
        return;
    }


    void update(int query_low , int query_high , int node , int node_low , int node_high){
        propagate(node_low , node_high , node );
        if (query_low >= node_high || node_low >= query_high) return;
        if (node_low >= query_low && query_high >= node_high){
           operation[node] = !operation[node];
            propagate(node_low , node_high , node);
            return;
        }
        int mid = node_low +node_high >> 1;
        update(query_low ,  query_high  , 2*node+1 , node_low , mid);
        update(query_low ,  query_high ,2*node+2 , mid ,  node_high);
        arr[node] = arr[2*node+1] + arr[2*node+2];

    }

    void update(int l , int r ){
        update(l , r+1  , 0 , 0 , leader);
    }


    ll get(int query_low , int query_high , int node , int node_low , int node_high){
        propagate(node_low , node_high , node) ;
         if (query_low >= node_high || node_low >= query_high) return 0;
         if (node_low >= query_low && query_high >= node_high){
            return arr[node];
         }
          int mid = node_low +node_high >> 1;
           ll op1 = get(query_low ,  query_high , 2*node+1 , node_low , mid);
           ll op2 = get(query_low ,  query_high , 2*node+2 , mid ,  node_high);
            return op1+op2;
    }
    ll get(int l , int r) {
        return get(l ,r+1 , 0 , 0 , leader);
    }
};
*/
//////////////////////////////////////////////////////////
struct myT{
    vector<ll>a; int parent;
    vector<ll>lazy;
    void S(int n){
        parent = n;
        while (popcount(parent)!= 1)++parent;
        a = vector<ll>(2 * parent); lazy = vector<ll> (2* parent , -1);
    }
    void propagate(int node_low , int node_high , int node ){
        if (lazy[node] == -1) return;
        a[node] = lazy[node];
        if (node_high - node_low > 1)
            lazy[2*node+1] = lazy[2*node+2] = lazy[node];
        lazy[node] = -1;
        return;
    }

    void update(int query_low , int query_high , int node , int node_low , int node_high , ll v){
        propagate(node_low , node_high , node );
        if (query_low >= node_high || node_low >= query_high) return;
        if (node_low >= query_low && query_high >= node_high){
            lazy[node] = v;propagate(node_low , node_high , node);
            return;
        }
        int mid = node_low +node_high >> 1;
        update(query_low ,  query_high  , 2*node+1 , node_low , mid , v);
        update(query_low ,  query_high ,2*node+2 , mid ,  node_high , v);
        a[node] = a[2*node+1]|a[2*node+2];
    }

    void update(int l , int r  ,ll v){
        update(l , r+1  , 0 , 0 , parent , v);
    }

    ll get(int query_low , int query_high , int node , int node_low , int node_high){
        propagate(node_low , node_high , node) ;
        if (query_low >= node_high || node_low >= query_high) return 0;
        if (node_low >= query_low && query_high >= node_high)
            return a[node];
        int mid = node_low +node_high >> 1;
        ll op1 = get(query_low ,  query_high , 2*node+1 , node_low , mid);
        ll op2 = get(query_low ,  query_high , 2*node+2 , mid ,  node_high);
        return op1|op2;
    }
    ll get(int l , int r) {
        return get(l ,r+1 , 0 , 0 , parent);
    }
};
struct tree{
    int leader ; vector<ll>arr; set<int> st;
    tree(int n){
        leader = n;
        while (popcount(leader) != 1)++leader; arr.resize(2*leader);
    }
    set<int>& update_set(){
        return st;
    };

    void fill_the_tree (int node , int node_low , int node_high){
        if (node_high-node_low == 1){
            arr[node] = st.count(node_low);
            return;
        }
        int mid = node_low + node_high >> 1;
        fill_the_tree(2*node+1 , node_low , mid);
        fill_the_tree(2*node+2 ,mid  , node_high);
        arr[node] = arr[node*2 +1] + arr[node*2+2];
    }
    void fill_the_tree(){
        fill_the_tree(0 , 0 , leader);
    }

    void update(int i , int node , int node_low , int node_high){
        if (node_high-node_low== 1){
            arr[node] = 1;
            return;
        }
        int mid = node_low + node_high >> 1;
        if (i < mid){
            update(i , 2*node+1 , node_low , mid);
        }else{
            update(i , 2*node+2 , mid , node_high);
        }
        arr[node] = arr[node*2+1] + arr[node*2+2];
    }
    void update(int i){
        update(i , 0  , 0 , leader);
    }

    ll get(int query_low , int query_high , int node , int node_low , int node_high){
        if (query_low >= node_high || node_low >= query_high) return 0;
        if (node_low >= query_low && query_high >= node_high){
            return arr[node];
        }
        ll mid = node_low +node_high >> 1;
        ll left_tree = get(query_low , query_high , 2*node+1 , node_low , mid);
        ll right_tree = get(query_low , query_high , 2*node+2 , mid , node_high);
        return left_tree+ right_tree;
    }
    ll get(int l , int r){
        return get(l , r+1 , 0 , 0 , leader);
    }

    void print(){
        cout << "set"<<nd;
        for (auto &i : st) cout <<i<<' ';
        cout <<nd<<" "<<leader<<nd;
        for (int i = 0; i < 2*leader; ++i){
            cout <<i<<' '<<arr[i]<<nd;
        }


    }

};
////////////////////////

struct node{
    ll mx_p , mx_m;
};
struct seg{
    int parent;
    vector<node>tree[2];
    seg(int n){
        parent = n;
        while (popcount(parent)!= 1) ++parent;
        tree[0].resize(2*parent); tree[1].resize(2*parent);
    }

    void update(int i , ll v , int n , int node_low , int node_high , int type){
        if (node_high-node_low == 1){
            tree[type][n].mx_p = v+i; tree[type][n].mx_m = v-i;
            return;
        }
        int mid = node_low +node_high >> 1;
        if (i < mid) {
            update(i, v, 2 * n + 1, node_low, mid, type);
        }
        else {
            update(i, v, 2 * n + 2, mid, node_high, type);
        }
        tree[type][n].mx_m = max(tree[type][2*n+1].mx_m  , tree[type][2*n+2].mx_m);
        tree[type][n].mx_p = max(tree[type][2*n+1].mx_p , tree[type][2*n+2].mx_p);
    }

    void update(int i , ll v , int type){
        update(i , v ,0 , 0 , parent , type);
    }

    ll get(int query_low , int query_high , int n , int node_low , int node_high , bool type , bool p){
        if (node_low >= query_high || query_low >= node_high) return LLONG_MIN;
        if (node_low >= query_low && query_high >= node_high){
            return p ? tree[type][n].mx_p : tree[type][n].mx_m;
        }
        int mid = node_low +node_high >> 1;
        ll left_tree = get(query_low , query_high , 2*n+1 , node_low , mid , type , p);
        ll right_tree = get(query_low , query_high , 2*n+2 ,mid , node_high , type , p );
        return max(left_tree , right_tree);

    }
    ll get(int l , int r , bool up , bool p){// up = 1 , p = 1
        return get(l , r+1 , up , p);
    }
    // p ---> plus

};


void solve(){
    ll m; cin >>m;
    vector<ll>arr[2]; arr[0].resize(m+10); arr[1].resize(m+10);
    seg tree(m+5);
    for (int i = 0; i < 2; ++i){
        for (int j = 1;j <= m; ++j){
            cin >>arr[i][j]; tree.update(j , arr[i][j] , i);
        }
    }


    auto get_ans=[&](ll & ans ){
        ans = 2* (m-1)+1; ans = max(ans , tree.get(1 , m , 1 , 1)-1+1); ans = max(ans  , tree.get(2 , m , 0 , 0)+2*m+2-1);
        ll row  , col ; row = col = 1;
        ll track = 0;
        for (int move = 1; move <= m; ++move){
            if (move %2 == 0){
                col++;
                track = max(track+1 , arr[row][col]+1);
                ll final = track;
                if (col == m){
                    final = max(track , arr[row == 2 ? 1 : 2][col]+1);
                }else{
                    final += 2*(m-col)+1;
                    if (row == 1){
                        final = max(final , tree.get(col+1 , m , 0 , 0)+2*m+2-col);
                        final = max(final , tree.get(col , m , 1 , 1)+1-col);
                    }else{
                        final = max(final , tree.get(col+1 , m , 1 , 0)+2*m+2-col);
                        final = max(final , tree.get(col , m ,0 , 1 )+1-col);

                    }
                }
                ans = max(ans , final);

            }else if (move %4 == 1){
                row++;
                track = max(track+1 , arr[row][col]+1);
            }else{
                row--;
                track = max(track+1 , arr[row][col]+1);
            }
        }

    };
    ll ans = 0;
    get_ans(ans);
    cout << ans<<nd;

}

///////////////////////////
struct node{
public:
    node * next;
    ll data;
    node(ll c){
        next = nullptr; data = c;
    }
};

class T{
public:
    node * root; node *last;
    T(){
        root = last = nullptr;
    }

    void update(ll x){
        node* temp = new node(x);
        if (root == nullptr){
            root = last = temp;
        }
        else{
            last->next = temp;
            last = temp;
        }

    }

    void connect(T & t , T & f){
        if (f.root == nullptr) return;
        if (t.root == nullptr){
            t.root = f.root;
        }
        else{
            t.last->next = f.root;
        }
        t.last = f.last;
        f.root = f.last = nullptr;
    };


};
class the_best_is_still_yet_to_come{
private:
    using node= pair<pair<ll,ll> ,ll>;

    vector<vector<node>> tree;///2d array of node

    vector<node> sort(vector<node> a , vector<node> b){// be careful Don't pass it by ref
        for (auto & i : a){
            i.first.second = arr[i.second].first * i.first.first;
        }
        for (auto & i : b){
            i.first.second = arr[i.second].first * i.first.first;
        }
        vector<node> ret;
        int i  , j ; i = j = 0;

        while (i <(int)a.size() && j < (int)b.size()){
            a[i].first.first > b[j].first.first ? ret.emplace_back(b[j++]): ret.emplace_back(a[i++]);
        }
        while (i < (int)a.size()){
            ret.emplace_back(a[i++]);
        }
        while (j < (int)b.size()){
            ret.emplace_back(b[j++]);
        }
        for (int ii = 1; ii <(int)ret.size(); ++ii){
            ret[ii].first.second += ret[ii-1].first.second;
        }

        return ret;

    }

    vector<node> alone(int i){
        return {{{arr[i].second , arr[i].first* arr[i].second }, i}};

    }
public:
    int parent ;
    void S(int x){
        parent = x;
        while (popcount(parent) != 1) ++ parent;
        tree = vector< vector<node> > (2*parent);
    }

    void fill(int n , int node_low , int node_high ){
        if (node_high- node_low == 1){
            if (node_low < nn) {
                tree[n] = alone(node_low);
            }
            return;
        }

        int mid = node_low + node_high >> 1;
        fill(2*n+1 , node_low , mid);
        fill(2*n+2 , mid , node_high);
        tree[n] = sort(tree[2*n+1] , tree[2*n+2]);
    }

    ll get(int n , int node_low , int node_high , int l , int r , int w1 , int w2){
        if (node_low >= r || l >= node_high) return 0;
        if (r >= node_high && node_low >= l){
            ll L , R ; L = R = -1;
            ll st= 0 , end = (int)tree[n].size()-1;
            while (st <= end){
                ll mid = st + end >> 1;
                if (tree[n][mid].first.first >= w1){
                    L = mid; end = mid-1;
                }else{
                    st = mid+1;
                }
            }if (L == -1) return 0;
            st = 0 , end = (int)tree[n].size()-1;
            while (st <= end){
                ll mid = st + end>> 1;
                if (tree[n][mid].first.first <= w2){
                    R = mid; st = mid+1;
                }
                else{
                    end = mid-1;
                }
            }if (R == -1) return 0;

            return  tree[n][R].first.second-(L ? tree[n][L-1].first.second : 0);
        }
        ll mid = node_low + node_high >> 1;
        ll op1 = get(2*n+1 , node_low , mid , l , r , w1 , w2);
        ll op2 = get(2*n+2 , mid , node_high , l , r , w1 , w2);
        return op1+op2;
    }

    ll get (ll l , ll r , ll w1 , ll w2){
        return get(0 , 0 , parent , l , r+1 , w1 , w2);
    }
    void print_um_el_tree(){
        for (int i = 0;i< 2 *parent ; ++i){
            cout <<i<<" oooooooooo  "<<nd;
            for (auto &el  : tree[i]){
                cout <<el.first.first<<' '<<el.first.second<<' '<<el.second<<"         "<<nd;
            }
        }
    }


};



ll arr[N] , n;
vector<ll> tree , lazy;
void build (ll node , ll node_low , ll node_high){
    if (node_high == node_low){
        tree[node] = arr[node_low]- node_low;
        return;
    }
    int mid = node_low + node_high >> 1;
    build(2* node , node_low , mid) ;
    build(2* node+1 , mid+1 , node_high);
    tree[node] = min(tree[2* node] , tree[2* node+1]);
}
ll value;
void propagate(int node , int l , int r){
    if (!lazy[node]) return;
    tree[node]+= lazy[node];
    if (l != r){
        lazy[2*node]+= lazy[node];
        lazy[2* node+1]+= lazy[node];
    }
    lazy[node]={};
    return;
}
ll get(int node , int node_low  , int node_high , int query_low , int query_high){
    propagate(node , node_low , node_high);
    if ( query_low > node_high || node_low > query_high ||  tree[node] >= 0 ) return n+1;
    if (node_low == node_high){
        value = tree[node];
        return node_low;
    }
    int m = node_low + node_high >> 1;
    ll op1 = get(2* node , node_low , m , query_low , query_high);
    if (op1 < n+1)
        return op1;
    return get(2* node+1 , m+1  , node_high, query_low , query_high);
}

void update(int node , int node_low , int node_high , int query_low , int query_high , ll val ){
    propagate(node , node_low , node_high);
    if (node_low > query_high || query_low > node_high){
        return;
    }
    if (node_low >= query_low && query_high >= node_high){
        lazy[node] = val;
        propagate(node , node_low , node_high);
        return;
    }
    int mid = node_low + node_high>> 1;
    update(2* node , node_low ,mid , query_low , query_high , val);update(2* node+1 , mid+1 , node_high , query_low , query_high , val);
    tree[node] = min(tree[2* node] , tree[2* node+1]);
}
vector<vector<ll>>mytree;
vector<deque<pair<ll,ll>>>st;
vector<ll>b, pre;
void init(int n){
    st.assign(n+5 , {});++n;
    b = pre = vector<ll>(n);
    while (popcount(n) != 1)++ n;
    tree = lazy = vector<ll>(2* n);
    mytree.assign(2*n , {});
}

void _2000(){
    cin >>n;init(n);
    for (int i = 1; i<= n; ++i)
        cin >>arr[i];
    build(1 , 1 , n);
    ll ans = 0;
    for (int i = 1; i<= n; ++i){
        ll idx = get(1 , 1 , n , i , n);
        ans+=idx-i;
        b[i] = idx;
        pre[i] = ans;
        if (idx < n){
            ll v = value;
            update(1 , 1 , n , idx  , idx , -v);
            ll idx2 = get(1 , 1 , n , i , n);
            st[idx].emplace_back(arr[idx]- v, idx2-idx);
            update(1 , 1 , n , idx , idx , v);
        }
        if (i+1 <= n) update(1, 1, n, i + 1, n, 1);
    }
    for (int i = 1; i<= n; ++i){ sort(all(st[i]));
        deque<pair<ll,ll>>q; ll lst = 0;
        while (!st[i].empty()){
            auto  top = st[i].front(); st[i].pop_front();
            top.second+= lst;
            q.emplace_back(top);
            lst = top.second;
        }
        st[i] = q;
    }
    ll q; cin >>q;
    auto go =[&](int i  , ll v)->ll{if (st[i].empty()) return 0;
        ll s = 0 , e = (int)st[i].size()-1;
        ll ret = (int)st[i].size();
        while (s <= e){
            ll m = s + e >> 1;
            if (st[i][m].first > v){
                ret = m; e = m-1;
            }else{
                s = m+1;
            }
        } --ret;
        return  ret >= 0 ? st[i][ret].second : 0;
    };
    build2(1 , 1 , n);
    for (int i = 1; i<= q; ++i){ ll idx  , val ; cin >>idx>> val;
        if (val >= arr[idx]){
            ll cnt =go(idx , val);
            cout << ans+cnt<<nd;
        }
        else{
            ll L = 1 , R = idx- val;
            ll cnt = 0;
            if (L <= R)
                cnt = kill(1 , 1 , n , L , R , idx);
            ll temp = 0;
            if (cnt){
                L = R- cnt;
                temp = - pre[R]+ pre[L];
                temp+= nck(cnt+1 , 2);
                temp+= (idx-R-1) * cnt;
            }
            cout <<ans+temp<<nd;

        }
    }
}
  ll n , x; cin >>n>>x;
   vector<ll>a(n+1); vector<ll>f(x+1,inf) ,l(x+1 , -1);
   for (int i = 1; i<= n; ++i){
       cin >>a[i];
       if (f[a[i]]== inf) f[a[i]] = i;
       l[a[i]] = i;
   }

   if (is_sorted(all(a))){
       cout <<x* (x+1)/2<<nd;
       return;
   }
   vector<ll>lt,rt;
   lt.emplace_back(-1);
   int L = 1; int last_oc = l[L];
   lt.emplace_back(last_oc);
    while (L+1 <= x && last_oc < f[L+1]){
        last_oc = maxz(last_oc , l[L+1]);lt.emplace_back(last_oc); ++L;
    }

    int R = x;
    int foc = f[R];
    rt.emplace_back(inf);
    rt.emplace_back(foc);
    while (R-1 >= 1 && foc > l[R-1]){
        foc = minz(foc , f[R-1]); rt.emplace_back(foc); --R;
    }
    print(lt);
    print(rt);
    ll ans = 0;
    for (auto &i : lt){
        while (!rt.empty() && rt.back() < i) rt.pop_back();
        ans+= (int)rt.size();
    }
    cout <<ans<<nd;




  const int N = 2000000;// number of unique primes untill 1e5 ---> 9592
ll ans = 1;// gcd between any primes
class node{/// by pointers cuz if we construct 2d seg tree without it the program crash
public:
    node *left  , *right;
    ll val;
    node(){
        left = right = nullptr; val = 0;
    };
};

node* T[N]; // seg tree for every prime or 2d seg tree
vector<ll>pr; vector<ll>lp(N);
vector<ll>index(N); int id;
void the_best_is_still_yet_to_come(){
    for (int i = 2;i  < N-5; ++i){
        if (lp[i] == 0){
            lp[i] = i; index[i] = id++;
            pr.emplace_back(i);
        }
        for (int j = 0; j < (int)pr.size() && pr[j]<= lp[i] && i*pr[j] <N-5; ++j){
            lp[i*pr[j]] = pr[j];
        }
    }

}

vector<pair<ll,ll>>Go(ll x){
    vector<pair<ll,ll>>ret;
    while (x > 1){
        int l = lp[x];
        ret.emplace_back(l , 0);
        while (!(x%l)){
            x/=l;
            ret.back().second++;
        }
    }
    return ret;
}

ll fp (ll x  , ll p){// power mod
    if (!p) return 1;
    ll v = fp(x , p/2); v = mul(v , v);
    if (p & 1){
        v = mul(x , v);
    }
    return v;
}
ll inv(ll x){
    return fp(x , mod-2);
}

void burn(node* &n , int node_low , int node_high , int i , ll v ){// the minimum of course the head
    if (!n) n = new node(); // there will be memory leak
    if (node_high-node_low== 1){
        n->val+= v;
        return;
    }
    int mid = node_low + node_high >> 1;
    i < mid ? burn(n->left , node_low , mid , i , v) : burn(n->right , mid , node_high , i , v);
    ll op1 = n->left  == nullptr ? 0: n->left->val; ll op2 = n->right == nullptr ? 0 : n->right->val;
    n->val = min(op1 , op2);
}

ll n  , q;
void update(ll x , int i){

    for (auto &el  : Go(x)){
        ll p = el.first; ll pwr = el.second;
        ll ind = index[p];
        if (T[ind]){// division part
            ans = mul(ans , inv(fp(p , T[ind]->val)));
        }
        burn(T[ind] , 0 , n , i , pwr);
        //  cout << T[ind]-> val<<" oo "<< p<<" "<<pwr<<" "<<x<<" "<<i<<nd;
        ans = mul(ans , fp(p , T[ind]->val));
    }
}
void deleteT(node* &cur){
    if (cur == nullptr) return;
    deleteT(cur->left);
    deleteT(cur->right);
    delete cur; cur = nullptr;
}

void solve(){
    the_best_is_still_yet_to_come();
    cin >>n>>q;

    for (int i = 0; i <N; ++i){
        T[i] = nullptr;
    }
    for (int i = 0;i < n; ++i){
        ll x; cin >>x; update(x , i);
    }
    while (q--){
        int i ,x; cin >>i>>x;--i;
        update(x , i);
        cout << ans<<nd;
    }
    for (int i = 0;i < N; ++i){
        deleteT(T[i]);// T[i] = nullptr;
    }
    ///cout <<(T[0] ? 1 : 0)<<nd;



}


int dx []  {0 ,0  , 1 , -1 , 1 , 1 , -1 , -1};
int dy []  {1 , -1 , 0 , 0 , 1 ,-1 , -1 ,  1};

ll fp(ll base , ll p){
    ll ans = 1;
	while (p){
		if (p &1)
		ans = mul(ans , base);
      p>>=1;
		base = mul(base , base);
	}
	return ans;
}

ll gcd(ll a , ll b){
   ll r0 = a , r1 = b;
   while (r1){
      int next = r0%r1;
      r0 = r1;
      r1 = next;

   }
   return r0;
}


ll Ex_Gcd(ll a , ll b , ll& x0 , ll& y0){
    if (!b){
        x0 = 1; y0 =!x0;
        return a;
    }
    ll x1 , y1;
    ll g = Ex_Gcd(b , a%b , x1 , y1);
    x0 = y1;
    y0 = x1- (a/b) *y1;
    return g;
}

ll nPr(ll n , ll r){
    // fact[n]/fact[n-r];
    ll ans = 1;
    for (ll i = n-r+1; i <= n; ++i){
        ans *= i;
    }
    return ans;
}

ll nCr(ll n , ll r){
    ll res = 1;
    ll FactR = 2;
    for (ll i = n-r+1;i <= n ;++i){
        res = res *i;
        if (r >= FactR && res %FactR == 0){
            res/=FactR++;
        }
    }
    return res;
}
using node = priority_queue<pair<ll,ll> , vector<pair<ll,ll>> , greater<pair<ll,ll>> >;

void init(){
/*
    const int N = 1000+10;
    ll dp[N][N] , dp2[N][N];
    for (int i = 1;i < N; ++i){
        dp[1][i] = 1;
    }
    for (int i= 2;i < N; ++i){
        for (int j = 1; j< N; ++j){
            dp[i][j] = add(dp[i-1][j] , dp[i][j-1]) ;
        }
    }
   // bi >= ai
   for (int i = 1;i <N; ++i){
       for (int j = 1; j < N; ++j){
           dp2[i][j] = add(dp[i][j] , dp2[i][j-1]);
       }
   }
    ll n , m; cin >>n>>m;// range //length
    ll ans = 0;
    for (int i = 1;i <= n; ++i){
        ans = add(ans , mul(dp[m][i] ,dp2[m][n-i+1] ));
    }
    cout <<ans<<nd;
    */

}
function<bool(ll)>go=[&](ll x)->bool{
    node q;
    q.emplace(0 , 1); // depth length
    ll can = 1;// root
    for (auto & L : arr){
        ll left = L/2  , right = (L-1)/2;

        auto top = q.top(); q.pop();
        if (top.second > 1){// add chains
            q.emplace(top.first+1 , top.second-1);
        }
        can-= (x >= top.first);// remove cuz it will connect
        int depth = top.first+2;
        if (left){
            q.emplace(depth , left);
            if (x >= depth){
                can+= min(left , x-depth+1);//+1 to go to the parent
            }
        }
        if (right){
            q.emplace(depth , right);
            if (x >= depth){
                can+= min(right ,x-depth+1 );//+1 to go to the parent
            }
        }
        if (can >= k) return 1;

    }
    return false;
};


ll fp(ll base , ll p){
    ll res = 1;
    while (p){
        if (p &1) res =mul(res , base);
        p/=2;
        base = mul(base , base);
    }
    return res;
}


vector<vector<ll>>dp(2000 , vector<ll>(200 , -1));
ll nCr(ll n , ll r){
    if (dp[n][r] !=-1) return dp[n][r];
    if (r > n) return 0; if (r == 0 || n == r) return 1;
    if (r == 1) return n;
    ll op1 = nCr(n-1 , r-1);
    ll op2 = nCr(n-1 , r);
    return dp[n][r] = add(op1 , op2);
}


ll add (ll a  , ll b){
    return (a + b + mod) %mod;
}
ll mul (ll a , ll b){
    return ( a * b ) % mod;
}

ll gcd(ll a , ll b){ if (b > a) swap(a , b);
    ll r0 = a , r1 = b;
    while (r1){
        ll next = r0%r1;
        r0 = r1;
        r1 = next;

    }
    return r0;
}



ll Ex_gcd(ll a , ll b , ll & x0 , ll& y0){

    auto nxt= [&] (ll &a , ll &b , ll q)-> void{
        ll next = a - q* b;
        a = b ;
        b = next;
    };
    ll r0 = a , r1 = b;
    ll x1 , y1;
    x0 = y1 = 1;
    y0 = x1 = 0;
    while (r1){
        ll q = r0/ r1;
        nxt(r0 , r1 , q);
        nxt(x0 , x1 , q);
        nxt(y0 , y1 , q);
    }
    return r0;
}

ll inverse(ll a , ll M){ ll c , no;
    ll g = Ex_gcd(a , M , c , no);
    if (g != 1){
        return -1;
    }
    /* 11 -- > mod //  -4 %11 = -4 but it mst be 7
    n = bq +r
    -4 = 0 *11 -4
     in math
     -4 = -1*11 +7
     */
    return add(c  , M);
}

int dx[] {1 , 0 , -1 , 0};
int dy[] {0 , 1 , 0,  -1};
const int N = 1e6+10;
struct proofs{
    /*
    we can write any number in terms of any other number
    n = d q +r // r  >= 0 && r < d
    ----> gcd proof
     lets say there is a number c &&  c| a && c| b
      a= bq +r  all equation mod c
     a%c = b%c +r%c then r%c == 0 from that we can say any number divides a && b divides r
     d |b &&  d | r
      a = bq +r all equation mod d
      a%d == b%d + r%d there for a%d == 0 then any number divides b && r divides a

      numbers divides a && b -- > x y z// then r have x , y , z
      number divides b && r --> l m // then a have l  m
      a ->  x , y , z l m
      b -> x y , z , l , m
      r -> x , y , z , l , m
      then the set of common divisors between a&& b  is the same between r && b // gcd between a && b is the same between b && r
      r0 = a , r1 = b
      recurrence relation ri = ri-2 % ri-1
      while(r1){
      ll next = r0%r1;
      r0 = r1; r1 = next
      }
      return r0 -- >  last non zero remainder;
    */
    /*
     extended gcd
     a x + b y = g // g = gcd(a , b) // recurrence relation

     a xi + b yi = ri //  ri = ri-2 % ri-1
     // base case when
      a x0 +b y0 = a from that --> x0 = 1 , y0 = 0
      a x1+ b y1 = b then --> y1 = 1 , x1= 0

     n = bq +r // r = n- b q // q = ri-2/ ri-1
     ri-2 = ri-1 *q +r then
     r =       ri-2 -         q * ri-1
                 |                 |
 a xi-2 + b y-2  = ri-2     //  a xi-1 + b y-1 = ri-1

    a xi + byi = a xi-2+ b yi-2 -q (a xi-1 + b yi-1)

     xi = xi-2 - q * xi-1 // yi = yi-2 -q * yi-1
     */
    /* mod inverse

      5 /5 % mod 7 --> 5^-1  modular inverse

      5 * M == 1 (MOD 7) // congruence relation
      M = 3// 15 %7 == 1

      // Extended gcd
      ax + by = g  mod n
      a * M + b * M  = 1 % n
      a *M = 1 (mod n)
     but for modular inverse gcd (a , m) must == 1
     */

    /*
  a x+ by = c // gcd or multiple of gcd
  a * (x+ b/g) + b * (y-a/g) == c
  a x+ ab/g +b y -ab/g = c
       |           |
   a x + by = c
   x0 = x+ k * b/ g  |||  y0 = y- k* a/g
 */
};

struct combination{
    int N;
    vector<ll>fact , inv;
    ll Fp(ll a , ll b){
        if (!b) return 1;
        ll v = Fp(a , b/2);
        v = mul(v , v);
        if (b & 1)
            v  = mul(a , v);
        return v;
    }
    combination(int N){
        fact = inv= vector<ll>(N); inv.shrink_to_fit(); fact.shrink_to_fit();
        fact[0] = inv[0] =1;
        N-=10;
        for (ll i = 1; i < N; ++i){
            fact[i] = mul(i , fact[i-1]);
            inv[i] = Fp(fact[i] , mod-2);
        }
    }
    ll nPr(ll n , ll r){
        if (r > n|| r < 0) return 0;
        // fact[n]/ fact[n-r]
        return mul(fact[n] , inv[fact[n-r]]);
    }
    ll ncr (ll n , ll r){
        if (r > n|| r < 0) return 0;
        // fact[n]/ fact[r] * fact[n-r]
        return mul(fact[n] , mul(inv[r] , inv[n-r]));
    }
    /*
     nC0 + nC1+ nC2+ ---- nCn --> 2^n  --> we can look at like masks with different state// be careful there nC0
     nC1 + nC3 +nC5 = nC4+ nC2+ nC0 // 2^(n-1)// be careful there nC0
     // reverse thinking good -- == all- bad
     nCr = n/r * nCr(n-1 , r-1)
     // stars and bars // inclusion and exclusion
     */

};


ll Ex_gcd(ll a , ll b , ll & x0 , ll& y0){

    auto nxt= [&] (ll &a , ll &b , ll q)-> void{
        ll next = a - q* b;
        a = b ;
        b = next;
    };
    ll r0 = a , r1 = b;
    ll x1 , y1;
    x0 = y1 = 1;
    y0 = x1 = 0;
    while (r1){
        ll q = r0/ r1;
        nxt(r0 , r1 , q);
        nxt(x0 , x1 , q);
        nxt(y0 , y1 , q);
    }
    return r0;
}

ll de(ll a , ll b , ll c ,ll& x0 , ll& y0){
    ll g = Ex_gcd(abs(a) , abs(b) , x0 , y0);// be careful use abs
    if (c%g){
        return -1;
    }
    x0*= c/g;
    y0*= c/g;
    a >= 0 ? x0*=1 : x0*=-1;
    b >= 0 ? y0*=1 : y0*=-1;
    return g;
}

pair<ll,pair<ll,ll>> num_of_solutions(ll a , ll b , ll c , ll mnx , ll mxx, ll mny , ll mxy){
    ll x , y;
    ll g = de(a , b  , c , x , y);
    if (g == -1){
        return { 0 , {-1 , -1}};
    }
    //x0 = x+ k * b/ g
    //y0 = y- k* a/g
    ll lx , rx ,ly , ry; a/=g; b/= g;
    // mnx -x0 <= k * b <= mxx- x0
    // (mnx-x0)/b <= k <= (mxx-x0)/b
    lx = ceil((mnx-x) *1.0/ b);
    rx = floor((mxx-x)*1.0 / b);
    // mny <= y- k *a <= mxy
    // (mny-y) <= - k * a <= (mxy-y)
    // (-mny+y) >=  k * a >=  (-mxy+y)
    ry = floor((y-mny)*1.0 / a);
    ly = ceil((y-mxy) *1.0 / a);
    ll L = max(ly , lx);
    ll R = min(ry , rx); if (L > R)return { 0 , {-1 , -1}};
    return {R-L+1 , {L , R}};
}
ll mul (ll a, ll b){
    return ((a % mod )  *  (b % mod ) ) % mod;
}

ll add (ll a , ll b){
    return ( (a % mod )  + (b % mod) ) % mod;
}


int nCr( int n , int r ){

    if(!r) return 1 ;

    ll x = nCr(n , r - 1)  % mod ;
    ll y = x * (n - r + 1) % mod ;
    y /= r ;

    return y ;
}

ll fact[N+10] , inv[N+10];
ll inv(ll x){
    return Fp(x , mod-2);
}
void init(){
    fact[0] = inv[0] = 1;
    for (ll i = 1; i <N-5; ++i){
        fact[i] = mul(fact[i-1] , i);
        inv[i] = Fp(fact[i] , mod-2);
    }
}

auto C =[](ll n , ll r)->ll{
    assert(n >= r && r >= 0);
    return mul(fact[n] , mul(inv[r] , inv[n-r]));
};
map<pair<ll,ll>,ll>dp;
ll nCr(ll n , ll r){
    r = min(r , n-r);
    if (!r){
        return dp[{n , r}] = 1;
    }
    if (dp.count({n , r})){
        return dp[{n , r}];
    }
    ll op1 = mul(n * inv(r)  ,  nCr(n-1 , r-1));
    return dp[{n , r}] = op1;
}
int dx[] {1 , 0 , -1 , 0};
int dy[] {0 , 1 , 0,  -1};

ll inv (ll x){
    return Fp(x , mod-2);
}
 ll n ,m , k; cin >>n>>m>>k;
  vector<ll>x(n) , y(m);
  for (int i = 0; i < n; ++i) cin >>x[i];
  for (int i = 0; i < m; ++i) cin >>y[i];
  vector<pair<ll,ll>> positions;
  for (ll &i : x) in_x[i].clear();
  for (ll &i : y) in_y[i].clear();


  for (int i = 0; i < k; ++i){positions.emplace_back();
      cin >> positions.back().first >> positions.back().second;
  }


    sort(all(positions) , [&](pair<ll,ll> & a , pair<ll,ll>& b){
        return a.first < b.first;
    });


  auto get_l =[&](ll x , bool f ){
      ll st = 0 , end = k-1;
      ll ret = k;
      while (st <=end){
          ll mid = st + end >> 1;
          ll ch = (f ? positions[mid].first : positions[mid].second);
          if (ch >= x){
              ret = mid; end = mid-1;
          }else{
              st = mid+1;
          }
      }
      return ret;
  };

  auto get_r =[&](ll x , bool f){
      ll st = 0 ,end = k-1; ll ret = k;
      while (st <= end){
          ll mid = st + end >> 1;
          ll ch = (f ? positions[mid].first : positions[mid].second);
          if(ch > x){
              ret = mid; end = mid-1;
          }else{
              st = mid+1;
          }
      }
      return ret;
  };
    ll ans = 0;
    ll last = 0;

    for (int i = 0; i < n; ++i){ last+= 1; // to protect me from double counting
     ll ret = get_r(x[i]-1 , 1)-get_l(last , 1);
      ans+= C2(ret);
      last = x[i];
  }


    sort(all(positions) , [&](pair<ll,ll> & a , pair<ll,ll>& b){
        return a.second< b.second;
    });

    last = 0;
    for (int i = 0; i < m; ++i){ last+= 1;
        ll ret = get_r(y[i]-1 , 0)- get_l(last , 0);
        ans+= C2(ret);
        last = y[i];
    }

    for (int i = 0;i < k ; ++i){
        in_x[positions[i].first].emplace_back(positions[i].second);
        in_y[positions[i].second].emplace_back(positions[i].first);
    }

    // x

    for (ll & el : x){
        sort(all(in_x[el]));// yes

        auto go =[&](ll _)->ll{
            ll st = 0 , end = m-1;
            ll res = 0;
            while (st <= end){
                ll mid = st + end >> 1;
                if (_ >= y[mid]){
                    res = y[mid]; st = mid+1;
                }else{
                    end = mid-1;
                }
            }
            return res;
        };
        ll cnt = 0;
        ll pre_last = -1;
        for (auto &i : in_x[el]){
            ll nw_last = go(i);
            if (pre_last == nw_last){
                cnt++;
            } else{
                ans-= C2(cnt);
                cnt =( i != nw_last);
            }
            pre_last = nw_last;
        }
        ans-= C2(cnt);
    }


    // y
    for (ll &el: y){
        sort(all(in_y[el]));// yes

        auto go =[&](ll _)->ll{
            ll st = 0 , end = n-1;
            ll res = 0;
            while (st <= end){
                ll mid = st + end >> 1;
                if (_ >= x[mid]){
                    res = x[mid]; st = mid+1;
                }else{
                    end = mid-1;
                }
            }
            return res;
        };
        ll cnt = 0;
        ll pre_last = -1;
        for (auto &i : in_y[el]){
            ll nw_last = go(i);

            if (pre_last == nw_last){
                cnt++;
            } else{
                ans-= C2(cnt);
                cnt = ( i != nw_last); // fixed point 90 degree
            }

            pre_last = nw_last;
        }

        ans-= C2(cnt);
    }
    cout <<ans<<nd;
struct node{
    ll preef , suff , sum , mx;
};
struct monster {
    vector<node>arr;
    int leader;
    monster(int n){
        while(popcount(n) != 1) ++n;
        leader = n; arr.resize(2 * n);
    }
    void single(int nn , int val ){
        arr[nn].preef = arr[nn].suff = arr[nn].mx = arr[nn].sum = val;
    }
    node merge(node left , node right){
        node temp;
        temp.preef = max({left.preef , left.sum+ right.preef});
        temp.suff = max({right.suff ,right.sum + left.suff });
        temp.sum = left.sum + right.sum;
        temp.mx = max({left.mx , right.mx , left.suff+ right.preef});
        return temp;
    }

    void update(int i, int val ,ll _node  , ll node_low , ll node_high){
        if (node_high - node_low == 1){
            return single(_node , val);
        }
        ll mid = (node_low + node_high) >>1;
        if (i < mid){
            update(i,val ,2 *_node+1, node_low, mid);
        }
        else{
            update(i,val ,2 *_node+2, mid, node_high);
        }
        arr[_node] = merge(arr[2 *_node+1] , arr[2 * _node+2]);
    }

    void update(int i , ll val ){
        update(i, val , 0,0, leader);
    }

    node burn (ll query_low , ll query_high , ll N , ll node_low , ll node_high){
        if (node_low >= query_high || query_low >= node_high){
            return {0 , 0 , 0, 0};
        }
        if (node_low >= query_low && query_high >= node_high){
            return arr[N];
        }
        ll mid = (node_low + node_high) >>1;
        node op1 =burn(query_low , query_high ,2 * N +1 , node_low , mid);
        node op2 = burn(query_low , query_high , 2 * N+2 , mid , node_high);
        return merge(op1 , op2);
    }

    node burn(int l , int r){
        if (l > r) return {0 , 0 , 0 , 0};
        return burn(l , r+1 , 0 , 0 , leader);
    }


};

pair<node , node > neu = {{0 , 0 , 0, 0} , {0 , 0 , 0, 0}};
struct monster {
    vector<pair<node , node>>a; // mxsum // mnsum
    int leader;
    monster(int n){
        while(popcount(n) != 1) ++n;
        leader = n; a.resize(2 * n);
    }
    void single(int nn , int val ){
        a[nn].first.pre =  a[nn].first.suf = a[nn].first.sum = a[nn].first.mx = val;
        a[nn].second.pre =  a[nn].second.suf = a[nn].second.sum = a[nn].second.mx = val;
    }
    pair<node , node> merge(pair<node , node> left , pair<node , node> right){
        node temp;
        pair< node , node> ans;
        temp.pre = max({left.first.pre , left.first.sum+ right.first.pre});
        temp.suf = max({right.first.suf ,right.first.sum + left.first.suf });
        temp.sum = left.first.sum + right.first.sum;
        temp.mx = max({left.first.mx , right.first.mx , left.first.suf+ right.first.pre});
        ans.first = temp;
        temp.pre = min({left.second.pre , left.second.sum+ right.second.pre});
        temp.suf = min({right.second.suf ,right.second.sum + left.second.suf });
        temp.sum = left.second.sum + right.second.sum;
        temp.mx = min({left.second.mx , right.second.mx , left.second.suf+ right.second.pre});
        ans.second = temp;
        return ans;
    }

    void update(int i, int val ,ll _node  , ll node_low , ll node_high){
        if (node_high - node_low == 1)
            return single(_node , val);
        ll mid = (node_low + node_high) >>1;
        if (i < mid)
            update(i,val ,2 *_node+1, node_low, mid);
        else
            update(i,val ,2 *_node+2, mid, node_high);

        a[_node] = merge(a[2 *_node+1] , a[2 * _node+2]);
    }

    void update(int i , ll val ){
        update(i, val , 0,0, leader);
    }

    pair<node , node>  burn (ll query_low , ll query_high , ll N , ll node_low , ll node_high){
        if (node_low >= query_high || query_low >= node_high)
            return neu;
        if (node_low >= query_low && query_high >= node_high)
            return a[N];
        ll mid = (node_low + node_high) >>1;
        auto op1 =burn(query_low , query_high ,2 * N +1 , node_low , mid);
        auto op2 = burn(query_low , query_high , 2 * N+2 , mid , node_high);
        return merge(op1 , op2);
    }

    pair< node , node> burn(int l , int r){
        if (l > r) return neu;
        return burn(l , r+1 , 0 , 0 , leader);
    }


};
vector<ll>phi(N);
void build() {
    iota(phi.begin() ,phi.end() , 0);
    for (int i = 2; i < N; ++i) {
        if (phi[i]== i) {
            for (int j = i; j < N; j += i)
                phi[j] -= phi[j] / i;
        }
    }
}

int mob[N];
void mobi() {
    mob[1] = 1;
    for (int i = 2; i < N; i++){
        mob[i]--;
        for (int j = i + i; j < N; j += i) {
            mob[j] -= mob[i];
        }
    }
}

void init ( int k )
{
    for ( int i = 2 ; i < N ; i++)
        mobius[i] = -1 , p[i] = 1;
    for ( ll i = 2 ; i < k ; i++)
    {
        if (p[i] == 1) {
            p[i] = i ;
            mobius[i] = 1;
            for (ll j = 2 * i ; j < N ; j += i)
                mobius[j] = j%(i*i) == 0 ? 0 : -mobius[j], p[j] *= i;
        }
    }
}
vector<int>prime;
vector<int>primes;
vector<char> mu;
ll a , b , k;
void mobi(){
    prime = vector<int>(N , 1); prime.shrink_to_fit();
    mu = vector<char>(N , 1); mu.shrink_to_fit();
    for (ll i = 2; i *k <= b&& i < k; ++i){
        if (prime[i]== 1){
            for (ll j = i; j * k <= b && j < N; j+=i){
                mu[j] = (j % (i *i )== 0 ? 0 : -mu[j]);
                prime[j]*=i;
            }
        }
    }
}

ll mul (ll a, ll b){
    return ( ( a % mod ) * ( b % mod ) ) % mod;
}
ll add (ll a , ll b){
    return (a + b + mod) % mod;
}
ll Fp (ll a , ll b){
    if (!b) return 1;
    ll v = Fp(a , b/2);
    v = mul(v , v);
    if (b & 1){
        v = mul(v  , a);
    }
    return v;
}

ll inv (ll x){
    return Fp(x , mod-2);
}

ll fact[N];

void init(){
    fact[0] =1;
    for (ll i = 1; i <N; ++i){
        fact[i] = fact[i-1] * i % mod;
    }
}
ll npr(ll n , ll r){// fact[n]/ fact[n-r]
    if (r > n|| r < 0) return 0;
    return mul(fact[n] , inv(fact[n-r]));
}
ll ncr (ll n , ll r){ // fact[n]/ fact[r] * fact[n-r]
    if (r > n|| r < 0) return 0;
    return mul(npr(n , r), inv(fact[r]));
}
ll ll gcd (ll r0 , ll r1){
    while (r1){
        ll next = r0% r1;
        r0 = r1;
        r1= next;
    }
    return r0;
}
void _2600(){
    ll n; cin >>n;ll ans = 0;
    for (int i = n/2 + (n/2)%2; i <= n; i+=2){
        ll ways1 = nCr(i , n-i)+ nCr(i-1 , n-i-1);
        // how many ways we put n-i cells in i places
        // plus the first cell is empty so the remain is n-i-1 free cells and i-1 places
        ans= (ans + 2* fact[i] * ways1) % mod;
    }
    cout <<ans<<nd;

}
ll lcm (ll a , ll b){
    return a / gcd(a , b) *b;
}
*/
ll c2(ll n) {
    return n * (n-1)/2;
}

vector<ll> f(N);
void add(ll x){
    for (ll &i : d[x]){
        if (prime[i]== i)
            ans -= mu[i] * f[i]++;
    }
}
void remove(ll x){
    for (ll &i : d[x]){
        if (prime[i]== i)
            ans+= --f[i] * mu[i];
    }
}


pre();
ll n;
cin >> n;
ll q;
cin >> q;
vector<ll> arr(n);
for (ll &i: arr) cin >> i;
while (q--){ int idx; cin >> idx; idx--;
have[idx] ? remove(arr[idx]) : add(arr[idx]);
tot+= (have[idx] ? -1 : 1);
have[idx] = !have[idx];
cout <<c2(tot)- ans<<nd;

}

ll gcd(ll r0, ll r1){
    while (r1){
        ll next = r0%r1;
        r0 = r1;
        r1 = next;
    }
    return r0;
}
vector<pair<ll,ll>> freq;vector<ll> v;
void go (int i , ll mul){
    if (i == (int)freq.size()){
        v.emplace_back(mul);return;
    }
    go(i+1 , mul);
    for (int j = 1; j <= freq[i].second; ++j){
        mul*= freq[i].first;
        go(i+1 , mul);
    }
}

ll euclid(ll a , ll b , ll & x0 , ll& y0){
    auto nxt= [&] (ll &a , ll &b , ll q)-> void{
        ll next = a - q* b;
        a = b ;
        b = next;
    };
    ll r0 = a , r1 = b; ll x1 , y1;x0 = y1 = 1; y0 = x1 = 0;
    while (r1){
        ll q = r0/ r1;
        nxt(r0 , r1 , q);
        nxt(x0 , x1 , q);
        nxt(y0 , y1 , q);
    }
    return r0;
}
ll inverse(ll a , ll M){ ll c , no;
    ll g = euclid(a , M , c , no);
    if (g != 1){
        return -1;
    }
    /* 11 -- > mod //  -4 %11 = -4 but it mst be 7
    n = bq +r // -4 = 0 *11 -4
    but another solution is // -4 = -1*11 +7
     */
    return (c % M + M) % M;
}
/*  the system is solvable if and only if
 *  case 1) all mods are pairwise gcd
 *  case 2) every ai is congruent to aj mod gcd(ni , nj)
 */
ll solve_relative_primes(vector<ll> & rems  , vector<ll> & mods){ // if and only if the mods are pairwise gcd
    ll lc = 1; ll x = 0;
    for (auto &i : mods) lc *= i;
    for (int i = 0; i< (int)mods.size(); ++i){
        x+= lc/ mods[i] * rems[i] * inverse(lc/ mods[i] , mods[i]);
    }
    return x % lc;
}
ll de(ll a , ll b , ll c ,ll& x0 , ll& y0){
    ll g = euclid(abs(a) , abs(b) , x0 , y0);// be careful use abs
    if (c%g){
        return -1;
    }
    x0*= c/g;// may c negative it will be okay
    y0*= c/g;
    a >= 0 ? x0*=1 : x0*=-1;
    b >= 0 ? y0*=1 : y0*=-1;
    return g;
}
ll solve_system(vector<ll> & rems  , vector<ll> & mods){//  case 2) every ai is congruent to aj mod gcd(ni , nj) // nasted loops check
    ll rem = rems[0]; ll Mod = mods[0];
    // T is congruent to x Mod n  which means x mod n is equal to T mod n
    // T is congruent to y Mod m
    // T = k *n + x // T = p * m + y
    // k * n +x = p * m + y
    // k * n - p * m = y -x
    for (int i = 1; i < (int)mods.size(); ++i){
        ll x , y; ll a = Mod , b = -mods[i] , c = rems[i] - rem;
        ll g = de(a , b , c , x , y); if (g == -1) return -1; if (rems[i] % g != rem % g) return -1;
        assert(x * a + b *y == c);
        rem += Mod * x;
        Mod = Mod / g * mods[i]; // the new mod is the lcm
        rem = (rem % Mod + Mod) % Mod;
    }
    return rem;
}
struct monster{
    vector<pair<ll,ll>> tree , lazy; ll s;// mx  mn
    monster(int n){
        s = n;while (popcount(s)!= 1)++s;
        tree.resize(2 *s);lazy.resize(2 *s);
    }
    void propagate(int node_low , int node_high , int node ){
        if (!lazy[node].second  && !lazy[node].first) return;
        tree[node].first+=  lazy[node].first ;
        tree[node].second+=  lazy[node].second ;
        if (node_high-node_low > 1){
            lazy[2*node+1].first+= lazy[node].first; lazy[2*node+2].first+= lazy[node].first;
            lazy[2*node+2].second+= lazy[node].second; lazy[2*node+1].second+= lazy[node].second;
        }
        lazy[node].first = lazy[node].second ={};
        return;
    }

    void update(int query_low , int query_high , int node , int node_low , int node_high ,ll val){
        propagate(node_low , node_high , node );
        if (query_low >= node_high || node_low >= query_high) return;
        if (node_low >= query_low && query_high >= node_high){
            lazy[node].first = lazy[node].second += val;
            propagate(node_low , node_high , node);
            return;
        }
        int mid = node_low +node_high >> 1;
        update(query_low ,  query_high  , 2*node+1 , node_low , mid , val);
        update(query_low ,  query_high ,2*node+2 , mid ,  node_high , val);
        tree[node].first = max(tree[2*node+1].first , tree[2*node+2].first);
        tree[node].second = min(tree[2*node+1].second , tree[2*node+2].second);
    }

    void update(int l , int r  ,ll val){
        update(l , r+1  , 0 , 0 , s , val);
    }
    void update(int i , int node , int node_low , int node_high ,ll val ){
        if (node_high-node_low== 1){
            tree[node]= {val , val};
            return;
        }
        int mid = node_low + node_high >> 1;
        if (i < mid){
            update(i , 2*node+1 , node_low , mid , val );
        }else{
            update(i , 2*node+2 , mid , node_high , val);
        }
        tree[node].first = max(tree[2*node+1].first , tree[2*node+2].first);
        tree[node].second = min(tree[2*node+1].second , tree[2*node+2].second);
    }
    void update(int i ,ll val ){
        update(i , 0  , 0 , s , val );
    }

    ll get(int query_low , int query_high , int node , int node_low , int node_high ,bool mn){ // 1 mn // 0 mx
        propagate(node_low , node_high , node) ;
        if (query_low >= node_high || node_low >= query_high) return mn ? LLONG_MAX : LLONG_MIN;
        if (node_low >= query_low && query_high >= node_high){
            return mn ? tree[node].second : tree[node].first;
        }
        int mid = node_low +node_high >> 1;
        ll op1 = get(query_low ,  query_high , 2*node+1 , node_low , mid ,mn);
        ll op2 = get(query_low ,  query_high , 2*node+2 , mid ,  node_high , mn);
        return mn ? min(op1 , op2) : max(op1 , op2);
    }
    ll get(int l , int r , bool mn) {
        return get(l ,r+1 , 0 , 0 , s , mn);
    }
    void print( int node , int node_low , int node_high ){
        propagate(node_low , node_high , node) ;
        if (node_high-node_low== 1){
            cout <<node_low<<' '<< node_high-1<< " mn "<< tree[node].second<<" mx "<< tree[node].first<<nd;
            return;
        }
        int mid = node_low + node_high >> 1;
        print( 2*node+1 , node_low , mid );
        print( 2*node+2 , mid , node_high);
        tree[node].first = max(tree[2*node+1].first , tree[2*node+2].first);
        tree[node].second = min(tree[2*node+1].second , tree[2*node+2].second);
        cout <<node_low<<' '<< node_high-1<< " mn "<< tree[node].second<<" mx "<< tree[node].first<<nd;
    }
    void print(){
        print(0  , 0 , s );
    }

};

struct Leonidas{// zero based
    int n;
    vector < vector <ll > > table; vector <int >Log;
    void init(vector <ll> & a){
        n = (int)a.size();
        table = vector < vector <ll > > (n+5 , vector <ll> (LOG+1));
        Log = vector <int > (n+5);
        for (int i = 0; i <= n; ++i){
            table[i][0] = (i < n ? a[i] : 0);
            Log[i] = (i > 1 ?  Log[i >> 1] +1 : 0);
        }
        build();
    }
    ll merge (ll u ,ll v){
        return max (u , v);
    }
    void build(){
        for (ll j = 1; j < LOG; ++j)
            for (ll i = 0; i + (1ll << j)-1 < n; ++i)
                table[i][j] = merge(table[i][j-1] , table[i+ (1ll << (j-1))][j-1]);
    }

    ll query(ll l ,ll r){
        int L = Log[r -l+1];
        return merge(table[l][L] , table[r-(1ll << L) + 1][L]);
    }

};

ll fastest_gcd(ll a, ll b) {
    if (!a || !b)
        return a | b;
    unsigned shift = __builtin_ctzll(a | b);
    a >>= __builtin_ctzll(a);
    do {
        b >>= __builtin_ctzll(b);
        if (a > b) swap(a, b); b -= a;
    } while (b);
    return a << shift;
}
ll calc (ll a , ll b){ if (b > a) swap(a , b);
    if (!a || !b) return a|b;
    if ((a & 1) && (b & 1)) return calc(a-b , b);
    if (!(a & 1) && !(b & 1)) return 2* calc(a >> 1 , b >> 1);
    if (a & 1) return calc(a-b , b >> 1);
    if (b & 1) return calc(a >> 1 , b);
    assert(0);
}
void sparta(vector<ll>&arr){
    vector<ll>go = arr;
    sort(all(go));
    go.resize(unique(all(go))-go.begin());
    int n = arr.size();
    for (int i =0;i <n; ++i){
        arr[i] = upper_bound(all (go) , arr[i])-go.begin();
    }
}template<typename T>
struct fenwick
{
    const int n;
    vector<T>arr;
    fenwick(int n):n(n) ,arr(n+1){};
    void upd(int x , T val){
        for (int i = x; i <= n; i += (i &-i)){
            arr[i]+=val;
        }
    }
    T query (int i){
        T ans {};
        while (i >0){
            ans +=arr[i];
            i -= i &-i;
        }
        return ans;
    }
    T query(int l , int r){
        return query(r)- query(l-1);
    }
};
ll mul (ll a, ll b){
    return ( ( a % mod ) * ( b % mod ) ) % mod;
}
ll add (ll a , ll b){
    return (a + b + mod) % mod;
}

ll nck(ll n , ll r){ if (n < r || r < 0) return 0;
    ll ans = 1; ll f = 2;r = min(r , n-r);
    for (ll i = n-r+1; i <= n; ++i) { ans *= i ;  if (f <= r && ans %f == 0) ans/= f++; }
    return ans;
}

ll sq (ll n){
    return n * (n +1) * (2 * n +1)/6;
}

ll pascal (ll n , ll k){
    return nck(n+k-1 , k);
}
const int N = 1e7+100;
struct Leonidas{
    int n , LOG; vector<ll> a;
    vector< vector<pair<ll,ll>> >table ; vector<ll>logTwo;
    void init(vector<ll>& arr){
        a = arr; n = (int)arr.size(); LOG = 20;
        table = vector<vector<pair<ll,ll>>> (n+5 , vector<pair<ll,ll>>(LOG+1));
        logTwo= vector<ll> (n+5);
        build();
    }
    pair<ll,ll> merge(pair<ll,ll>& u, pair<ll,ll>& v) {
        return min(u, v);
    }
    void build() {
        logTwo[1] = 0;
        for (int i = 2; i <= n; i++)
            logTwo[i] = logTwo[i >> 1] + 1;

        for (int i = 0; i < n; i++)
            table[i][0] = {a[i] , i};

        for (int j = 1; j < LOG; j++)
            for (int i = 0; i + (1 << j) - 1 < n; i++)
                table[i][j] = merge(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);
    }
    pair<ll,ll> query(int l, int r) {
        int len = r - l + 1;
        int power = logTwo[len];
        return merge(table[l][power], table[r - (1 << power) + 1][power]);
    }
};
void killer(){
    ll n , m , k; cin >>n>>m>>k;
    vector<ll>a(n); for (ll &i : a) cin >>i;
    vector<ll>ans(m);
    vector<ll>mn; deque<ll>q;
    for (int i= 0; i< n; ++i){
        while (!q.empty() && a[q.back()] >= a[i] ) q.pop_back();
        while (!q.empty() && i-q.front() > k) q.pop_front();
        q.emplace_back(i);
        if (i >= k)mn.emplace_back(a[q.front()]);
    }
    assert((int)mn.size() == n-k);
    vector<vector<vector<pair<ll,ll>>>>qu(k , vector<vector<pair<ll,ll>>>(n/k+2));
    // l % k && l /k  && num of parts  , id
    for (int i = 0; i< m; ++i){
        ll l , r; cin >>l>>r;l-- , r--;
        ans[i]+= a[l];
        qu[l%k][l/k].emplace_back((r-l)/k , i);
    }

    for (int i = 0; i< k; ++i){ // mods
        vector<ll>c;
        for (int j = i; j <n-k; j+=k) c.emplace_back(mn[j]);
        int len = (int)c.size();
        Leonidas table ; table.init(c);
        stack<ll>st; vector<ll>nxt(len);
        vector<ll>dp(len+1);
        // dp[len] = starting from len to the end of array what is the min cost // prefix
        // dp[i] = a[i] * range mn of a[i] + dp[nxt_mn]
        // ans(l , r) dp[l] -dp[mn] + need of mn

        for (int j = len-1; j >= 0 ; -- j){
            while (!st.empty() && c[st.top()] >= c[j]) st.pop();
            nxt[j] = st.empty() ? len : st.top(); st.emplace(j);
            dp[j] = c[j]* (nxt[j]-j) + dp[nxt[j]];
        }
        for (int j = 0; j <= n/k; ++j){
            for (auto & f: qu[i][j]){
                int qid = f.second;
                ll d = f.first;
                if (!d) continue;
                ll idx = table.query(j , j+d-1).second;
                ll dpr = dp[nxt[idx]] + (nxt[idx]-idx) * c[idx];
                ans[qid]+= dp[j] + (j+d-idx) * c[idx] - dpr;

            }
        }
    }
    for (auto &i : ans) cout <<i<<nd;

}
vector<ll>lp(N);vector<ll> pr;
void the_best_is_still_yet_to_come(){
    mu[1] = 1;
    for (int i = 2;i <= 1e7; ++i){
        if (lp[i] == 0){
            lp[i] = i; mu[i]= -1;
            pr.emplace_back(i);
        }
        for (int j = 0; j < (int)pr.size() && pr[j]<= lp[i] && i*pr[j] <= 1e7; ++j){
            lp[i*pr[j]] = pr[j];
            if (i % pr[j]== 0){
                mu[i * pr[j]]= 0;break;
            }
            else mu[pr[j] * i]= -mu[i];
        }
    }

}
auto enk7 =[&](ll x1 ,ll  y1 , ll x2 , ll y2  , ll val)->ll{
    ll ans = arr[x2][y2][val]-arr[x2][y1-1][val]-arr[x1-1][y2][val]+arr[x1-1][y1-1][val];
    return ans;
};
ll get(int l , int r){
    return l + rand() % (r-l+1);
}
srand(time(NULL));
ll n;
vector<ll>a;
int go(int l , int r ,int pivot){
    int cnt = 0;
    for (int i = l; i <= r; ++i)
        cnt+= (a[i] < a[pivot]);
    return cnt;
}
void solve(int l , int r ){
    if (l >= r) return;
    int pivot = get(l , r);
    int id = l +go(l , r , pivot);
    swap(a[id] , a[pivot]);pivot = id;
    for (int i = l , j = r; i < pivot && j > pivot ; ++i , --j){
        while (a[i] < a[pivot])++i;
        while (!(a[j] < a[pivot])) --j;
        if (i < pivot && j > pivot) {
            assert((a[i] < a[j]) == 0);
            swap(a[i] , a[j]);
        }
    }
    int last = id;
    for (int i = last; i<= r; ++i){
        if (a[i] == a[pivot])
            swap(a[i] , a[last++]);

    }
    solve(l , pivot-1);
    solve(last , r);
}

class node{
public:
    int  data;node * nxt;
    node(int c){
        data = c; nxt = nullptr;
    }
};

class T{
public:
    node * root; node * last;
    T(){
        root = last = nullptr;
    }
    void update(int c){
        node * temp = new node(c);
        if (root == nullptr)
            root = last = temp;
        else{
            last->nxt = temp;last = temp;
        }
    }
};

T myl[30];
ll dp[N];
ll inv (ll x){
    if (dp[x] != -1) return dp[x];
    return dp[x] = Fp(x , mod-2);
}
ll c(ll n , ll r){ if (n < r || r < 0) return 0;
    r = min(r , n-r);
    if (!r) return 1;
    ll op1 = mul(mul(n  ,  inv(r)) ,  c(n-1 , r-1));
    return op1;
}

/*
ll solve(int i  , int cnt , ll sum){
    if (i == n) {
        int cc = cnt & 1 ? -1 : 1;
        ll ret = c(s+n-1-cnt-sum, n-1) * cc;
        return ret;
    }
    ll op1 = solve(i+1 , cnt , sum);
    ll op2 = solve(i+1 , cnt+1  ,sum+a[i]);
    return add(op1 , op2);
}
*/
struct king{
    vector<ll>arr,lazy;int leader;
    void S(int n){
        this->leader = n;
        while (popcount(leader)!= 1) ++leader;
        arr.resize(2 * leader); lazy = vector<ll>(2 * leader , -1);
    }

    void propagate(int node , int node_low , int node_high){
        if (lazy[node] == -1) return;
        arr[node] = lazy[node] * (node_high- node_low);
        if (node_high-node_low > 1){
            lazy[2* node+1]=lazy[node];
            lazy[2* node+2]=lazy[node];
        }
        lazy[node]= -1;
        return;
    }

    void update(int query_low , int query_high , int delta , int node , int node_low , int node_high){
        propagate(node , node_low , node_high);// make sure all propagation is done at this node
        if (node_low >= query_high || query_low >= node_high) return;
        if (query_high >= node_high && node_low >= query_low){
            lazy[node] = delta;propagate(node , node_low , node_high);return;
        }
        int mid = node_low + node_high >>1;
        update(query_low , query_high , delta , 2 *node+1 , node_low , mid);
        update(query_low , query_high , delta , 2 *node+2 , mid , node_high);
        arr[node] = arr[2 *node+1] + arr[ 2 *node+2];
    }

    ll burn(ll query_low , ll query_high , ll node , ll node_low , ll node_high){
        propagate(node , node_low , node_high);
        if (node_low >= query_high || query_low >= node_high)
            return 0;
        if (node_low >= query_low && query_high >= node_high)
            return arr[node];
        int mid = node_low + node_high >>1;
        ll op1 = burn(query_low , query_high , 2 *node+ 1, node_low , mid);
        ll op2 = burn(query_low , query_high , 2 *node+2,mid , node_high );
        return op1 + op2;
    }

    ll get(int l , int r ){
        return burn(l , r+1 , 0 , 0 , leader);
    }

    void update(int i , ll val){
        update(i , i+1 , val , 0 , 0 , leader);
    }
    void update(int l , int r , ll val ){
        update(l , r+1 , val , 0 , 0 , leader);
    }

};
void kill(){
    for (ll i = 2; i <= 1e5; ++i){
        if (!lp[i]) pr.emplace_back(i) , lp[i] = i;
        for (auto &p : pr){
            if (p > lp[i] || i * p > 1e5) break;
            assert(!lp[i * p]);lp[i * p] = p;
        }
    }
}
template < typename T , class F = function<T(const T&  , const T&)>>
class sword{
public:
    ll SQ = 2000;
    vector<T>bucket;
    F func;
    void build (const vector<ll> &a , const F & f){
        const int n = (int)a.size();
        func = f; int s = (n+SQ-1)/ SQ;
        bucket = vector<T> (++s);
        for (int i = 0; i < n;++i)
            bucket[i/SQ] =  func(bucket[i/SQ] , i);
    }
    ll query(ll l ,ll r){
        ll ans = l;
        for (int i = l; i <= r;){
            if (i % SQ == 0 && i+SQ-1 <= r)
                ans = func(ans , bucket[i/SQ]) , i+=SQ;
            else ans =  func(ans , i) , ++i;
        }
        return ans;
    }
    void print(){
        for (auto &i : bucket)
            cout << i<<nd;
    }

};
const int LOG = 20; ll n;
vector<ll> depth;vector<vector<ll>>ancestor , ad;
void dfs(int node , int par){
    depth[node] = depth[par]+1;
    ancestor[node][0] = par;
    for (int i = 1; i <LOG; ++i){
        ancestor[node][i] = ancestor[ancestor[node][i-1]][i-1];
    }
    for (auto &ch : ad[node]){
        if (par != ch)
            dfs(ch , node);
    }
}
ll kth_ancestor(int node , int k){
    for (int i = LOG-1; ~i ; --i){
        if (k & (1 << i))
            node = ancestor[node][i];
    }
    return node;
}
ll lca (int u , int v){
    if (depth[u] < depth[v])
        swap(u , v);
    u = kth_ancestor(u , depth[u]-depth[v]);
    if (u == v) return u;
    for (int i = LOG-1; ~i ; --i){
        if (ancestor[u][i] != ancestor[v][i]){
            u = ancestor[u][i];
            v = ancestor[v][i];
        }
    }
    return ancestor[u][0];
}
void addEdge(int f, int t){
    to[ne] = t;
    nxt[ne] = head[f];
    head[f] = ne++;
}
struct node{
    ll pre , mx , sum , suf;
};
pair<node , node> merge(pair<node , node> left , pair<node , node> right){
    node temp;
    pair< node , node> ans;
    temp.pre = max({left.first.pre , left.first.sum+ right.first.pre});
    temp.suf = max({right.first.suf ,right.first.sum + left.first.suf });
    temp.sum = left.first.sum + right.first.sum;
    temp.mx = max({left.first.mx , right.first.mx , left.first.suf+ right.first.pre});
    ans.first = temp;
    temp.pre = min({left.second.pre , left.second.sum+ right.second.pre});
    temp.suf = min({right.second.suf ,right.second.sum + left.second.suf });
    temp.sum = left.second.sum + right.second.sum;
    temp.mx = min({left.second.mx , right.second.mx , left.second.suf+ right.second.pre});
    ans.second = temp;
    return ans;
}

ll SQ;
struct query{
    ll idx , block_id , l  , r;
    query (int _l  , int _r , int i ){
        idx = i; l = _l ; r = _r; block_id = l/SQ;
    }
    bool operator < (const query & rhs) const{
        if (block_id != rhs.block_id)
            return l < rhs.l;
        return r < rhs.r;
    }
};
vector<query>queries;vector<ll>a;
ll f; vector<ll> freq(N);
int n , q  ,l , r = -1;
void update(int i , int s){
    f-= a[i] * freq[a[i]] * freq[a[i]];
    freq[a[i]]+= s;
    f+= a[i] * freq[a[i]] * freq[a[i]];
}
void solve (int i){
    while (r < queries[i].r) update(++r , 1); //++r; // add
    while (l > queries[i].l) update(--l , 1); //--l; // add
    while (r > queries[i].r) update(r-- , -1); //r--;// rem
    while (l < queries[i].l) update(l++ , -1); //l++; // rem

}
void test_case(int tc) {
    cin >>n>>q;
    a = vector<ll>(n);
    for (ll &i : a) cin >>i;
    SQ = sqrtl(n); ++SQ;

    for (int i= 0; i < q; ++i){ int l , r; cin >>l>>r;
        queries.emplace_back(--l , --r , i);
    }
    vector<ll>ans(q);
    // complexity n * sq(n) + q * sq(n)
    sort(all(queries));
    r = -1;
    for (int i = 0; i < q; ++i){
        solve(i);
        ans[queries[i].idx] = f;
    }
    for (auto &i : ans) cout << i<<nd;

}
const int LOG = 18; ll n;
vector<ll> depth;vector<vector<ll>>ancestor , ad;
vector<ll>ans;
void dfs(int node , int par){
    depth[node] = depth[par]+1;
    ancestor[node][0] = par;
    ans[node] = depth[node]-1;
    for (int i = 1; i <LOG; ++i){
        ancestor[node][i] = ancestor[ancestor[node][i-1]][i-1];
    }
    for (auto &ch : ad[node]){
        if (par != ch)
            dfs(ch , node);
    }
}
ll kth_ancestor(int node , int k){
    for (int i = LOG-1; ~i ; --i){
        if (k & (1 << i))
            node = ancestor[node][i];
    }
    return node;
}
ll lca (int u , int v){
    if (depth[u] < depth[v])
        swap(u , v);
    u = kth_ancestor(u , depth[u]-depth[v]);
    if (u == v) return u;
    for (int i = LOG-1; ~i ; --i){
        if (ancestor[u][i] != ancestor[v][i]){
            u = ancestor[u][i];
            v = ancestor[v][i];
        }
    }
    return ancestor[u][0];
}

void init(){
    ad = vector<vector<ll>>(n+10);
    ancestor = vector<vector<ll>> (n+10 , vector<ll>(LOG+1));
    ans = depth = vector<ll>(n+10);
}
void bfs (deque<ll> & q){
    while (!q.empty()){ int s = (int)q.size();
        while (s--) {
            int node = q.front();
            q.pop_front();
            for (auto &ch: ad[node])
                if (ans[ch] > ans[node] + 1) {
                    ans[ch] = ans[node] + 1;
                    q.emplace_back(ch);
                }
        }

    }
    assert(q.empty());
}
ll dist (int u , int v){
    return depth[u]+ depth[v] - 2* depth[lca(u , v)];
}
void test_case(int tc) {int q;
    cin >>n>>q;
    init();
    for (int i = 0; i+1 < n; ++i){
        int u , v; cin >>u>>v;
        ad[u].emplace_back(v);
        ad[v].emplace_back(u);
    }
    dfs(1 , 1);
    deque<ll> reds;
    // complexity q * sq(q)* lg(n) + n * sq(q)
    while (q--){
        int op , node; cin >>op>> node;
        if (op == 1){
            ans[node] = 0;
            reds.emplace_back(node);
            if ((int)reds.size() == 350)
                bfs(reds);
        }
        else{
            ll res = ans[node];
            for (auto &i : reds) res = min(res , dist(i , node));
            cout << res<<nd;
        }

    }

}
ll colourBit(ll c){
    return 1ll << c;
}
vector<vector<ll>>ad(N);
vector<ll>col(N) , in(N) , out(N); int tim ;
void dfs(int node , int p){
    in[node] = tim++;
    for (auto &ch : ad[node]){
        if (ch != p)
            dfs(ch , node);
    }
    out[node] = tim-1;
}
vector<ll>node_colour(N);
vector<ll>lazy(N , -1) , bucket(N);
void main_(int tc) {
    // sqrt decomposition on starts
    ll n , q  ,u , v , c; cin >>n>>q;
    for (int i = 0; i < n; ++i)
        cin >>col[i];
    for (int i = 1; i < n; ++i){cin >>u>>v;--u; --v;
        ad[u].emplace_back(v);
        ad[v].emplace_back(u);
    }
    ll SQ = sqrtl(n); ++SQ; ll s = (n+SQ-1)/SQ;

    dfs(0 , -1);
    assert(tim == n);

    auto calc =[&](ll f)->ll{
        ll ans = 0;
        while (f) ans+= f & 1 , f >>= 1;
        return ans;
    };
    for (int i = 0; i < n; ++i){
        c = col[i];
        u = in[i];
        v = out[i];
        bucket[u/SQ]|= colourBit(c);
        node_colour[u] = c;
    }

    auto re_build =[&](ll s , ll e){
        ll num_of_bucket = s/SQ;
        bucket[num_of_bucket] = 0;
        for (int i = num_of_bucket * SQ; i < num_of_bucket *SQ+ SQ; ++i){
            if (i >= s && i <= e)
                node_colour[i] = c;
            else if (lazy[num_of_bucket] != -1)
                node_colour[i] = lazy[num_of_bucket];
            bucket[num_of_bucket]|= colourBit(node_colour[i]);
        }
        lazy[num_of_bucket] = -1;
    };
    while (q--){
        cin >> n>> v;--v;
        if (n == 2){ // ans
            ll ans = 0;
            u = in[v];
            v = out[v];
            for (int i = u ; i <= v; ++i){
                if (i %SQ == 0 && i+SQ-1 <= v){
                    ans|= bucket[i/SQ]; i+= SQ-1;continue;
                }
                if (lazy[i/SQ]!= -1) ans|= colourBit(lazy[i/SQ]);
                else ans|= colourBit(node_colour[i]);
            }
            cout << calc(ans)<<nd;
            continue;
        }
        cin >>c;
        u = in[v]; v = out[v];
        for (int i = u ; i<=v; ++i){
            if (i %SQ == 0 && i+SQ-1 <= v ){
                bucket[i/SQ] = colourBit(c);
                lazy[i/SQ] = c; i+=SQ-1;continue;
            }
            int last = min(v , i/SQ * SQ +SQ-1);
            re_build(i , last);i = last;
        }
    }


}


class component{
public: ll SQ;
    vector<int>par , value , root;
    void init(int v){
        SQ = v;
        par = value = vector<int>(SQ+5);root = vector<int>(105 , -1);
        iota(all(par) , 0);
    }
    int findp(int n){
        if (par[n] == n) return n;
        return par[n] = findp(par[n]);
    }
    void merge(int a , int b){
        par[findp(a)] = findp(b);
    }
    // edge between index and value
};
void main_(int tc){
    ll n , q , l , r , y , x; cin >>n;
    vector<int>a (n); for (auto &i : a) cin >>i;
    ll SQ = 450; ll s = (n+SQ-1)/SQ;
    vector<component>bucket(++s);
    auto build=[&](ll b){
        auto & cur = bucket[b];
        cur.init(SQ);
        for (int i = b *SQ; i < min(n , (b+1)*SQ); ++i){
            int indexInBucket = i %SQ;
            if (cur.root[a[i]] == -1)
                cur.root[a[i]] = indexInBucket;
            cur.par[indexInBucket] = cur.root[a[i]];
            cur.value[indexInBucket] = a[i];
        }
    };
    for (int i = 0; i < n; i+=SQ)
        build(i/SQ);

    auto solve =[&](){
        for (ll i = l; i <= r; ++i){
            auto &cur = bucket[i/SQ];
            if (i %SQ == 0 && i +SQ-1 <= r){
                if (cur.root[x] == -1){}
                else if (cur.root[y] == -1){
                    int root =cur.findp(cur.root[x]);
                    cur.root[y] = root;
                    cur.value[root] = y;
                    cur.root[x] = -1;
                }
                else{
                    cur.merge(cur.root[x] , cur.root[y]);
                    cur.root[x] = -1;
                }
                i+=SQ-1;continue;
            }
            int start = i/SQ * SQ;
            int end = min(n-1 , start+SQ-1);
            for (int j = start; j <= end; ++j){
                int indexInBucket = j %SQ;
                int root = cur.findp(indexInBucket);
                a[j] = cur.value[root];
                if (j>= l && j <= r && a[j] == x) a[j] = y;
            }
            build(i/SQ); i = end;
        }
    };
    cin>>q;
    while (q--){
        cin >>l>>r>>x>>y; --l , --r;
        if (x == y) continue;
        solve();
    }
    for (int i = 0; i < n; ++i){
        int indexInBucket = i %SQ;
        int root = bucket[i/SQ].findp(indexInBucket);
        cout << bucket[i/SQ].value[root]<<" \n"[i+1 == n];
    }


}


vector<ll>in(N) , out(N) , dp(N) , upd(N) , new_dp(N);
vector<pair<ll,ll>>queries;ll tim;
vector<vector<ll>>ad(N) , lvl(N) ;
void pre_dfs(int node , int par , int h){
    in[node] = tim++;
    lvl[h].emplace_back(in[node]);
    for (auto &ch : ad[node]){ if (ch == par) continue;
        pre_dfs(ch , node , h+1);
    }
    out[node]= tim-1;
}
void dfs(int node , int par , int h){
    new_dp[node]+= upd[h];
    for (auto &ch : ad[node]){ if (par == ch) continue;
        dfs(ch , node , h+1);
        new_dp[node]+= new_dp[ch]; // increase the value of node by its subtree
    }
    dp[node]+= new_dp[node];
}
void main_(int tc){
    ll n , q; cin >>n>>q;
    for (int i = 1; i < n; ++i){ int u , v; cin >>u>>v;
        ad[--u].emplace_back(--v);
        ad[v].emplace_back(u);
    }
    pre_dfs(0 , 0 , 0);
    auto relax =[&](){
        dfs(0 , 0 , 0);
        upd = new_dp= vector<ll>(N);
        queries.clear();
    };
    ll op , v , l;
    // complexity // n *sq(q) + q * log(n) * sq(q)
    while (q--){
        cin >>op>>v;
        if (op == 1){
            cin >>l;
            upd[v]+=l;
            queries.emplace_back(v , l);
            if ((int)queries.size() == 150)
                relax();
            continue;
        }
        ll ans = dp[--v];
        for (auto&p : queries){
            int H = p.first;
            ll R = upper_bound(all(lvl[H]) , out[v])-lvl[H].begin();
            ll L = lower_bound(all(lvl[H]) , in[v])-lvl[H].begin();
            ans+= (R-L) * p.second;
        }
        cout << ans<<nd;
    }

}
int dx [] {0 , 0 , 1 ,-1};
int dy [] {1 ,-1 , 0 , 0};

template<typename T>
struct fenwick
{
    int n;
    vector<T>a;
    void init(int _n){ n = _n+5; a = vector<T>(n+5); }
    void upd(int x , T val){
        for (int i = x; i <= n; i += (i &-i))
            a[i]+=val;
    }
    T query (int i){
        T ans {};
        while (i) ans +=a[i] ,  i -= i &-i;
        return ans;
    }
    T query(int l , int r){
        return query(r)- query(l-1);
    }
};
int diameter = 0;
function < int (int  , int )> dfs=[&](int node , int par)->int{
    int mx1 , mx2; mx1 = mx2 = 0;
    for (auto &ch : ad[node]){ if (par == ch) continue;
        int h = dfs(ch , node);
        if (mx1 < h)
            mx2 = mx1 , mx1 = h;
        else if (mx2 < h) mx2 = h;
    }
    diameter = max(diameter , mx1+mx2);
    return 1+mx1;
};
vector<vector<ll>>ad(N);
vector<ll>tin(N) , tout(N)  , freq(N), ans(N) , col(N), id(N);
ll SQ , l , timer ;ll r = -1;
class query{
public:
    ll l , r , i , k;
    query(int _l , int _r , int _i , int _k){
        l = _l ; r = _r; i = _i;k = _k;
    }
    bool operator < (query & inp) const{
        if (l/ SQ != inp.l/SQ)
            return l < inp.l;
        return r < inp.r;
    }
};
ll fans;
fenwick<ll> fen;
vector<query>queries;
vector<ll>f_freq(N);
void pre_dfs(int node , int par){
    id[timer] = node;
    tin[node] = timer++;
    for (auto &ch : ad[node]){ if (ch== par) continue;
        pre_dfs(ch , node);
    }
    tout[node] = timer-1;
}

void update (int i  , int v){
    i = id[i];
    if (freq[col[i]]) fen.upd(freq[col[i]] , -1);
    freq[col[i]]+= v;
    if (freq[col[i]]) fen.upd(freq[col[i]] , 1);
}
ll mx  ,n , m;
void solve (int i){
    while (r < queries[i].r) update(++r , 1); // add
    while (l > queries[i].l) update(--l , 1);// add
    while (r > queries[i].r) update(r-- , -1); // sub
    while (l < queries[i].l) update(l++ , -1);// sub
    ans[queries[i].i] = fen.query(queries[i].k , n);
}
cin >>n>>m;
for (int i = 0; i < n; ++i) cin >>col[i];
mx = *max_element(all(col));
int u , v; SQ = 450;
for (int i = 1; i < n; ++i){
cin >>u>>v;
ad[--u].emplace_back(--v);
ad[v].emplace_back(u);
}
pre_dfs(0 , 0);
fen.init(N);
for (int i = 0; i < m; ++i){
cin >> u>> v; --u;
queries.emplace_back(tin[u] , tout[u] , i , v);
}
sort(all(queries));
for (int i = 0; i < m; ++i)
solve(i);

for (int i = 0; i < m; ++i)
cout << ans[i]<<nd;

vector<ll>depth , tin , tout; set<ll>st;// inf;
vector<vector<ll>>ad , ancestor; ll timer = 0;


void kill(int n){
    depth  = vector<ll> (n+10 , inf);
    tin = tout = vector<ll>(n+10); timer = 0;
    ad = vector<vector<ll>>(n+10);
    ancestor = vector<vector<ll>>(n+10 , vector<ll>(1+LOG));
}

void pre_dfs(int node , int par){
    ancestor[node][0] = par;
    depth[node] = depth[par]+1;
    tin[node] = timer++;
    for (int i = 1; i < LOG; ++i)
        ancestor[node][i] = ancestor[ancestor[node][i-1]][i-1];
    for (auto &ch : ad[node]){ if (ch == par) continue;
        pre_dfs(ch , node);
    }
    tout[node] = timer-1;
}
ll kth_ancestor(int node , ll k){
    for (int i = LOG-1; ~i ; --i)
        if (k & (1 << i))
            node = ancestor[node][i];
    return node;
}
ll lca(int u , int v){
    if (depth[v] > depth[u])
        swap(u , v);
    u = kth_ancestor(u , depth[u]-depth[v]);
    if (u == v) return u;
    for (int i = LOG-1; ~i; --i){
        if (ancestor[u][i] != ancestor[v][i])
            u = ancestor[u][i] , v = ancestor[v][i];
    }
    assert(ancestor[u][0] == ancestor[v][0]);
    return ancestor[u][0];
}
ll dist(ll u , ll v){
    return depth[u]+ depth[v] -2* depth[lca(u , v)];
}
ll is_anc(int u , int v){
    return tin[u] <= tin[v] && tout[u] >= tout[v];
}
ll inside(ll s , ll e , ll m){
    return ((is_anc(m , s)|| is_anc(m , e)) && is_anc(lca(s , e) , m));
}
ll n , q , u , v , k;

void main_(int tc){
    cin >>n;
    kill(n);
    for (int i = 1; i < n; ++i){ cin >>u>>v;
        ad[u].emplace_back(v);
        ad[v].emplace_back(u);
    }
    pre_dfs(1 , 1);cin >> q;
    while (q--){
        cin >> k; vector<pair<ll,ll>> nodes;
        for (int i = 1; i <= k; ++i){
            cin >>u;
            nodes.emplace_back(-depth[u] , u);
        }
        if (k < 3){ py;continue;}

        sort(all(nodes));
        ll lc = nodes.front().second;
        for (auto &i : nodes)lc = lca(lc , i.second);
        ll nodeL = nodes.front().second;
        ll nodeR = -1;
        for (auto &i : nodes){
            if (lca(nodeL , i.second) != i.second){
                nodeR = i.second;break;
            }
        }
        if (nodeR == -1){py; continue;}
        if (lca(nodeL  , nodeR) != lc){ pn;continue; }
        ll d = dist(nodeR , nodeL);
        bool fail = 0;
        for (auto &i : nodes){
            if (i.second == nodeL || i.second == nodeR) continue;
            if (!inside(nodeR , nodeL , i.second)) fail = 1;
        }
        if (fail){pn;continue;}
        py;

    }



}
void kill(){
    for (ll i = 2; i <= 1e5; ++i){
        if (!lp[i]) pr.emplace_back(i) ,lp[i] = i;
        for (ll &p : pr){ if (p *i > 1e5 || p > lp[i] ) break; assert(!lp[p * i]);
            lp[i * p] = p;
        }
    }
}
map<ll,ll > mp;
void fuck(ll n){
    for (auto &p : primes){ if (p *p > n) break;
        if (n % p == 0){
            mp[p]++;
            while (n %p == 0) n/=p;
        }
    }
    if (n > 1) mp[n]++;
}
int64_t Order(ll l , ll r , ll LOG, ll ZERO) { // 2na sare2 el function de 3l2 fekra w m4 fahemha
    //
    if (pow == 0) {
        return 0;
    }
    ll hpow = 1 << (pow - 1);
    ll seg = (x < hpow) ? ((y < hpow) ? 0 : 3) : ( (y < hpow) ? 1 : 2);
    seg = (seg + rotate) & 3;
    const ll rotateDelta[4] = {3, 0, 0, 1};
    ll nx = x & (x ^ hpow), ny = y & (y ^ hpow);
    ll nrot = (rotate + rotateDelta[seg]) & 3;
    int64_t subSquareSize = int64_t(1) << (2 * pow - 2);
    int64_t ans = seg * subSquareSize;
    int64_t add = Order(nx, ny, pow - 1, nrot);
    ans += (seg == 1 || seg == 2) ? add : (subSquareSize - add - 1);
    return ans;
}

bool valid(vector<int> &org , vector<vector<int > > &sq){
    map<int , vector< int > > mp;
    map< int , int > inDeg;
    for (auto &i : sq) {
        for (int j = 1; j < (int) i.size(); ++j) {
            mp[i[j - 1]].emplace_back(i[j]);
            inDeg[i[j]]++;
        }
        if ((int)i.size() == 1 && !mp.count(i.front()))
            mp[i.front()] = vector<int>();
    }

    deque < int > q;
    for (auto &i :inDeg)
        if (!i.second)
            q.emplace_back(i.first);
    vector<int > ans;
    while (!q.empty()) {
        ans.emplace_back(q.front());
        if ((int)q.size() > 1) return 0;
        int node = q.front();q.pop_front();
        for (auto &ch: mp[node])
            if (!--inDeg[ch])
                q.emplace_back(ch);
    }
    if ((int)ans.size() != (int)mp.size()) return 0;
    return ans == org;
}

bool isPrintable(vector<vector<int>>& target) {
    const int _N = 60;
    vector<int> mxr , mxc , mnr , mnc;
    int n= (int)target.size();
    int m = (int)target[0].size();
    mxr = mxc = vector<int > (_N+5 , -1);
    mnr = mnc = vector<int> (_N+5 , n*m+5);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            int c = target[i][j];
            mnc[c] = min(mnc[c], j);
            mnr[c] = min(mnr[c], i);
            mxc[c] = max(mxc[c], j);
            mxr[c] = max(mxr[c], i);
        }
    }
    vector<int> have , order;
    for (int i = 1; i<= _N; ++i)
        if (mnc[i] != -1)
            have.emplace_back(i);

    vector<vector<int > > ad(_N+5);
    vector<int > inDeg(_N+5);

    auto calc =[&](int c){
        for (int i = mnr[c]; i <= mxr[c]; ++i)
            for (int j = mnc[c]; j <= mxc[c]; ++j)
                if (c != target[i][j])
                    ad[c].emplace_back(target[i][j]) , inDeg[target[i][j]]++;

    };
    deque < int > ready;
    for (auto &i : have) calc(i);
    for (auto &i : have)
        if(!inDeg[i])
            ready.emplace_back(i);


    while (!ready.empty()){
        int sz = (int) ready.size();
        while (sz--){
            int node = ready.front(); ready.pop_front();
            for (auto &ch : ad[node])
                if (!--inDeg[ch])
                    ready.emplace_back(ch);
            order.emplace_back(node);
        }
    }
    return (int) have.size() == (int) order.size();
}
template < typename T >
using min_heap = priority_queue< T  , vector<T >  , greater<T> > ;

void upd(int x){
    ++freq[x];
    if (freq[x] == 1){
        ++consider[x];
        ++block[x / SQ];
        ++tot;
    }
    else if (freq[x] == 2){
        --consider[x];
        --block[x / SQ];
        --tot;
    }
}
ll B = (n+ SQ-1)/ SQ +1;
vector < vector <int > >jump (B , vector <int > (B , inf));
for (int l = 0 ; l < B; ++l){
int ans = inf;
for (int r = l; r < B; ++r){
int s = r * SQ; int e = min(s + SQ , n);
for (int i = s ; i < e ; ++i){
if (prv[i] != -1 && prv[i] >= l * SQ)
ans = min(ans , i - prv[i]);
}
jump[l][r] = ans;
}
}

ll l , r;
while (q--){
cin >> l >> r; l-= 1 , r-=1;
ll lB = (l+SQ-1)/SQ;
ll rB = r/SQ;
int ans = inf;
if (lB < rB) ans = jump[lB][rB-1];
ll L = min(lB * SQ , n);
ll R = rB * SQ;
for (int i = l; i < L; ++i) if (nxt[i] != -1 && nxt[i] <= r) ans = min(ans , nxt[i]-i);
for (int i = r; i >= R; --i) if (prv[i] != -1 && prv[i] >= l) ans = min(ans , i -prv[i]);
cout << (ans > n ? -1: ans) <<nd;
}

void del(int x){
    --freq[x];
    if (freq[x] == 1){
        ++consider[x];
        ++block[x / SQ];
        ++tot;
    }
    else if (freq[x] == 0){
        --consider[x];
        --block[x / SQ];
        --tot;
    }
}

int calc(){
    if (tot == 0)
        return 0;

    for(int i = 0; i < SQ; ++i){
        if (block[i] > 0){
            for (int j = i * SQ;; ++j){
                if (consider[j]){
                    return j;
                }
            }
        }
    }

    assert(false);
}
int tx [] {0 , 0 , 1 ,-1};
int ty [] {1 ,-1 , 0 , 0};
int dx [] {-1 , -1 , 1 , 1};
int dy [] {-1 , 1 , -1 , 1};
ll n , m; cin >> n >> m;
vector < string  > a(n);
for (auto &i : a) cin >> i;
vector < vector < bool > > bad (n , vector < bool > (m));
auto  v =[&] (pair < int , int > p)-> bool{
    return p.first >=0 && p.second >=0 && p.first < n && p.second < m;
};
auto pnt =[&] (pair  < int , int > p){
    cout << p.first <<" "<< p.second <<"    iiii "<<nd;
};
for (int i = 0; i < n; ++i){
for (int j = 0; j <m; ++j){
if (a[i][j] != '#') continue;
for (int k = 0; k < 4; ++k){
int nr = i+ tx[k];
int nc = j +ty[k];
if (!v({nr , nc})) continue;
bad[nr][nc] = 1;
}
}
}

vector < vector <int > > dist (n , vector <int > (m , inf)); // what is minimum number of cacti needed to reach this cell
// we will deal with this problem as a graph with cost one added to an edge if we wanna plant a cacti in this cell
deque < pair < int , int > > q;
for (int i = 0;i <n; ++i){
if (!bad[i][0]){
bool c = (a[i][0] == '#' ? 0 : 1);
c ? q.emplace_back(i , 0) : q.emplace_front(i , 0);
dist[i][0] = c;
}
}



vector < vector < pair < int , int > > > par(n , vector <pair < int , int > > (m , {-1 , -1}));
auto zero_one_Bfs =[&](){
    while (!q.empty()){
        int sz_level = (int)q.size();
        while (sz_level--){
            auto node = q.front();; q.pop_front();
            for (int i = 0; i < 4; ++i){
                int nr = node.first + dx[i];
                int nc = node.second + dy[i];
                if (!v({nr , nc}) || bad[nr][nc]) continue;
                bool push =(a[nr][nc] == '#' ? 0 : 1);
                if (dist[nr][nc] > push + dist[node.first][node.second]) {
                    dist[nr][nc] = push + dist[node.first][node.second];
                    !push ? q.emplace_front(nr, nc) : q.emplace_back(nr, nc);
                    par[nr][nc] = node;
                }
            }
        }
    }
};
zero_one_Bfs();
int mn = inf;pair < int , int > s;
for (int i = 0; i <n; ++i){
if (dist[i][m-1] <  mn) mn = dist[i][m-1] , s = {i , m-1};
}
if (mn == inf){
pn;return;
}
function < void (pair < int , int >) > backtrack =[&] (pair < int , int >node ){
    if (node.first == -1) return ;
    backtrack(par[node.first][node.second]);
    a[node.first][node.second] = '#';
};
backtrack(s);
py;
for (int i = 0; i < n; ++i , cout <<nd)
for (int j = 0; j < m; ++j)
cout << a[i][j];
/*
struct node{
    pair <int , int > data;
    node *l; node * r;
    node (){ l = r = nullptr; data = {inf , 0};}
};
using myT = node*;
node buf[N];int index = 0;
myT new_node(pair <int , int > n ,myT l , myT r){
    buf[index].data = n;
    buf[index].l = l;
    buf[index].r = r;
    return & buf[index++];
}
myT alone(pair <int , int > n){
    return new_node(n , nullptr , nullptr);
}
*/

int last[N];
struct myT{
    vector <pair < int , int > > tree ; int parent ;
    void S (int n){
        parent = n;
        while (popcount(parent) != 1)++ parent;
        tree = vector < pair <int , int > > (2 * parent , {inf , inf});
    }
    void upd(int i , pair <int , int > p , int node , int node_low , int node_high ){
        if (node_high- node_low == 1) {
            tree[node] = p;return;
        }
        int mid = node_low+ node_high >> 1;
        i <  mid  ?  upd(i , p  , 2*node+1 , node_low , mid ) : upd(i , p, 2* node+2 , mid  , node_high );
        tree[node] = min(tree[2* node+1] , tree[2* node+2]);
    }
    void upd(int i , pair < int , int > v){
        return upd(i , v , 0 , 0 , parent);
    }
    pair <int , int > query (int node , int node_low , int node_high  , int query_low , int query_high){
        if (node_low >= query_high || query_low >= node_high)
            return {inf , inf};
        if (node_low >= query_low && query_high >= node_high)
            return tree[node];
        int mid = node_low + node_high >> 1;
        auto op1= query(2* node+1 , node_low , mid , query_low , query_high);
        auto op2 = query(2* node+2 , mid , node_high , query_low , query_high);
        return min(op1 , op2);
    }
    pair <int , int >  query (int l , int r){
        return query(0 , 0 , parent , l , r+1);
    }

};
void main_(int tc){
    ll n , q; cin >> n;
    vector < int > a(n);
    for (auto &i : a) cin >>i  , last[i] = -1;
    cin >> q;
    vector < vector <pair <int , int > >> qu(n);
    vector <int > ans(q);

    for (int i = 0; i < q; ++i){ int l , r;
        cin >> l >> r ;
        qu[--r].emplace_back(--l , i);
    }
    myT tree; tree.S(n);
    auto pnt =[&] (pair < int , int > p){
        cout << p.first <<" "<<p.second <<nd;
    };
    for (int i = 0; i < n; ++i){
        if (~last[a[i]]) tree.upd(last[a[i]] , {inf , inf});
        tree.upd(i , {last[a[i]] , a[i]});
        last[a[i]] = i;
        for (auto & p : qu[i]){
            int l = p.first , index = p.second;
            auto ret = tree.query(l , i);
            // cout << i <<" "<< ret.first <<" "<< ret.second <<nd;
            if (ret.first < l)
                ans[index] = ret.second;
        }
        //cout << i <<" uuuu "<<nd;
        //for (int k = 0; k <= i; ++k) {
        // auto ret = tree.query(k, k);
        // pnt(ret);
        // }

    }
    for (auto &i : ans) cout << i <<nd;



}
int last[N];
struct myT{
    vector <pair < int , int > > tree ; int parent ;
    void S (int n){
        parent = n;
        while (popcount(parent) != 1)++ parent;
        tree = vector < pair <int , int > > (2 * parent , {inf , inf});
    }
    void upd(int i , pair <int , int > p , int node , int node_low , int node_high ){
        if (node_high- node_low == 1) {
            tree[node] = p;return;
        }
        int mid = node_low+ node_high >> 1;
        i <  mid  ?  upd(i , p  , 2*node+1 , node_low , mid ) : upd(i , p, 2* node+2 , mid  , node_high );
        tree[node] = min(tree[2* node+1] , tree[2* node+2]);
    }
    void upd(int i , pair < int , int > v){
        return upd(i , v , 0 , 0 , parent);
    }
    pair <int , int > query (int node , int node_low , int node_high  , int query_low , int query_high){
        if (node_low >= query_high || query_low >= node_high)
            return {inf , inf};
        if (node_low >= query_low && query_high >= node_high)
            return tree[node];
        int mid = node_low + node_high >> 1;
        auto op1= query(2* node+1 , node_low , mid , query_low , query_high);
        auto op2 = query(2* node+2 , mid , node_high , query_low , query_high);
        return min(op1 , op2);
    }
    pair <int , int >  query (int l , int r){
        return query(0 , 0 , parent , l , r+1);
    }

};
void main_(int tc){
    ll n , q; cin >> n;
    vector < int > a(n);
    for (auto &i : a) cin >>i  , last[i] = -1;
    cin >> q;
    vector < vector <pair <int , int > >> qu(n);
    vector <int > ans(q);

    for (int i = 0; i < q; ++i){ int l , r;
        cin >> l >> r ;
        qu[--r].emplace_back(--l , i);
    }
    myT tree; tree.S(n);
    auto pnt =[&] (pair < int , int > p){
        cout << p.first <<" "<<p.second <<nd;
    };
    for (int i = 0; i < n; ++i){
        if (~last[a[i]]) tree.upd(last[a[i]] , {inf , inf});
        tree.upd(i , {last[a[i]] , a[i]});
        last[a[i]] = i;
        for (auto & p : qu[i]){
            int l = p.first , index = p.second;
            auto ret = tree.query(l , i);
            // cout << i <<" "<< ret.first <<" "<< ret.second <<nd;
            if (ret.first < l)
                ans[index] = ret.second;
        }
        //cout << i <<" uuuu "<<nd;
        //for (int k = 0; k <= i; ++k) {
        // auto ret = tree.query(k, k);
        // pnt(ret);
        // }

    }
    for (auto &i : ans) cout << i <<nd;



}

ll n , k;
vector < pair < ll , pair <ll,ll > > > a , s; // L R V
struct monotonic{
    deque <pair <ll ,ll > > q;
    ll cnt  , cost;
    void init(){
        q = deque <pair <ll,ll > > ();cnt = cost = 0;
    }
    void insert(ll x , ll y){ // len cost
        cnt+= x;
        cost+= x * y;
        q.emplace_back(x , y);
        ll lastCost = -1;
        while (cnt  > k){
            cost-= q.front().first * q.front().second;
            cnt-= q.front().first;
            lastCost = q.front().second;
            q.pop_front();
        }
        if (lastCost != -1 && cnt < k){
            q.emplace_front(k-cnt , lastCost);
            cost+= (k-cnt) * lastCost;
            cnt = k;
        }
    }
    ll calc (){ return cost; }
};

ll solve(){
    monotonic q;
    q.init(); ll ans = 0;
    for (auto &i : s){
        ll L = i.first; ll R = i.second.first ; ll v = i.second.second;
        q.insert(R-L+1 , v);
        ans = max(ans , q.calc());
    }
    q.init();
    reverse(all(s));
    for (auto &i : s){
        ll L = i.first; ll R = i.second.first ; ll v = i.second.second;
        q.insert(R-L+1 , v);
        ans = max(ans , q.calc());
    }
    return ans;
}
vector<Data> a;
ll n , k; cin >> n >> k;
for (int i = 1; i <= n; ++i){
int l , r , v; cin >> l >> r >> v;
a.emplace_back(l , r , v);
}
sort(all(a));
vector <ll> pre(n);
for (int i = 0; i < n; ++i){
pre[i] = (a[i].r- a[i].l+1) * a[i].v;
pre[i]+= (i ? pre[i-1] : 0);
}

auto getR =[&](ll target , bool ok)->ll{
    ll ret = (ok ? n-1 : 0);
    ll s = 0 , e = n-1;
    while (s<=e){
        ll m = s + e >> 1;
        if(target >= a[m].l){
            ret = m; s = m+1;
        }
        else e = m-1;
    }
    return ret;
};

ll ans = 0;
for (int i = 0;i < n; ++i){
ll s  , e;
s = a[i].l; e = s + k-1;
ll last = getR(e ,1);
ll consider = pre[last]- (i ? pre[i-1] : 0); // end at last
consider-= max(0ll , (a[last].r - e)) *a[last].v;
ans = max(ans , consider);

// end at i
e = a[i].r; s = e - k+1;
ll f = getR(s ,0);
consider = pre[i] - (f ? pre[f-1] : 0);
consider-= max(0ll , (s - a[f].l)) *a[f].v;
ans = max(ans , consider);
}
cout << ans <<nd;
ll n , k;
struct Data{
    ll l , r , v;
    Data(ll a , ll b ,ll c){
        l = a , r = b , v = c;
    }
    bool operator < (const Data &rhs) const{
        return make_pair(l , r) < make_pair(rhs.l , rhs.r);
    }
};
struct monotonic{
    deque <pair <ll,ll > > q;
    ll cost , cnt;
    void init(){
        cost = cnt = 0;q = deque <pair <ll,ll > > ();
    }
    void insert(ll x  ,ll y){
        cnt+=x;
        cost+= x * y;
        ll lastCost = -1;
        q.emplace_back(x , y);

        while (cnt > k){
            lastCost = q.front().second;
            cnt-= q.front().first;
            cost-= q.front().first * q.front().second;
            q.pop_front();
        }
        if (cnt <k && lastCost != -1){
            q.emplace_front(k-cnt , lastCost);
            cost+= lastCost * (k-cnt);
            cnt = k;
        }
    }
    ll calc() {return cost;}
};

struct Badass{
    stack<pair<ll,ll > > a , b; // gcd , ele
    void push(ll data){
        a.empty() ? a.emplace(data , data) : a.emplace(gcd(a.top().first , data) , data);
    }
    void del(){
        if (b.empty()){
            while (!a.empty()){
                b.empty() ? b.emplace(a.top().second , a.top().second) : b.emplace(gcd(a.top().second , b.top().first) , a.top().second);
                a.pop();
            }
        }
        b.pop();
    }
    ll calc(){
        ll ch1 = a.empty() ? 0 : a.top().first;
        ll ch2 = b.empty() ? 0 : b.top().first;
        return gcd(ch1 , ch2);
    }
    ll S (){
        return (int)a.size() +(int)b.size();
    }
};


struct node{
    pair <int , int > data;
    node *l , * r;
};

node buf[N];
const int M = 5e5+100;
int sf[M];
int index = 0;
node * extend(pair <int , int > v , node *l , node * r){
    buf[index].l = l;
    buf[index].r = r;
    buf[index].data = v;
    assert(index < N);
    return &buf[index++];
}
node * leaf(pair <int , int > v){
    return extend(v , nullptr , nullptr);
}
node * merge (node *l  , node *r){
    return extend(min(l->data , r->data) , l , r);
}
node * build(const vector <pair <int , int > > & a , int node_low , int node_high){
    if (node_high- node_low == 1)
        return leaf(a[node_low]);
    int mid = node_low + node_high >> 1;
    node * left = build(a , node_low , mid);
    node * right = build(a , mid , node_high);
    return merge(left , right);
}
node * upd(node * tree ,int i ,  int node_low , int node_high , pair <int , int > p){
if (node_high - node_low == 1)
return leaf(p);
int mid = node_low + node_high >> 1;
node *left = tree->l;
node * right = tree->r;
if (i < mid)
left = upd(left , i  , node_low , mid , p);
else
right = upd(right, i ,mid  , node_high , p);
return merge(left , right);
}
pair <int , int > neu = {inf , inf};
pair <int , int > get(node * tree , int query_low , int query_high , int node_low , int node_high){
if (node_low >= query_high || query_low >= node_high)
return neu;
if ( node_low >= query_low && query_high >= node_high)
return tree->data;

int mid = node_low + node_high >> 1;
auto left = get(tree->l , query_low , query_high , node_low , mid);
auto right = get(tree->r , query_low , query_high , mid , node_high);
return min(left , right);
}

void print(node * tree , int node_low , int node_high){
   if (node_high- node_low == 1){
cout << node_low <<" "<< tree->data.first <<" "<< tree->data.second << nd;
return;
}
int mid = node_low + node_high >> 1;
print(tree->l , node_low , mid);
print(tree->r , mid , node_high);
}

void main_(int tc){
    ll n; cin >> n;
    vector <ll > a(n);
    for (auto &i : a) cin >> i , sf[i] = -1;
    vector <node* > versions;
    versions.push_back(build(vector <pair <int , int > > (n , make_pair(inf , inf)) , 0 , n));

    for (int i = 0; i < n; ++i){
        node * tree = versions.back();
        if (sf[a[i]] != -1) tree = upd(tree , sf[a[i]] , 0 , n , {inf , inf} );
        tree = upd(tree , i , 0 , n , {sf[a[i]] , a[i]});
        sf[a[i]] = i;
        versions.push_back(tree);
    }

    int q; cin >> q;
    while (q--){
        int l , r , out; cin >> l >> r;
        auto ans = get (versions[r] , --l , r , 0 , n);
        out = 0;
        if (l > ans.first) out = ans.second;
        cout << out << nd;
    }

}
}
struct node{
    pair <int , int > data;
    node *l , * r;
};


node buf[N];
const int M = 5e5+100;
int sf[M];
int index = 0;
node * extend(pair <int , int > v , node *l , node * r){ // r +1
    buf[index].l = l;
    buf[index].r = r;
    buf[index].data = v;
    assert(index < N);
    return &buf[index++];
}
node * leaf(pair <int , int > v){
    return extend(v , nullptr , nullptr);
}
node * merge (node *l  , node *r){
    return extend(min(l->data , r->data) , l , r);
}
node * build(const vector <pair <int , int > > & a , int node_low , int node_high){
    if (node_high- node_low == 1)
        return leaf(a[node_low]);
    int mid = node_low + node_high >> 1;
    node * left = build(a , node_low , mid);
    node * right = build(a , mid , node_high);
    return merge(left , right);
}
node * upd(node * tree ,int i ,  int node_low , int node_high , pair <int , int > p){
if (node_high - node_low == 1)
return leaf(p);
int mid = node_low + node_high >> 1;
node *left = tree->l;
node * right = tree->r;
if (i < mid)
left = upd(left , i  , node_low , mid , p);
else
right = upd(right, i ,mid  , node_high , p);
return merge(left , right);
}
pair <int , int > neu = {inf , inf};
pair <int , int > get(node * tree , int query_low , int query_high , int node_low , int node_high){
if (node_low >= query_high || query_low >= node_high)
return neu;
if ( node_low >= query_low && query_high >= node_high)
return tree->data;

int mid = node_low + node_high >> 1;
auto left = get(tree->l , query_low , query_high , node_low , mid);
auto right = get(tree->r , query_low , query_high , mid , node_high);
return min(left , right);
}

void print(node * tree , int node_low , int node_high){
if (node_high- node_low == 1){
cout << node_low <<" "<< tree->data.first <<" "<< tree->data.second << nd;
return;
}
int mid = node_low + node_high >> 1;
print(tree->l , node_low , mid);
print(tree->r , mid , node_high);
}

void main_(int tc){
    ll n; cin >> n;
    vector <ll > a(n);
    for (auto &i : a) cin >> i , sf[i] = -1;
    vector <node* > versions;
    versions.push_back(build(vector <pair <int , int > > (n , make_pair(inf , inf)) , 0 , n));

    for (int i = 0; i < n; ++i){
        node * tree = versions.back();
        if (sf[a[i]] != -1) tree = upd(tree , sf[a[i]] , 0 , n , {inf , inf} );
        tree = upd(tree , i , 0 , n , {sf[a[i]] , a[i]});
        sf[a[i]] = i;
        versions.push_back(tree);
    }

    int q; cin >> q;
    while (q--){
        int l , r , out; cin >> l >> r;
        auto ans = get (versions[r] , --l , r , 0 , n);
        out = 0;
        if (l > ans.first) out = ans.second;
        cout << out << nd;
    }

}
int main(){

    ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);
    //the_best_is_still_yet_to_come();
    //freopen("red2.in ","r",stdin);//  freopen("output.txt","w",stdout);
    int tt = 1 , tc = 0;
    // cin>>tt;
    while(tt--) main_(++tc);
#ifndef ONLINE_JUDGE
    cout << "Running Time: " << 1.0 * clock() / CLOCKS_PER_SEC << " s .\n";
#endif
    return 0;
}
 ll n  , q , t , p , cc; cin >> n;
    vector < ll > a(n) , b(n);
    vector <ll > bucket (n+5) ,lazy(n+5);
    for (int i = 0; i <n; ++i){
        cin >> a[i];b[i] = a[i];
        bucket[i/SQ]+= a[i];
    }
    auto drop =[&](ll B){
        bucket[B] = 0;
        ll r = min(n , (B+1) * SQ);
        for (int i = B * SQ; i <r ; ++i){
            ll v = min(b[i] , lazy[i/SQ]);
            b[i]-=v; lazy[i/SQ]-=v;
            bucket[i/SQ]+=b[i];
        }
        lazy[B] = 0;
    };
    auto upd =[&](ll l ,ll r , ll k){
        drop(l/SQ); drop(r/SQ);
        for (int i = l; i <= r; ){
            if (i %SQ == 0 && i + SQ -1 <= r){
                ll v = min(k , bucket[i/SQ]); k-= v;
                bucket[i/SQ]-=v;
                lazy[i/SQ]+= v;
                i+=SQ;
            }
            else{
                ll v = min(k , b[i]);bucket[i/SQ]-=v;
                b[i++]-=v;k-=v;
            }
        }
    };
    cin >> q;
    while (q--){
        cin >> t >> p;--p;
        if (t == 1){
            cin >> cc;
            upd(p , n-1, cc);
            continue;
        }
        drop(p/SQ);
        cout << a[p]-b[p] << nd;
    }
}
function<bool(int , int ) > go=[&] (int l, int r)-> bool{
    ans.clear();
    for (int i = 0; i < n; ++i){
        ans.emplace_back(r);
        int nxt = -1;
        if (a[l][0] == r)
            nxt = a[l][1];
        else if (a[l][1] == r)
            nxt =a[l][0];
        else return 0;
        l = r;
        r = nxt;
    }
    return 1;
};



//////////////////////////////
vector < vector < vector < vector < int > > > > table;
ll n , m;
vector <vector <int> > mx;
vector<int > Log;
ll merge (ll u ,ll v){
    return max(u , v);
}
void build(){// zero based
    //use fucken arrays not vectors
    Log = vector<int > (max(n , m)+5);
    table = vector < vector < vector < vector <int> > > > (n+5 , vector<vector<vector<int> > > (LOG , vector<vector<int> >(m+5 , vector<int>(LOG))));
    // rows - power of rows && cols - power of cols
    for (int i = 2; i <= max(n , m); ++i) Log[i] = Log[i >> 1] +1;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            table[i][0][j][0] = mx[i][j];

    for (int i = 0; i < n; ++i)
        for (int l = 1; l < LOG; ++l)
            for (int j = 0; j + (1 << l)-1 < m; ++j)
                table[i][0][j][l] = merge(table[i][0][j][l-1] , table[i][0][j + (1 << (l-1))][l-1]);

    for (int k = 1; k < LOG; ++k)
        for (int i = 0; i + (1 << k)-1 < n; ++i)
            for (int l = 0; l < LOG; ++l)
                for (int j = 0; j + (1 << l)-1 < m; ++j)
                    table[i][k][j][l] = merge(table[i][k-1][j][l] , table[i+ (1 << (k-1))][k-1][j][l]);

}

ll query(ll x1 , ll y1 , ll x2 , ll y2){// zero based
    if (x1 > x2 || y1 > y2 || min({x1 , x2 , y1 , y2}) <0 || max(x1 , x2) >= n || max(y1 , y2) >= m) return 0;
    assert(x1 >=0 && x1 <n);  assert(y1 >=0 && y1 < m);
    assert(x2 >=0 && x2 < n &&x2 >= x1);assert(y2 >=0 &&y2 < m && y2 >= y1);
    ll lx = Log[x2-x1+1]; ll ly = Log[y2-y1+1];
    ll prob1 = merge(table[x1][lx][y1][ly] , table[x1][lx][1 + y2- (1 << ly)][ly]);
    ll prob2 = merge(table[1 + x2 -(1<< lx)][lx][y1][ly] , table[1 +x2 - (1 << lx)][lx][1 + y2- (1 << ly)][ly]);
    // cout <<lx<<" "<<ly <<" "<<prob1 <<" "<<prob2 <<" "<<x1<<" "<<y1 <<" "<<x2<<" "<<y2 << nd;
    return merge(prob1 , prob2);
}
vector <vector <vector <int > > > pref;
vector<string > s;
void build_prefix (char c , int t){
    for (int i = 1; i <= n; ++i){
        for (int j = 1; j <= m; ++j){
            char in = s[i-1][j-1];
            pref[t][i][j]+= (in == c);
            pref[t][i][j]+= pref[t][i-1][j];
            pref[t][i][j]+= pref[t][i][j-1];
            pref[t][i][j]-=pref[t][i-1][j-1];
        }
    }
}
pair <int , int > operator + (const pair <int , int > &  p1 , const pair <int ,int > & p2){
    return make_pair(p1.first+p2.first , p1.second+p2.second);
}
pair <int ,int >  operator -(const pair <int ,int > & p1  , const pair <int ,int > &p2){
    return make_pair(p1.first-p2.first , p1.second-p2.second);
}
ll get (ll x1 , ll y1 , ll x2 , ll y2 , int t ){
    ++x1 , ++y1 , ++x2 , ++y2;
    assert(x1 >=1 && x1 <=n);  assert(y1 >=1 && y1 <=m);
    assert(x2 >=1 && x2 <= n &&x2 >= x1);assert(y2 >=1 &&y2 <= m && y2 >= y1);
    return pref[t][x2][y2]- pref[t][x2][y1-1] - pref[t][x1-1][y2] +pref[t][x1-1][y1-1];
}
void main_(int tc){
    int q;
    cin >> n >> m >> q;
    s = vector<string  > (n);
    for (auto &i : s) cin >> i;
    pref = vector <vector <vector<int > > > (4 , vector<vector<int> > (n+5 , vector<int> (m+5)));
    build_prefix('R' , 0);build_prefix('G' , 1);build_prefix('Y' , 2);build_prefix('B' , 3);
    mx = vector <vector<int > > (n , vector<int> (m));
    for (int i = 0;i < n; ++i){
        for (int j = 0; j < m; ++j){
            for (int k = 1;  min(i , j)-k +1 >= 0 && i+k < n && j+k < m; ++k){
                if (get(i-k+1 , j-k+1 , i , j , 0) != k * k) break;
                if (get(i-k+1 , j+1 , i , j+k , 1) != k *k) break;
                if (get(i+1 , j-k+1 , i+k , j , 2) != k *k) break;
                if (get(i+1 , j+1 , i+k , j+k , 3) != k * k) break;
                mx[i][j] = k;
            }
        }
    }
    build();

    while (q--){
        int r1 , r2 , c1 , c2;
        cin >> r1 >> c1 >> r2 >> c2; --r1 , --r2 , --c1 , --c2;
        ll s = 0 , e = n; ll ans = 0;
        while (s<= e){
            ll m = s + e >> 1;
            ll nr1 = r1+m -1 , nc1 = c1 + m-1;
            ll nr2 = r2-m; ll nc2 = c2-m;
            if (query(nr1 , nc1 , nr2 , nc2) >= m) {
                ans = m; s = m+1;
            }
            else e = m-1;
        }
        cout << 4 * ans * ans <<nd;
    }



}


int table[N][LOG][N][LOG];
int Log[N];
void build (){
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            table[i][0][j][0] = pref[i][j];

    for (int i = 0; i < n ; ++i)
        for (int l = 1; l < LOG; ++l)
            for (int j = 0; j + (1 << l)-1 < m; ++j)
                table[i][0][j][l] = merge(table[i][0][j][l-1] , table[i][0][j+ (1 << (l-1))][l-1]);


    for (int k = 1; k < LOG; ++k)
        for (int i = 0; i + (1 << k)-1 < n; ++i)
            for (int l = 0; l < LOG; ++l)
                for (int j = 0; j + (1 << l)-1 < m; ++j)
                    table[i][k][j][l] = merge(table[i][k-1][j][l] , table[i+ (1 << (k-1))][k-1][j][l]);


    for (int i = 2; i <= max(n , m); ++i) Log[i] = Log[i >> 1] +1;
}
ll query (ll x1 , ll y1 ,ll x2 , ll y2){
    ll lx = Log[x2-x1+1] , ly = Log[y2-y1+1];
    ll prob1 = merge(table[x1][lx][y1][ly] , table[x1][lx][1 + y2 - (1 << ly)][ly]);
    ll prob2 = merge(table[1 + x2 - (1 << lx)][lx][y1][ly] , table[1 + x2 - (1 << lx)][lx][1 + y2 - (1 << ly)][ly]);
    return merge(prob2 , prob1);
}

bool overFlow(ll x, ll y) {
    return (abs(x) > 1e18 / abs(y));
}
template <typename T>
vector<T> calc(const vector<T>& a, int k) {
    const int n = a.size();
    vector<T> b(n - k + 1);
    deque<int> mono;
    for (int i = 0; i < n; ++i) {
        while (!mono.empty() && a[mono.back()] <= a[i]) mono.pop_back();
        mono.push_back(i);
        if (i-k >= mono.front())
            mono.pop_front();
        if (i >= k-1)
            b[i - k +1] = a[mono.front()];
    }
    return b;
}

template <typename T>
vector<vector<T>> f(const vector<vector<T>>& a, int k, int l) {
    const int n = a.size(), m = a[0].size();
    vector<vector<T>> b(m - l + 1, vector<T>(n));
    for (int i = 0; i < n; ++i) {
        const auto tmp = calc(a[i], l);
        for (int j = 0; j < m - l + 1; ++j) {
            b[j][i] = tmp[j];
        }
    }
    vector<vector<T>> c(n - k + 1, vector<T>(m - l + 1));
    for (int j = 0; j < m - l + 1; ++j) {
        const auto tmp = calc(b[j], k);
        for (int i = 0; i < n - k + 1; ++i) {
            c[i][j] = tmp[i];
        }
    }
    return c;
}



int n,m,a,b;
int arr[N][N],tree[4*N][4*N]; // one based
long long sum[N][N];

void build_y(int vx,int lx,int rx,int vy,int ly,int ry)
{
    if(ly==ry)
    {
        if(lx==rx) tree[vx][vy]=arr[lx][ly];
        else tree[vx][vy]=min(tree[2*vx][vy],tree[2*vx+1][vy]);
    }
    else
    {
        int my=(ly+ry)/2;
        build_y(vx,lx,rx,2*vy,ly,my);
        build_y(vx,lx,rx,2*vy+1,my+1,ry);
        tree[vx][vy]=min(tree[vx][2*vy],tree[vx][2*vy+1]);
    }
}

void build_x(int vx,int lx,int rx)
{
    if(lx!=rx)
    {
        int mx=(lx+rx)/2;
        build_x(2*vx,lx,mx);
        build_x(2*vx+1,mx+1,rx);
    }
    build_y(vx,lx,rx,1,1,m);
}

int query_y(int vy,int ly,int ry,int qly,int qry,int vx)
{
    if(qly>qry) return inf;
    if(ly==qly&&ry==qry) return tree[vx][vy];
    int my=(ly+ry)/2;
    return min(query_y(2*vy,ly,my,qly,min(qry,my),vx),query_y(2*vy+1,my+1,ry,max(qly,my+1),qry,vx));
}

int query_x(int vx,int lx,int rx,int qlx,int qrx,int qly,int qry)
{
    if(qlx>qrx) return inf;
    if(qlx==lx&&qrx==rx) return query_y(1,1,m,qly,qry,vx);
    int mx=(lx+rx)/2;
    return min(query_x(2*vx,lx,mx,qlx,min(qrx,mx),qly,qry),query_x(2*vx+1,mx+1,rx,max(qlx,mx+1),qrx,qly,qry));
}

void update_y(int vx,int lx,int rx,int vy,int ly,int ry,int x,int y,int val)
{
    if(ly==ry)
    {
        if(lx==rx) tree[vx][vy]=val;
        else tree[vx][vy]=min(tree[2*vx][vy],tree[2*vx+1][vy]);
    }
    else
    {
        int my=(ly+ry)/2;
        if(y<=my) update_y(vx,lx,rx,2*vy,ly,my,x,y,val);
        else update_y(vx,lx,rx,2*vy+1,my+1,ry,x,y,val);
        tree[vx][vy]=min(tree[vx][2*vy],tree[vx][2*vy+1]);
    }
}

void update_x(int vx,int lx,int rx,int x,int y,int val)
{
    if(lx!=rx)
    {
        int mx=(lx+rx)/2;
        if(x<=mx) update_x(2*vx,lx,mx,x,y,val);
        else update_x(2*vx+1,mx+1,rx,x,y,val);
    }
    update_y(vx,lx,rx,1,1,m,x,y,val);
}


struct DataLOL {// zero based
    int n, m;
    vector<vector<int>> bit;

    DataLOL(int n = 0, int m = 0) : n(n), m(m) {
        bit.resize(n + 1, vector<int>(m + 1, 0));
    }

    int get(int x, int y) {
        int sum = 0;
        for (int i = x; i; i -= i & -i)
            for (int j = y; j; j -= j & -j)
                sum += bit[i][j];

        return sum;
    }

    int get_sum(int x1, int y1, int x2, int y2) {
        // cout << "get_sum " << x1 << ' ' << y1 << ' ' << x2 << ' ' << y2 << endl;
        x2++, y2++;
        // cout << get(x2, y2) << ' ' << get(x2, y1) << ' ' << get(x1, y2) << ' ' << get(x1, y1) << endl;
        return get(x2, y2) - get(x2, y1) - get(x1, y2) + get(x1, y1);
    }

    void increase(int x, int y) { // update all the points of square zero based
        // cout << "increasing " << x << ' ' << y << endl;
        for (int i = x + 1; i <= n; i += i & -i)
            for (int j = y + 1; j <= m; j += j & -j)
                bit[i][j]++;
    }
};



ll euclid(ll a , ll b , ll & x0 , ll& y0){
    auto nxt= [&] (ll &a , ll &b , ll q)-> void{
        ll next = a - q* b;
        a = b ;
        b = next;
    };
    ll r0 = a , r1 = b; ll x1 , y1;x0 = y1 = 1; y0 = x1 = 0;
    while (r1){
        ll q = r0/ r1;
        nxt(r0 , r1 , q);
        nxt(x0 , x1 , q);
        nxt(y0 , y1 , q);
    }
    return r0;
}
ll inv(ll a  , ll M){ ll c , no;
    ll g = euclid(a , M , c , no); assert(g== 1);
    if (g != 1) return -1;
    /* 11 -- > mod //  -4 %11 = -4 but it mst be 7
    n = bq +r // -4 = 0 *11 -4
    but another solution is // -4 = -1*11 +7
    */
    return (c % M + M) % M;
}
ll Fp (ll a , ll b){
    if (!b) return 1;
    ll v = Fp(a , b/2);
    v = mul(v , v);
    if (b & 1)
        v = mul(v  , a);
    return v;
}

ll fact[N];

void init(){
    fact[0] =1;
    for (ll i = 1; i <N; ++i) fact[i] = fact[i-1] * i % mod;
}
ll npr(ll n , ll r){// fact[n]/ fact[n-r]
    if (r > n|| r < 0) return 0;
    return mul(fact[n] , inv(fact[n-r] , mod));
}
ll ncr (ll n , ll r){ // fact[n]/ fact[r] * fact[n-r]
    if (r > n|| r < 0) return 0;
    return mul(npr(n , r), inv(fact[r] , mod));
}





struct node{
    ll pref , suf , mx , len;
    node *l , * r;
};
node buf[N];
int index;

node * extend(ll pre , ll suf , ll mx ,ll len , node *l , node *r){
    buf[index].pref = pre; buf[index].suf = suf;
    buf[index].mx = mx; buf[index].len= len;
    buf[index].l = l; buf[index].r = r;
    assert(index+1 < N);
    return & buf[index++];
}
node * leaf(int data){
    return extend(data , data , data , 1 , nullptr , nullptr);
}
node * merge(node * l , node *r){
    ll pre = (l->pref == l->len ? l->len + r->pref : l->pref);
    ll suf = (r->suf == r->len ? r->suf + l->suf : r->suf);
    ll mx = max({ l->suf+r->pref , l->mx , r->mx });
    ll len = l->len +r->len;
    return extend(pre , suf , mx , len , l , r);
}

node * build (int node_low , int node_high){
    if (node_high - node_low == 1) return leaf(0);
    int mid = node_low + node_high >> 1;
    node * left= build(node_low , mid);
    node * right = build( mid , node_high);
    return merge(left , right);
}

node * upd (node * tree , int i , int data , int node_low , int node_high){
if (node_high - node_low == 1) return leaf(data);
int mid = node_low + node_high >> 1;
node* left = tree->l; node * right = tree->r;
if (i < mid) left = upd(left , i , data , node_low , mid);
else right = upd(right , i , data , mid , node_high);
return merge(left , right);
}

struct range{
    ll pre ,  suf , mx , len;
};
range merge (range & l , range  & r){
    ll pre = (l.pre == l.len ? l.len + r.pre : l.pre);
    ll suf = (r.suf == r.len ? r.len + l.suf : r.suf);
    ll mx = max({ l.suf+r.pre , l.mx , r.mx});
    ll len = l.len +r.len;
    return  {pre , suf , mx , len};
}

range query (node * tree , int node_low , int node_high  , int query_low , int query_high){
if (query_low >= node_high || node_low >= query_high) return {0 , 0 , 0 , 0};
if (node_low >= query_low && query_high >= node_high )
return {tree->pref , tree->suf , tree->mx , tree->len};
int mid = node_low + node_high >> 1;
auto L= query(tree->l , node_low , mid , query_low , query_high);
auto R = query(tree->r , mid , node_high , query_low , query_high);
return merge(L , R);
}
void hat_wrong_answer_test2(int tc){
    ll n , q ,l , r , w; cin >> n;
    vector <pair <ll ,int > > a; a.reserve(n+1);
    for (int i = 0;i < n; ++i){ a.emplace_back();
        cin >> a.back().first; a.back().second = i;
    }
    sort(a.rbegin() , a.rend());
    vector < node * > versions; versions.reserve(n+5);
    versions.push_back(build(0 , n));
    for (int i = 0; i < n; ++i){
        node * tree = versions[i];tree = upd(tree , a[i].second , 1 , 0 , n);
        versions.push_back(tree);
    }
    cin  >> q;
    while (q--){
        cin >>l >> r >> w; --l;
        int  L = 1 , R = n; ll ans = -1;
        while (L <= R){
            ll mid = L + R >> 1;
            if (query(versions[mid] , 0 , n  , l , r).mx >= w) R = (ans = mid)-1;
            else L = mid+1;
        }
        assert(--ans >= 0);
        cout << a[ans].first << nd;
    }



}

vector<int>prime;
vector<char> mu;
void mobi(){
    prime = vector<int>(N , 1); prime.shrink_to_fit();
    mu = vector<char>(N , 1); mu.shrink_to_fit();
    for (ll i = 2; i <= 1e6; ++i)
        if (prime[i]== 1)
            for (ll j = i; j <= 1e6; j+=i)
                mu[j] = (j % (i *i )== 0 ? 0 : -mu[j]) , prime[j]*=i;
}
ll euclid(ll a , ll b , ll & x0 , ll& y0){
    auto nxt= [&] (ll &a , ll &b , ll q)-> void{
        ll next = a - q* b;
        a = b ;
        b = next;
    };
    ll r0 = a , r1 = b; ll x1 , y1;x0 = y1 = 1; y0 = x1 = 0;
    while (r1){
        ll q = r0/ r1;
        nxt(r0 , r1 , q);
        nxt(x0 , x1 , q);
        nxt(y0 , y1 , q);
    }
    return r0;
}

ll inv(ll a , ll M){ ll c , no;
    ll g = euclid(a , M , c , no); assert(g == 1);
    if (g != 1) return -1;
    /* 11 -- > mod //  -4 %11 = -4 but it mst be 7
    n = bq +r // -4 = 0 *11 -4
    but another solution is // -4 = -1*11 +7
     */
    return (c % M + M) % M;
}

int Log[N];
int n;
int table [N][LOG];
for (int j = 1; j < LOG; ++j){
    for (int i = 0;i+(1 << j)-1 < n; ++i)
        table[i][j] = gcd(table[i][j-1] , table[i+ (1 << (j-1))][j-1]);
}
for (int i = 2; i <= n; ++i) Log[i] = 1 + Log[i >> 1];
auto calc =[&](int l , int r)->ll{ // log max element
    int L = Log[r-l+1];
    return gcd(table[l][L] , table[r- (1 << L)+1][L]);
};


ll mul(ll a, ll b, ll M) {
    ll ret = a * b - M * ll(1.L / M * a * b);
    return ret + M * (ret < 0) - M * (ret >= (ll)M);
}
ll Fp(ll b, ll e, ll mod) {
    ll ans = 1;
    for (; e; b = mul(b, b, mod), e /= 2)
        if (e & 1) ans = mul(ans, b, mod);
    return ans;
}

bool isPrime(ll n) {
    if (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;
    ll A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},
            s = __builtin_ctzll(n-1), d = n >> s;
    for (ll a : A) {   // ^ count trailing zeroes
        ll p = Fp(a%n, d, n), i = s;
        while (p != 1 && p != n - 1 && a % n && i--)
            p = mul(p, p, n);
        if (p != n-1 && i != s) return 0;
    }
    return 1;
}

ll pollard(ll n) {
    auto f = [n](ull x) { return mul(x, x, n) + 1; };
    ll x = 0, y = 0, t = 30, prd = 2, i = 1, q;
    while (t++ % 40 || __gcd(prd, n) == 1) {
        if (x == y) x = ++i, y = f(x);
        if ((q = mul(prd, max(x,y) - min(x,y), n))) prd = q;
        x = f(x), y = f(f(y));
    }
    return __gcd(prd, n);
}

vector<ll> factor(ll n) {
    if (n == 1) return {};
    if (isPrime(n)) return {n};
    ull x = pollard(n);
    auto l = factor(x), r = factor(n / x);
    l.insert(l.end(), all(r));
    return l;
}
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()) ;

long long rand(long long l , long long r)
{
    return uniform_int_distribution<long long>(l , r)(rng) ;
}



node * upd (node * tree , int i , ll data ,int node_low , int node_high){
if (node_high - node_low == 1)
return leaf(data ^ tree->data);
int mid = node_low + node_high >> 1;
node * left = tree->l ;
node * right = tree->r;
if (i < mid)left =  upd(left , i , data , node_low , mid);
else right = upd(right , i , data ,mid ,node_high);
return merge(left , right);
}



ll ask (node * u , node *v  , node * lc , node * father , ll node_low , ll node_high , ll query_low , ll query_high){
ll tt = u-> data ^ v->data ^ lc->data ^ father->data;
if (!tt) return -1;
if (node_low >= query_high || query_low>= node_high) return -1;
if (node_high - node_low == 1)
return node_low;
int mid = node_low + node_high >> 1;
ll ac = ask(u->l, v->l, lc->l, father->l, node_low, mid, query_low, query_high);
if (ac != -1) return ac;

return ask(u->r , v->r , lc->r , father->r , mid , node_high , query_low , query_high);
}



void print (node * tree , int node_low , int node_high) {
cout << node_low << " " << node_high << " uuu   " << tree->data << nd;
if (node_high - node_low == 1){
return;
}
int mid = node_low + node_high >> 1;
print(tree->l, node_low, mid);
print(tree->r, mid, node_high);
}




struct interval{
    ll l  , r , c;
    bool operator < (const interval & rhs) const{
        return l < rhs.l;
    }
    void pew_pew(){
        print3(l , r , c);
    }
};
struct node{
    ll data ,lazy;
    node *l  , * r;
};
node buf[N];
int index;
node * extend (node *l , node *r , ll c){
buf[index].l = l;
buf[index].r = r;
buf[index].data = c;
buf[index].lazy = 0;
return & buf[index++];
}
node * leaf(ll c){
    return extend(nullptr , nullptr , c);
}
node * merge(node *l , node *r){
    return extend(l , r , l->data +r->data);
}
ll n;
node * build(int node_low = 0, int node_high= n){
    if (node_high - node_low == 1) return leaf(0);
    int mid = node_low + node_high >> 1;
    node *lf = build(node_low , mid);
    node *rt = build(mid , node_high);
    return merge(lf , rt);
}
void drop (node * tree , ll L ,ll R){
tree->data+= (R- L) * tree->lazy;
if (L +1 != R){
tree->l->lazy += tree->lazy;
tree->r->lazy +=tree->lazy;
}
tree->lazy = 0;
}
void upd (node * tree ,ll data  , int query_low , int query_high , int node_low = 0 , int node_high = n){
drop(tree , node_low , node_high);
if (node_low >= query_high || query_low >= node_high) return;
if (node_low >= query_low && query_high >= node_high){
tree->lazy += data;drop(tree , node_low , node_high);
return;
}
int mid = node_low + node_high >> 1;
upd(tree->l , data , query_low , query_high ,node_low , mid);
upd(tree->r , data , query_low , query_high , mid , node_high);
drop(tree->l , node_low , mid);
drop(tree->r ,mid , node_high);
tree->data = tree->l->data + tree->r->data;
// print3(node_low , node_high , tree->data);
}
ll ask (node * tree , int query_low , int query_high , int node_low= 0 ,int node_high= n){
drop(tree , node_low , node_high);
if (node_low >= query_high || query_low >= node_high) return 0;
if (node_low >= query_low && query_high >= node_high) return tree->data;
int mid = node_low + node_high >> 1;
ll lf = ask(tree->l , query_low , query_high , node_low , mid);
ll rt = ask(tree->r , query_low , query_high , mid , node_high);
return lf +rt;
}

void print (node * tree , int node_low , int node_high) {
drop(tree , node_low , node_high);
cout << node_low << " " << node_high << " uuu   " << tree->data <<" "<< tree->lazy << nd;
if (node_high - node_low == 1){
return;
}
int mid = node_low + node_high >> 1;
print(tree->l, node_low, mid);
print(tree->r, mid, node_high);
}
set < interval > st;

void hat_wrong_answer_test2(int tc){
    ll  q ; cin >> n >> q;
    for (int i = 0; i < n; ++i) st.insert({i , i , i+1});
    int op ,l , r ,c;
    node * tree = build(0 , n);
    auto calc =[&](ll L ,ll R ,ll nu)-> vector <interval >{
        vector <interval > ans;
        auto itl = --st.upper_bound({L , 0 , 0});
        auto itr = st.upper_bound({R , 0 , 0});
        // [itl , itr)
        ll acL = itl->l; ll acCC = itl->c;
        ll acR = prev(itr)->r; ll acC = prev(itr)->c;
        for (auto i = itl ; i != itr ; ++i)
            ans.push_back({max(L , i->l) , min(R , i->r) , i->c});
        st.erase(itl , itr);

        if (acL < L) st.insert({acL, L-1 , acCC});
        if (acR > R) st.insert({R+1 , acR , acC});
        st.insert({L , R , nu});
        return ans;
    };
    while (q--){
        cin >> op>> l >> r;l-=1;
        if (op == 2){
            cout <<ask(tree , l , r) << nd;continue;
        }
        cin >> c;
        for (auto &k : calc(l , r-1 , c)) upd(tree ,abs(c- k.c) , k.l , k.r+1 );
    }





}



struct DSU{
    int n;
    vector <int > sz , par;
    void S(int _n){
        n = _n;
        sz = par = vector <int > (n+5 , 1);
        iota(all(par) , 0);
    }

    int findp(int node){
        if (par[node] == node) return node;
        return par[node] = findp(par[node]);
    }
    bool Union(int u , int v){
        u = findp(u);
        v = findp(v);
        if (u == v) return 0;
        if (sz[u] < sz[v]) swap(u , v);
        sz[u]+= sz[v];
        par[v] = u;
        return 1;
    }

};

/*
 * g = gcd(a , b)
 * ll nw_gcd = gcd(a ,b -g )
 * nw_gcd % g == 0
 */
vector <int > primes;
vector <int > lp(N);
void sieve(){
    for (ll i = 2; i < N; ++i){ if (!lp[i]) primes.emplace_back(i) , lp[i] = i;
        for (auto &k : primes){ if (i *k >N || k > lp[i]) break; assert(!lp[i * k]); lp[i * k] = k ; }
    }
}
vector <ll> fact(ll n){
    vector <ll> d;
    for(auto &k : primes){
        if (k * k > n) break;
        if (n % k == 0) d.emplace_back(k);
        while (n % k == 0)n/= k;
    }
    if (n > 1) d.emplace_back(n);
    return d;
}
ll gcd(ll r0 , ll r1){
    while (r1){
        ll next = r0 % r1;
        r0 = r1;
        r1 = next;
    }
    return r0;
}
void hat_wrong_answer_test2(int tc){
    ll a , b; cin >> a >> b;
    vector <ll> d = fact(a);
    ll ans = 0;
    while (b){
        ll g = gcd(a , b);
        ll k = b/g;
        for (auto &p : d){
            ll target = b - (b/ (p *g) * p *g);
            assert(target % g == 0);
            if (target == b) continue;
            k = min(k , target/g);
        }
        //  cout << k <<" "<< g <<" "<< b << endl;
        ans+= k;
        b-= k * g;
    }
    cout << ans << nd;


}


ll ask (node * u , node *v  , node * lc , node * father , ll node_low , ll node_high , ll query_low , ll query_high){
//// pp;
ll tt = u-> data ^ v->data ^ lc->data ^ father->data;
//  print3(u->data , v->data , lc->data );
//  cout << father->data <<nd;
if (!tt) return -1;
//   cout << node_low <<" "<< node_high <<" " << query_low <<" "<< query_high <<nd;
if (node_low >= query_high || query_low>= node_high) return -1;
if (node_high - node_low == 1) {
/// pp;
return node_low;
}
int mid = node_low + node_high >> 1;
if (query_low < mid) {
ll ac = ask(u->l, v->l, lc->l, father->l, node_low, mid, query_low, query_high);
if (~ac) return ac;
}
return ask(u->r , v->r , lc->r , father->r , mid , node_high , query_low , query_high);
}




ll ask (node * u , node * v , node * lc , node * father , int k, int node_low , int node_high){
ll sum = u->data+ v->data - lc->data - father->data;
if (sum < k) return -1;
if (node_high - node_low == 1) return node_low;
int  mid= node_low + node_high >> 1;
ll sumL = u->l->data + v->l-> data -lc->l->data - father->l->data;
if (sumL >= k) return ask(u->l , v->l , lc->l , father->l ,k ,  node_low , mid);
return ask(u->r , v->r , lc->r , father->r , k-sumL , mid , node_high);
}




vector<int> primed[A];

vector<pair<int, int>> g[A][2];
pair<int, int> par[A][2];
int dist[A][2], mp[A];

void solve() {
    int n;
    cin >> n;

    memset(mp, -1, sizeof(mp));
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        mp[a[i]] = i;

        for (int p : primed[a[i]]) {
            g[p][1].emplace_back(a[i], 0);
            g[a[i]][0].emplace_back(p, 1);
        }
    }



    int s, t;
    cin >> s >> t;

    --s, --t;

    if (s == t) {
        cout << "1\n" << s + 1 << '\n';
        return;
    }

    if (a[s] == 1 || a[t] == 1) {
        cout << "-1\n";
        return;
    }

    mp[a[s]] = s;
    mp[a[t]] = t;

    if (a[s] == a[t]) {
        cout << "2\n" << s + 1 << " " << t + 1 << '\n';
        return;
    }

    memset(dist, -1, sizeof(dist));

    queue<pair<int, int>> q;
    q.push({a[s], 0});
    dist[a[s]][0] = 0;

    while (!q.empty()) {
        auto [x, tp] = q.front();
        q.pop();

        for (auto [to, y] : g[x][tp]) {
            if (dist[to][y] == -1) {
                par[to][y] = {x, tp};
                dist[to][y] = dist[x][tp] + 1;

                q.emplace(to, y);
            }
        }
    }

    if (dist[a[t]][0] == -1) {
        cout << "-1\n";
        return;
    }

    vector<int> ans;
    int x = a[t], tp = 0;
    while (pair{x, tp} != pair{a[s], 0}) {
        if (tp == 0) {
            ans.push_back(mp[x]);
        }
        tie(x, tp) = par[x][tp];
    }

    ans.push_back(s);
    reverse(ans.begin(), ans.end());

    cout << ans.size() << '\n';
    for (int i : ans) {
        cout << i + 1 << " ";
    }
    cout << '\n';
}




ll gcd(ll a, ll b) {
    if (!a || !b)
        return a | b;
    unsigned shift = __builtin_ctzll(a | b);
    a >>= __builtin_ctzll(a);
    do {
        b >>= __builtin_ctzll(b);
        if (a > b) swap(a, b); b -= a;
    } while (b);
    return a << shift;
}

void go(){
    for (ll i = 2; i <= MX; ++i)
        if (primes[i].empty())
            for (ll j = i; j <= MX; j+=i)
                primes[j].emplace_back(i);

    for (ll i = 1; i <= MX; ++i)
        for (ll j = i; j <= MX; j+=i)
            divs[j].emplace_back(i);
}

void hi(){
    ll n , q , l , r  , op; cin >> n >> q;
    a = b = vector <ll > (n);
    mn = in =  vector < vector <ll>> (SQ+5 , vector <ll> (MX+5 , inf));
    for (auto &i : a) cin >> i;
    ll B = (n+ SQ-1)/SQ+1;
    for (int i = 0;i < n; ++i){
        cin >> b[i]; ll g = gcd(a[i] , b[i]);
        ans[i] = a[i] * b[i]/ (g *g);
        for (auto &d : divs[b[i]]) in[i/SQ][d] = min(b[i] ,in[i/SQ][d]);
        Bl[i/SQ] = min(Bl[i/SQ] , ans[i]);
    }

    for (int i = 0;i < B; ++i){
        for (ll x = 1; x <= MX; ++x){
            if (in[i][x] != inf) mn[i][x] = in[i][x] / x;
            for (auto &p : primes[x]){
                ll fx = x/ p;
                if (mn[i][fx] == inf) continue;
                mn[i][x] = min(mn[i][x] , mn[i][fx] * p);
            }
        }
    }

    auto calc =[&](ll bu){
        ll s = bu * SQ; ll e = min(s+SQ , n);
        ll & ret = Bl[bu]; ret = inf;
        for (int i = s; i < e; ++i) ret = min(ret , ans[i]);
    };
    auto drop =[&](ll bu){
        ll s = bu * SQ; ll e = min(s+SQ , n);
        ll & ret = Bl[bu]; ret = inf;
        for (int i = s; i < e; ++i){
            a[i] = lazy[bu]; ll g = gcd(a[i] , b[i]);
            ans[i] = a[i] * b[i]/ (g *g) ;
            ret = min(ret , ans[i]);
        }
        lazy[bu] = -1;
    };
    ll x;
    while (q--){
        cin >> op >> l >> r; l-=1 , r-=1;
        if (op == 1){
            cin >>x;assert(x <= MX);
            ll lB = l/SQ; ll L = min({n , (lB+1)* SQ , r+1});
            if (lazy[lB] != -1) drop(lB);
            for (int i = l; i < L; ++i){
                a[i] = x;
                ans[i] = a[i] * b[i]; ll g = gcd(a[i] , b[i]);
                ans[i]/= (g *g);
            }
            calc(l/SQ);
            ll rB = r/SQ; ll R = max(l , rB * SQ);
            if (lazy[rB] != -1) drop(rB);
            for (int i = r ;i >= R; --i){
                a[i] = x;
                ans[i] = a[i] * b[i];  ll g = gcd(a[i] , b[i]);
                ans[i]/= (g *g);
            }
            calc(r/SQ);
            for (int i= lB+1; i < rB; i++){
                lazy[i] = x;
                Bl[i] = mn[i][x];
            }
            continue;
        }
        ll ret = inf;
        if (lazy[l/SQ] != -1) drop(l/SQ);
        if (lazy[r/SQ] != -1) drop(r/SQ);
        for (int i = l; i <= r; ){
            if (i %SQ == 0 && i+SQ-1 <= r) ret = min(Bl[i/SQ] , ret) , i+=SQ;
            else ret = min(ret , ans[i++]);
        }
        cout << ret << nd;

    }



}

void go (int i , ll mul){
    if (i == (int)freq.size()){
        v.emplace_back(mul);return;
    }
    go(i+1 , mul);
    for (int j = 1; j <= freq[i].second; ++j){
        mul*= freq[i].first;
        go(i+1 , mul);
    }
}


bool go(ll mid){
    nxt = vector < vector <int > > (26 , vector <int> (2 * n , n+1));
    for (int i = 0; i < k; ++i){
        int last = n+1; ll cnt = 0;
        for (int j = n-1; j >= 0 ; --j){
            if (id(s[j]) == i|| s[j] == '?') cnt++;
            else cnt = 0;
            if (cnt >= mid) last = j;
            nxt[i][j] = last;
        }
    }
    vector <int > dp(1<<k , inf);
    dp[0] = 0;
    min_heap<pair<ll,ll>> q;
    q.emplace(0 , 0);
    while (!q.empty()){
        auto node = q.top(); q.pop();
        int mask = node.second;
        if (dp[mask] >= n) continue;
        for (int bit = 0; bit < k; ++bit){
            if (mask & (1 << bit)) continue;
            int cost = nxt[bit][dp[mask]] + mid;
            int msk = mask |(1 << bit);
            if (dp[msk] > cost){
                dp[msk] = cost;
                q.emplace(cost , msk);
            }
        }
    }
    return dp.back() <= n;

}


bool go(ll mid){
    nxt = vector < vector <int > > (26 , vector <int> (2 * n , n+1));
    for (int i = 0; i < k; ++i){
        int last = n+1; ll cnt = 0;
        for (int j = n-1; j >= 0 ; --j){
            if (id(s[j]) == i|| s[j] == '?') cnt++;
            else cnt = 0;
            if (cnt >= mid) last = j;
            nxt[i][j] = last;
        }
    }
    vector <int > dp(1<<k , inf);
    dp[0] = 0;
    function<int(int )> solve =[&](ll mask)-> int{
        int & ret = dp[mask];
        if (ret != -1) return ret;
        ret = inf;
        for (int i = 0; i < k; ++i){
            if (mask & (1 << i)) {
                int prv = mask ^ (1 << i);
                int value = solve(prv);
                if (value < n) mn_self(dp[mask], nxt[i][value] + mid);
            }

        }
        return ret;
    };
    return solve((1 << k)-1) <= n;

}

int n , m; cin >> n >> m;
vector<vector<ll> > a(n , vector <ll>(m));
for (auto &i : a) for (auto &j : i) cin >> j , --j;
ll ans = 0;
for (int j = 0; j < m; ++j){
vector <int > cnt(n);// the number of cycles needed to put the element in its position
for (int i = 0;i < n; ++i){
if (a[i][j] % m != j || a[i][j] /m >= n) continue;
cnt[(i - a[i][j]/m +n) % n]++;
}
int cur = n - cnt[0];
for (int i = 1; i < n; ++i) cur = min(cur , n-cnt[i]+i);
ans+=cur;
}
cout << ans <<nd;



auto fuck =[&](ll MAX)->bool{
    vector <vector <ll > > G(n+5);
    for (int i = 1; i <= n; ++i){
        for (auto &ch : g[i]){
            G[i].emplace_back(ch.first);
            if (MAX >= ch.second) G[ch.first].emplace_back(i);
        }
    }
    vector <bool > mark(n+5);
    function<void(int)> dfs =[&] (int node){
        mark[node] = 1;
        for (auto &ch : G[node]) if (!mark[ch]) dfs(ch);
    };
    stack<ll>st;
    for (int i = 1; i <= n; ++i)
        if (!mark[i])st.emplace(i) , dfs(i);
    mark = vector <bool> (n+5);
    dfs(st.top());
    bool ac = 1;
    for (int i = 1; i <= n; ++i)  ac&= mark[i];
    return ac;
};



int MX;
template< typename  T > using min_heap = priority_queue <T , vector <T >  , greater < T > > ;
struct node{
    ll data;
    node*l; node *r;
};
node buf[N];
int index;

node* extend(node*l , node *r , int sum){
    buf[index].l = l;
    buf[index].r = r;
    buf[index].data = sum;
    assert(index+1 < N);
    return &buf[index++];
}
node * leaf (int sum){
    return extend(nullptr , nullptr , sum);
}
node * merge(node *l , node *r){
    return extend(l , r , l->data+ r->data);
}
node * build (int node_low , int node_high){
    if (node_high - node_low == 1) return leaf(0);
    int mid = node_high + node_low >> 1;
    node *lf = build(node_low , mid);
    node *rt = build(mid , node_high);
    return merge(lf , rt);
}
node * upd (node * tree  , int i, int node_low , int node_high){
  //  cout << node_low <<" "<< node_high << endl;
    if (node_high - node_low == 1) return leaf(1);
    int mid = node_low + node_high >> 1;
    node * lf = tree->l; node *rt = tree->r;
    i < mid ? lf = upd(lf , i , node_low , mid) : rt = upd(rt , i , mid , node_high);
    return merge(lf , rt);
}
vector <node* > root;
struct union_{
    vector <int > par;
    vector <vector <int > > in;
    int n;
    vector<bool > mark;
    void init(int _n){
        n = _n;
        par = vector <int > (n+5);
        in = vector < vector <int > >(n+5);
        mark = vector <bool > (n+5);
        iota(all(par) , 0);
        for (int i = 1; i <= n; ++i) in[i].emplace_back(i);
    }
    int findp (int node){
        if (par[node] == node) return node;
        return par[node] = findp(par[node]);
    }
    bool same(int u , int v){
        return findp(u) == findp(v);
    }
    bool merge(int u , int v , ll cost){
        root[cost] = root[cost-1];
        if (same(u , v)) return 0;
        u = findp(u);
        v = findp(v);
        if ((int)in[v].size() > (int)in[u].size()) swap(u , v);
        par[v] = u;
        for (auto &i : in[v]){
            in[u].emplace_back(i);
            if (i+1 <= n && !mark[i+1] && same(i+1 , i)){
                mark[i+1] = 1;
                root[cost] = upd(root[cost] , i+1 , 0 , MX);
            }
            if (!mark[i] && i-1 >= 1 && same(i-1 , i)){
               mark[i] = 1;
               root[cost] = upd(root[cost] , i , 0 , MX);
            }

        }
        in[v].clear();
        return 1;
    }
};
ll ask(node * tree , int query_low , int query_high , int node_low , int node_high){
    if (node_low >= query_high || query_low >= node_high) return 0;
    if (query_low <= node_low && query_high >= node_high) return tree->data;
    int mid = node_low + node_high >> 1;
    ll ans = ask(tree->l , query_low , query_high , node_low , mid);
    ans+= ask(tree->r , query_low , query_high , mid , node_high);
    return ans;
}
void hi(){
    ll n , m , q; cin >>n >> m >> q;
    union_ dsu; dsu.init(n+5);
    index = 0;
    root = vector <node*> (n+5);
    MX = n+4;
    root[0] = build(0 , MX);
    for (int u , v , i = 1; i <= m; ++i){
        cin >> u >> v;
         dsu.merge(u , v , i);
    }
    auto calc =[&](ll l , ll r)->ll{
        ll st = 1 , end = n;
        while (st<= end){
            ll mid = st + end >> 1;
            ll v = ask(root[mid] , l , r+1 , 0 , MX);
            if (v == r-l+1) end = mid-1;
            else st = mid +1;
        }
        return st;
    };
    //pp;
    for (int l , r , ans ,  i = 1; i <= q; ++i){
        cin >> l >> r;
       l == r? ans = 0 : ans = calc(l+1 , r);
        cout << ans <<" \n"[i == q];

    }


}
*/


// sweep line
// reachability capital problem

      ll n , m1 , m2;
    cin >> n >> m1 >> m2;
    // d % row == 0 && d/row <= n // d/ maxcol = mnrow
    vector <pair <int , int > > a;
    map<int , int > mp;
    for (auto i : {m1  , m2}){
        for (ll k = 2; k * k <= i; ++k) while (i % k == 0) mp[k]++ , i/= k;
        if (i > 1) mp[i]++;
    }
    for (auto &p : mp) a.emplace_back(p);

    vector <ll > d;
    function<void(int , ll)> solve =[&](int  i , ll lc){
        if (i == (int)a.size()){
            d.emplace_back(lc);
            return;
        }
        solve(i+1 , lc);
        for (int j = 0; j < a[i].second; ++j){
            lc*=a[i].first;
            solve(i+1 , lc);
        }
    }; solve(0 , 1);
    sort(all(d));
    ///print(d);

    assert((int)a.size() <= 40);
    int sz = (int)d.size();
    vector <int > dp(sz+5 , 1);
    for (int i  = 0; i < sz; ++i) if (d[i] <= n) dp[i] = d[i];

    for (auto &oo : a){
        ll p = oo.first; int l = 0;
        for (int i = 0; i < sz; ++i){
            if (d[i] % p == 0) {
                ll nx = d[i] / p;
                while (d[l] != nx) ++l;
               /// cout << l << " " << nx << endl;
                assert(l < sz && d[l] == nx);
                dp[i] = max(dp[i], dp[l]);
            }
        }
    }
    pair <ll,ll> ans {0 , 0};
    for (int i = 0; i < sz; ++i){
        ll ret = d[i]/ dp[i];
        if (ret <= n){
            ans.first+=1;
            ans.second^= ret;
        }
    }
    cout << ans.first <<" "<< ans.second << nd;


struct node{
    node *l, *r;
    long long sumc, sumr;
    node() : l(NULL), r(NULL), sumc(0), sumr(0) {}
    node(node* l, node* r, long long sumc, long long sumr) : l(l), r(r), sumc(sumc), sumr(sumr) {}
};

node* build(int l, int r, vector<int> &c){
    if (l == r - 1)
        return new node(NULL, NULL, c[l], 0);
    int m = (l + r) / 2;
    node* nw = new node();
    nw->l = build(l, m, c);
    nw->r = build(m, r, c);
    nw->sumc = nw->l->sumc + nw->r->sumc;
    return nw;
}

node* upd(node* v, int l, int r, int pos, int val){
    if (l == r - 1)
        return new node(NULL, NULL, 0, val);
    int m = (l + r) / 2;
    node* nw = new node(v->l, v->r, 0, 0);
    if (pos < m)
        nw->l = upd(v->l, l, m, pos, val);
    else
        nw->r = upd(v->r, m, r, pos, val);
    nw->sumc = nw->l->sumc + nw->r->sumc;
    nw->sumr = nw->l->sumr + nw->r->sumr;
    return nw;
}

long long getsum(node *v, int mult){
    return v->sumc + v->sumr * mult;
}

int trav(node *v, int l, int r, int L, int R, long long &lft, int mult){
    if (L >= R){
        return 0;
    }
    if (l == L && r == R && lft - getsum(v, mult) >= 0){
        lft -= getsum(v, mult);
        return r - l;
    }
    if (l == r - 1){
        return 0;
    }
    int m = (l + r) / 2;
    int cnt = trav(v->l, l, m, L, min(m, R), lft, mult);
    if (cnt == max(0, min(m, R) - L))
        cnt += trav(v->r, m, r, max(m, L), R, lft, mult);
    return cnt;
}

struct seg{
    int l, r, lst, cur;
};

int main() {
    int n;
    scanf("%d", &n);
    vector<int> c(n), r(n);
    forn(i, n) scanf("%d%d", &c[i], &r[i]);

    vector<int> ord(n);
    iota(ord.begin(), ord.end(), 0);
    sort(ord.begin(), ord.end(), [&](int x, int y){
        return c[x] / r[x] > c[y] / r[y];
    });
    vector<int> vals;
    for (int i : ord) vals.push_back(c[i] / r[i]);

    vector<node*> root(1, build(0, n, c));
    for (int i : ord)
        root.push_back(upd(root.back(), 0, n, i, r[i]));

    vector<seg> st;
    for (int i = n - 1; i >= 0; --i)
        st.push_back({i, i + 1, 0, c[i]});

    long long ans = 0;
    int q;
    scanf("%d", &q);
    forn(_, q){
        int t;
        long long h;
        scanf("%d%lld", &t, &h);
        while (!st.empty()){
            auto it = st.back();
            st.pop_back();
            if (it.r - it.l == 1){
                it.cur = min((long long)c[it.l], it.cur + (t - it.lst) * 1ll * r[it.l]);
                if (it.cur <= h){
                    h -= it.cur;
                }
                else{
                    st.push_back({it.l, it.r, t, int(it.cur - h)});
                    h = 0;
                }
            }
            else{
                int mx = vals.rend() - lower_bound(vals.rbegin(), vals.rend(), t - it.lst);
                ll cmp = upper_bound(all(vals) , t-it.lst)-vals.begin() ;
               // mx = cmp;
               cout << mx << " "<<n-cmp <<nd;
                int res = it.l + trav(root[mx], 0, n, it.l, it.r, h, t - it.lst);
                assert(res <= it.r);
                if (res != it.r){
                    if (it.r - res > 1)
                        st.push_back({res + 1, it.r, it.lst, 0});
                    int nw = min((long long)c[res], r[res] * 1ll * (t - it.lst));
                    assert(nw - h > 0);
                    st.push_back({res, res + 1, t, int(nw - h)});
                    h = 0;
                }
            }
            if (h == 0){
                break;
            }
        }
        if (st.empty()){
            st.push_back({0, n, t, 0});
        }
        else if (st.back().l != 0){
            st.push_back({0, st.back().l, t, 0});
        }
        ans += h;
    }

    printf("%lld\n", ans);
    return 0;
}





// check binary mx+1 , mx-1 // use fucken arrays instead of vectors
// stay fucken organised
// write a hard proof induction vs contradiction


// 24 hours a day 7 days a week lets gooooooooooooooo
// if u wanna things never done before u must do things never done before // killer
// road to candidate master



// simple test freq even odd 1 2 3 4 5 to 10 sec max observation
// check first min and second min // sqrt decomposetion
/*





ll v, arr[10], dp[N], f = 0;
int solve(int used)
{
    if (dp[used] != -1)
        return dp[used];
    int temp = 0;
    for (int i = 1; i < 10; i++)
    {
        if(used + arr[i] <= v)
            temp = max(temp, 1 + solve(used + arr[i]));
    }
    return dp[used] = temp;
}

void get_ans(int used)
{
    for (int i = 9; i  ; i--)
    {
        if (used + arr[i] <= v && dp[used] == 1 + solve(used + arr[i]))
        {
            f = 1;
            cout << i;
            get_ans(used + arr[i]);
            return;
        }
    }
    return;
    memset(dp, -1, sizeof dp);
    cin >> v;
    for (int i = 1; i < 10; i++)
        cin >> arr[i];
    solve(0);
    get_ans(0);
    if (!f)
        cout << -1;
}
*/
// two fucken pointers // partial sum // try all ways using trees // reverse fucken thinking
// w2af 3loia ans take some fucken observations and trase for ever ya 3el2
/*
 * 1
10
10 3 2 1 9 8 7 6 5 4

ll n , m , k; cin >>n>>m>>k;
  ll ans = Fp(k , n);
  for (ll i =1; i<= k; ++i){
      ll v = mul(Fp(k-i , n)  ,  nCr(k , i)); int c = i & 1 ? -1 : 1;
      ans = add(ans , c *v);
  }
  ans = mul(ans , nCr(m , k));
  cout <<ans<<nd;
ll dp[10][10];
ll n , k; cin >>n>>k;
vector<ll>we(n+1) , v(n+1);
for (int i = 1; i <= n; ++i) cin >>we[i];
for (int i = 1; i <= n; ++i) cin >>v[i];
dp[0][0] = 0;
for (int i = 1; i <= n; ++i){
    for (int w = 0; w <= k; ++w){
        dp[i][w] = dp[i-1][w];
        if (w >= we[i]){// rem weight = w- we[i]
            dp[i][w] = maxz(dp[i][w] , dp[i-1][w-we[i]]+v[i]);
        }
    }
}
cout <<dp[n][k]<<nd;
}

// table dp
// make something fixed something ahd see the difference
//always  think in ranges ?? less than or greater than // equal

// check overflow int vs ll 1e5 * 1e5 //  max_ranges


// simple test 1-10

// cycle defenistion ?????? // n smmall ?? how many arranges

// stay organised // some notes // leave it ??
// range cover
// sqrt relation
// mid+ mid-1 --- > mid/2+1

//  vector<ll>arr(n); for (ll &i : arr) cin >>i;
/// ll dp[2][n+10];
/*
dp[i][0] = max(dp[i-1][1]  , dp[i-1][0])
dp[i][1] = dp[i-1][0]+arr[i]
*/
// recurrence relations // states // transitions  //dp array


// seg tree
///elly fat tas5een w elly gay allah el mo3een
// lst = -1 , lst+1 // long long
// try greedy in b and a no coplicated  trace from 1 to 10
// a few against many // 4 days of return can we? // 24 hours a day 7 days a week


struct DSU{
    int n; vector<ll>par; vector<ll>in;
    DSU(int _n){
        this-> n = _n+100; par.resize(n); iota(all(par) , 0); in.assign(n , 1);
    }

    int findP(int u){
        if (u == par[u]) return u;
        return par[u] = findP(par[u]);
    }

    bool is_connected(int u , int v){
        return findP(u) == findP(v);
    }

    bool connect(int u , int v){
        u = findP(u); v = findP(v);
        if (u == v) {
            return 0;// cyclic
        }
        if (in[u] > in[v]){
            in[u]+=in[v];  par[v] = u;// in[v]= {};
        }else{
            in[v]+=in[u]; par[u] = v;// in[u]={};
        }
        return 1;
    }

};



//0 1bfs //prefix  - suffix heap




void dijk(int node){

    for (int i = 0;i < N; ++i){
        dist[i] = inf;
    }

    priority_queue<pair<ll,ll> , vector<pair<ll,ll>> , greater<pair<ll,ll>> >q;
    // cost // node
    dist[node] = {};
    q.emplace(0 , node);
    while (!q.empty()){
        auto top = q.top(); q.pop();// cost // node
        if (top.first > dist[node]) continue;
        for (auto & ch : gr[top.second]){
            // node // cost
            ///  top.first
            if (dist[top.second]+ ch.second < dist[ch.first]){
                dist[ch.first]= dist[top.second]+ ch.second ;
                //////////////////top.first
                q.emplace(dist[ch.first] ,  ch.first);
            }
        }
    }


}

// long long
// kruskal // prim --->>>> minimum spanning tree
// connection from top level not down


//probabilty ??? all elemets ?? multible chioces?? .. ask ur self// all is easy even last problrm if u are brave enough
// tracing to solve
//we are coming// create final answer // and take obsevations
// stack of recursion // always allocate memory in heap with recursion
// undo from back tracking ? it deserve??
// prefix not suffix   // binary for multibles  // max height
// pre processing // different approaches // if its complicated its not the sol // simulation
// partial sum.. prefix// greedy if implemetation failed // try i end
// even odd // tests// alot of test cases// binary
// constrains review // too slow// be careful //  easy approach// two ptr
// something special position 0 or 1 // if u dont know how to set elememts
// reverse thinking // equation // analyze all sides
// mapping with index utilize recursion // a lot of stls set map__> for each element
// wait
// try to use pointers // null ptr // free memo
// binary heap last level filled from left // the height of tree = ceil(log2(n+1))-1// each level 2^i nodes
// heap must be complete binary tree
/// monotonic stack way ?? stack of pair or pq or dq // relation between index
///   priority_queue<pair<ll,ll>  , vector<pair<ll,ll>>, greater<pair<ll,ll>>>pq; //0 // idx
/// +1 -1 way

///sum[i % m ] += arr[i].first;
///ind[arr[i].second] = (i % m )  + 1;  /// utilize strings pattern
///////////////////

 test --> odd -even freq   // if fails trace another 1 - 10 // basecases 0 1 2 // power of 2//reverse thinking


vector<vector<ll>>adj(N); vector<ll>cost(N) ,dp(N);
vector<bool>vis(N) , inStack(N);
ll n , m , k;
bool is_cyclic = 0;

void dfs(int node , ll mx){
    inStack[node] = vis[node] = true;
    for (auto &ch : adj[node]){ if (cost[ch] > mx) continue;
        if (!vis[ch])
          dfs(ch , mx);
        is_cyclic|= inStack[ch];
        dp[node] = max(dp[node] , dp[ch]+1);
    }
    inStack[node] = false; dp[node] =max(dp[node] , 1ll);

}
 ///////////////////////////
  cin >>n>>m>>k;
    for (int i = 1; i <= n; ++i) adj[i].clear() , vis[i]= {} , dp[i]= {} ;
    for (int i = 1; i <= n; ++i){
        cin >>cost[i];
    }
    for (int i = 1; i <= m; ++i){
        int u , v; cin >>u>>v; adj[u].emplace_back(v);
    }
    auto go=[&](ll mx)->bool{
        is_cyclic = 0;
        for (int i = 1; i <= n; ++i){ vis[i]= {} , dp[i]= {};}
         for (int i = 1; i <= n; ++i){ if (cost[i] > mx|| vis[i]) continue;
             if (dfs(i , mx) >= k || is_cyclic) return true;
         }
        return false;
    };
    vector<ll>sorted = cost;
    sort(all(sorted)) , sorted.resize(unique(all(sorted))-sorted.begin());
    ll st = 0 ,end = (int)sorted.size()-1;
    ll ans = -1;
    while (st <=end){
        ll mid = st + end >> 1;
        bool ac = go(sorted[mid]);
        if (ac){
            ans = sorted[mid]; end = mid-1;
        }else{
            st = mid+1;
        }
    }
    cout <<ans<<nd;



ll l , r; cin >> l >> r;
ll sq = sqrtl(l-1); while (sq * sq  < l)++sq;
ll ans = 0;
for (ll k = 1; k <= sq; ++k){
ll L = (l+k-1)/k; ll R = (k > 1) ? (l-1)/(k-1) : 2e18;
R = min(R  , r/ (k+1));
if (L <= R) ans+= R -L+1;
}
for (ll g = 1; g <= sq; ++g){
ll k = (l+g-1)/g;
ans+= (k > sq && (k+1) *g <= r);
}
cout << ans <<nd;

function<int(int , int , int) > Bad_ass=[&](int node , int d , int target)->int{// will tle ? if it was a chain ?
    // cout << node <<" "<<is_black[node] <<nd;
    if (is_black[node])
        return d;
    int ans = dist[node]+ d;
    int ret = Bad_ass(par[node] , d+1 , target);
    //cout << node <<" "<< ret <<" "<<d <<" ";
    dist[node] = min(dist[node] , d);
    ans = min(ans , ret);
    // cout << dist[node] <<" "<< ans <<nd;
    is_black[node]|= (node == target);
    return ans;
};

 auto go =[&](set <int > &src , set <int > & ans , set <int > & to){
        priority_queue<pair <int , pair<int , int > > > q; // d , dist , node
        for (auto &i : src) q.push({depth[i] ,{ 0 , i}});
        while (!q.empty()) {
            auto top = q.top();q.pop();
            int dist = top.second.first; int node = top.second.second;
            if (ans.find(node) != ans.end()) continue;
            ans.emplace(node);
            if (dist >= d) to.emplace(node);
            int p = par[node];
            q.push({depth[p], {dist + 1, p}});
        }
    };


struct myT{
    vector <ll> tree; int n;
    void init(int _n){
        n = _n+1;
        tree = vector <ll> (n+100);
    }
    void upd (int x , int v){
        for (int i = x; i <= n; i+= i & -i) tree[i]+=v;
    }
    ll ask(int i){
        ll ans = 0;
        while (i) ans+= tree[i] , i-= i & -i;
        return ans;
    }
    ll ask (int l , int r){
        return ask(r) - ask(l-1);
    }
};
set <int > idx[N];
struct RangeQuery{
    vector <int > tree , lazy; int n ;
    void S(int _n){
        n = _n;
        while (popcount(n)!= 1)++n;
        lazy = vector <int > (2 *n , -1);
        tree = vector <int > (2 *n);
    }
    void drop (int node , int node_low , int node_high){
        if (lazy[node] == -1) return;
        tree[node] = lazy[node];
        if (node_high - node_low -1){
            lazy[2* node+1] = lazy[2* node+2] = lazy[node];
        }
        lazy[node] = -1;
    }
    void upd(int node , int node_low , int node_high , int query_low , int query_high , int data){
        drop(node , node_low , node_high);
        if (node_low >= query_high || query_low >= node_high) return;
        if (node_low >= query_low && query_high >= node_high){
            lazy[node] = data;
            drop(node , node_low , node_high);
            return;
        }
        int mid = node_low + node_high >> 1;
        upd(2* node +1 , node_low , mid , query_low , query_high , data);
        upd(2* node +2 , mid , node_high , query_low , query_high , data);
    }
    void upd(int l , int r , int v){
        upd(0 , 0 , n , l , r , v);
    }
    ll query(int node , int node_low , int node_high , int i){
        drop(node , node_low , node_high);
        if (node_high - node_low == 1) return tree[node];
        int mid = node_low + node_high >> 1;
        if (i < mid) return query(2* node+1 , node_low , mid , i);
        return query(2* node+2 , mid , node_high , i);
    }
    ll query(int i){
        return query(0 , 0 , n , i);
    }
};
void hi(int tc) {
    ll n; cin >> n;
    vector <int > a(n) , nxt;
    //  RangeQuery tree; tree.S(n);
    for (int i = 0; i < n; ++i){
        cin >> a[i];
        idx[a[i]].emplace(i);
        nxt.emplace_back(i+1);
        // tree.upd(i , i+1 , a[i]);
    }
    int q ,c; cin >> q;
    while (q--){
        cin >> c;
        if ((int)idx[c].size() < 2) continue;
        int L = *idx[c].begin();
        int R = *idx[c].rbegin();
        vector <int > upd;

        for (int i = L ; i < R; i = nxt[i]){
            int in = tree.query(i);
            if (idx[in].find(i) != idx[c].end()) idx[in].erase(i);
            upd.emplace_back(i);
        }
        for (int i = L ; i < R; i = nxt[i])
            idx[a[i]].erase(i);
        nxt[L] = R;

        for (auto &l : upd) nxt[l] = R;
        tree.upd(L , R+1 , c);
    }
    //for (int i = 0; i < n; ++i) cout << tree.query(i)<<" ";

    for (int i = 0; i < n; i = nxt[i])
        for (int k = 0; k < nxt[i]-i; ++k)
            cout << a[i] <<" ";



}


vector <int > dep , up_path , bad;
vector<ll>sum , cost;vector <bool>banned;
vector<vector <int > > anc , col;
ll n;
vector < vector <pair <int , int > > > g;
vector <set<pair <ll,int > > > me;
void init(){
    sum= cost = vector <ll>(n+5);
    anc = vector < vector <int > > (n+5 , vector <int> (LOG+1));
    bad = dep = vector <int > (n+5);
    up_path =vector <int > (n+5 , -1);
    col = vector < vector <int > >(n+5);
    g =vector < vector <pair <int , int > > > (n+5);
    banned = vector <bool>(n+5);
    me = vector <set <pair <ll , int > > > (n+5);
}
void dfs(int node , int p){
    anc[node][0] = p;
    for (int i = 1; i < LOG; ++i) anc[node][i] = anc[anc[node][i-1]][i-1];
    for (auto &ch : g[node]){
        if (ch.first == p) continue;
        sum[ch.first] = sum[node] +ch.second;
        dep[ch.first] = 1+ dep[node];
        dfs(ch.first , node);
    }
}
ll kth(int node , int k){
    for (int i = LOG-1; ~i ; --i)
        if (k & (1 << i)) node = anc[node][i];
    return node;
}
ll lca(int u , int v){
    if (dep[u] < dep[v]) swap(u , v);
    u = kth(u , dep[u]- dep[v]);
    if (u == v) return u;
    for (int i = LOG-1; ~i ; --i){
        if (anc[v][i] != anc[u][i]) {
            u = anc[u][i];
            v = anc[v][i];
        }
    }
    assert(anc[u][0] == anc[v][0] && u ^ v);
    return anc[u][0];
}
void hi(int tc) {
    ll qs; cin >> n >> qs;
    init();
    for (int u , v , c , w  , i = 1; i < n; ++i){
        cin >> u >> v >>w >> c;
        col[c].emplace_back(u);
        col[c].emplace_back(v);
        g[u].emplace_back(v , w);
        g[v].emplace_back(u , w);
    }
    dfs(1 , 1);
    vector <array<int , 2 > > path;
    for (int i = 1; i <= n; ++i){ // get leafs of the path of unique color
        if (col[i].empty()) continue;
        vector <int > leafs;
        int sz = (int)col[i].size();
        sort(all(col[i]));
        int l = 0;
        while (l < sz) {
            int r = l;
            while (r < sz && col[i][l] == col[i][r]) ++r;
            if (r - l >= 3) goto out;
            if (r - l == 1) leafs.emplace_back(col[i][l]);
            l = r;
        }
        if ((int)leafs.size() >= 3) continue;
        assert((int)leafs.size() == 2);
        path.push_back({leafs[0] , leafs[1]});
        out:;
    }

    for (int i = 0; i < (int)path.size(); ++i){
        int u = path[i][0] ; int v = path[i][1];
        ll lc = lca(u , v);
        for (int node = u; node != lc ; node = anc[node][0])
            up_path[node] = i;
        for (int node = v; node != lc ; node = anc[node][0])
            up_path[node] = i;
        cost[i] = sum[u] + sum[v] -2 *sum[lc];
        me[lc].emplace(cost[i] , i);
    }

    auto get =[&](int u )->pair <ll , int >{
        if (me[u].empty())
            return {0 , u};
        return {me[u].rbegin()->first , u};
    };
    priority_queue<pair <ll,int > > q;

    auto add =[&](int i){
        int lc = lca(path[i][0] , path[i][1]);
        me[lc].emplace(cost[i] , i);
        q.emplace(get(lc));
    };

    auto del =[&](int i){
        int lc = lca(path[i][0] , path[i][1]);
        me[lc].erase({cost[i] , i});
        q.emplace(get(lc));
    };
    //int o = 0;
    // for (auto &i : path)
    // cout <<i[0] <<" "<<i[1]  <<" "<<cost[o++]<<nd;


    for (int i = 1; i <= n; ++i) q.emplace(get(i));
    for (int p , u , i = 1; i <= qs; ++i){
        cin >> p >> u;

        if (!p){
            banned[u] = 1;
            if (~up_path[u]){
                bad[up_path[u]]++;
                if (bad[up_path[u]] == 1) del(up_path[u]);
            }

        }
        else {
            // push
            q.emplace(get(u));
            banned[u] = 0;
            if (~up_path[u]) {
                bad[up_path[u]]--;
                if (!bad[up_path[u]]) add(up_path[u]);
            }
        }

        while (!q.empty()){
            auto top = q.top();
            //  cout << top.second <<" "<< banned[top.second] <<endl;
            // cout << get(top.second).first <<endl;
            if (!banned[top.second] && get(top.second).first == top.first) break;
            q.pop();
        }
        ll ans = (q.empty() ? 0 : q.top().first);
        cout << ans <<nd;

    }


}


ll n , qs;
vector <ll>sum , deg;
vector < vector<pair <int ,int > > >col;
vector < vector <int > >g;
vector <int > par ,up , col_lc;
vector< vector<int > >node_to_col;
void init(){
    col_lc = par = up = vector <int > (n+5 , -1);
    g = vector < vector <int > > (n+5);
    deg = sum = vector <ll> (n+5) ;
    node_to_col = vector < vector <int > >(n+5);
    col = vector < vector<pair <int ,int > > >(n+5);
}
void dfs(int node , int p){
    par[node] = p;
    for (auto &ch : g[node]) {
        if (ch == p) continue;
        dfs(ch, node);
    }
}

struct myT{
    vector <ll > tree ; int parent ;
    void S (int n){
        parent = n;
        while (popcount(parent) != 1)++ parent;
        tree = vector <ll> (2 * parent);
    }
    void upd(int i , ll p , int node , int node_low , int node_high ){
        if (node_high- node_low == 1) {
            tree[node] = p;return;
        }
        int mid = node_low+ node_high >> 1;
        i <  mid  ?  upd(i , p  , 2*node+1 , node_low , mid ) : upd(i , p, 2* node+2 , mid  , node_high );
        tree[node] = max(tree[2* node+1] , tree[2* node+2]);
    }
    void upd(int i , ll v){
        return upd(i , v , 0 , 0 , parent);
    }
    ll query (int node , int node_low , int node_high  , int query_low , int query_high){
        if (node_low >= query_high || query_low >= node_high) return 0;
        if (node_low >= query_low && query_high >= node_high) return tree[node];
        int mid = node_low + node_high >> 1;
        auto op1= query(2* node+1 , node_low , mid , query_low , query_high);
        auto op2 = query(2* node+2 , mid , node_high , query_low , query_high);
        return max(op1 , op2);
    }
    ll query (int l , int r){
        return query(0 , 0 , parent , l , r+1);
    }
    ll f(){
        return query(0 , parent-1);
    }

};

void hi(int tc) {
    cin >> n >> qs;
    init();
    for (int u , v , w , c , i = 1; i < n; ++i){
        cin >> u >> v >> w >> c;
        col[c].emplace_back(u , v);
        sum[c]+=w;
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }
    dfs(1 , 1);

    vector <int > is_child(n+5);
    for (int i = 1; i <= n; ++i){
        for (auto &edges : col[i]) {
            deg[edges.first]++ ,deg[edges.second]++;
            if (par[edges.first] == edges.second) swap(edges.first , edges.second);
            is_child[edges.second] = 1;
        }
        int c1 = 0;
        for (auto &edges : col[i]){
            c1+= (deg[edges.first] == 1);
            c1+= (deg[edges.second] == 1);
        }
        if (c1 == 2) {
            ll lc = -1;
            for (auto &edges: col[i]) {
                if (!is_child[edges.first]) lc = edges.first;
                up[edges.second] = i;
            }
            assert(~lc);
            col_lc[i] = lc;
            node_to_col[lc].emplace_back(i);
        }
        for (auto &edges : col[i]){
            deg[edges.first]-- ,deg[edges.second]--;
            is_child[edges.second] = 0;is_child[edges.first] = 0;
        }
    }


    vector <myT> trees(n+5); // 0 all answers!
    trees[0].S(n+2);
    vector <int > idx(n+5); // of color
    for (int i = 1; i <= n; ++i){
        int sz = (int)node_to_col[i].size();
        trees[i].S(sz+2);
        for (int k = 0; k < sz; ++k){
            int c = node_to_col[i][k];
            idx[c] = k;
            trees[i].upd(k  ,sum[c]);
        }
        trees[0].upd(i , trees[i].f());
    }

    vector <bool > on(n+5 , 1);
    vector <int > cover(n+5);
    for (int p , u  , i = 1; i <= qs; ++i){
        cin >> p >> u;
        on[u] = p;
        if (!p){
            if (~up[u]){
                cover[up[u]]++;
                if (cover[up[u]] == 1){
                    int lc = col_lc[up[u]];
                    assert(~lc);
                    trees[lc].upd(idx[up[u]] , 0);
                    trees[0].upd(lc , on[lc] ? trees[lc].f() :0);
                }
            }

            trees[0].upd(u , 0);
        }
        else{
            if (~up[u]){
                cover[up[u]]--;
                if (!cover[up[u]]){
                    ll lc = col_lc[up[u]];
                    assert(~lc);
                    trees[lc].upd(idx[up[u]] , sum[up[u]]);
                    trees[0].upd(lc , on[lc] ? trees[lc].f() : 0);
                }
            }

            trees[0].upd(u , trees[u].f());
        }
        cout << trees[0].f() << nd;

    }



}



///////////////////



ll n , qs , sz;
vector < vector <pair <int , int > > > g , anc;
vector <int > dep , lazy;
vector <pair <int , int > > ans , temp;
void init(){
    dep = vector <int > (n+5);
    anc = vector < vector <pair <int , int > > > (n+5 , vector <pair <int , int > > (LOG+1));
    g = vector < vector <pair <int , int > > > (n+5);
    sz = n+2;
    while (popcount(sz) != 1)++sz;
    lazy = vector <int > (2 * sz  , -1);
    temp = ans = vector <pair <int , int > > (2 * sz , {-1 , -1});
}
void dfs(int node , int p , int w){
    anc[node][0].first = p;
    anc[node][0].second = w;
    for (int i = 1; i < LOG; ++i){
        anc[node][i].first = anc[anc[node][i-1].first][i-1].first;
        anc[node][i].second = max(anc[node][i-1].second , anc[anc[node][i-1].first][i-1].second);
    }
    for (auto &ch : g[node]){
        if (ch.first == p) continue;
        dep[ch.first] = 1+ dep[node];
        dfs(ch.first , node  , ch.second);
    }
}
pair <int , int > kth(int node , int k){
    pair <int , int > ret;
    ret.first = node; ret.second = -1;
    for (int i = LOG-1; ~i ; --i) {
        if (k & (1 << i)){
            ret.second = max(ret.second , anc[ret.first][i].second);
            ret.first = anc[ret.first][i].first;
        }
    }
    return ret;
}
void lca (int u , int v , int &node , int& mx){
    //cout << u <<" "<< v << endl;
    mx = -1;
    if (u == -1 && v == -1) {
        node = mx = -1;
        return;
    }
    if (u == -1 || v == -1){
        node = max(u , v);
        return;
    }
    if (dep[u] < dep[v]) swap(u , v);
    auto p = kth(u , dep[u] - dep[v]);
    u = p.first ;  mx = p.second;
    node = u;
    if (u == v) return;

    for (int i = LOG-1; ~i ; --i){
        if (anc[u][i].first != anc[v][i].first){
            mx = max(mx , anc[u][i].second);
            mx = max(mx , anc[v][i].second);
            u = anc[u][i].first;
            v = anc[v][i].first;
        }
    }
    //  cout << u << " "<< v << endl;
    assert(u ^ v &&  anc[u][0].first == anc[v][0].first);
    mx = max({anc[u][0].second , mx , anc[v][0].second});
    node = anc[u][0].first;
    return;

}

void build (int node , int node_low , int node_high){
    if (node_high - node_low == 1){
        if (node_low == 0 || node_low > n) return;
        temp[node] = {node_low , -1};
        return;
    }
    int mid = node_low + node_high >> 1;
    build(2* node +1 , node_low , mid);
    build(2 * node+2 , mid, node_high);
    auto &p = temp[node];
    lca(temp[2 * node+1].first , temp[ 2* node+2].first , p.first , p.second);
    p.second = max({p.second , temp[2 * node+1].second , temp[2 * node+2].second});

}
void drop (int node , int node_low , int node_high){
    if (lazy[node] == -1) return;
    lazy[node] ? ans[node] = temp[node] : ans[node] = {-1 , -1};
    if (node_high - node_low -1) lazy[ 2* node +1 ] = lazy[2 * node +2] = lazy[node];
    lazy[node] = -1;
}
void upd (int node , int node_low , int node_high , int query_low , int query_high , int on ){ // on 1
    drop(node , node_low , node_high);
    if (node_low >= query_high || query_low >= node_high) return;
    if (node_low >= query_low && query_high >= node_high){
        lazy[node] = on;
        drop(node , node_low , node_high);
        return;
    }
    int mid = node_low + node_high >> 1;
    upd(2 * node +1 , node_low , mid , query_low , query_high , on);
    upd(2 * node+2 , mid , node_high , query_low , query_high , on);
    auto &p = ans[node];
    lca(ans[2 * node+1].first , ans[ 2* node+2].first , p.first , p.second);
    p.second = max({p.second , ans[2 * node+1].second , ans[2 * node+2].second});
    // cout << node <<" "<< node_low <<" "<< node_high <<" "<< p.first <<" "<< p.second <<" "<<on <<nd;
}
void upd(int l , int r , int on){
    upd(0 , 0 , sz , l , r+1 ,  on);
}

void hi(int tc) {

    cin >> n >> qs;
    init();
    for (int u , v , w , i = 1; i < n; ++i){
        cin >> u >> v >> w;
        g[u].emplace_back(v , w);
        g[v].emplace_back(u , w);
    }
    dfs(1 , 1 , 0);
    build(0 , 0 , sz);

    int op , l , r , u;
    for (int i = 1; i <= qs; ++i){
        cin >> op;
        if (op == 3){
            cin >> u;
            drop(0 , 0 , sz);
            auto &p = ans[0];
            if (p.first == -1){cout << -1 << nd;continue;}
            int mx = p.second;
            lca(u , p.first , l , r);
            mx = max(mx , r);
            cout << mx << nd;

            continue;
        }
        cin >> l >> r;
        upd(l , r , op == 1);
        //pp;
    }



}



struct T{
    vector <ll> tree  , lazy;
    int n;
    void S (int _n){
        n = _n;
        while (popcount(n) != 1) ++n;
        lazy = vector <ll> (2 * n , -1);
        tree = vector <ll> (2 * n);
    }
    void drop (int node , int node_low , int node_high){
        if (lazy[node] == -1) return;
        tree[node] = lazy[node] *(node_high - node_low);
        if (node_high - node_low -1) lazy[2 * node +1] = lazy[2 * node +2] = lazy[node];
        lazy[node] = -1;
    }
    void upd (int data , int node , int node_low , int node_high , int query_low , int query_high){
        drop(node , node_low , node_high);
        if (node_low >= query_high || query_low >= node_high) return;
        if (node_low >= query_low && query_high >= node_high){
            lazy[node] = data; drop(node , node_low , node_high);
            return;
        }
        int mid = node_low + node_high >> 1;
        upd(data , 2 * node +1 , node_low , mid , query_low , query_high);
        upd(data , 2* node +2  , mid , node_high , query_low , query_high);
        tree[node] = tree[2 * node +1] + tree[2 * node +2];
    }

    void upd (int l , int r , int data){
        upd(data , 0 , 0 , n , l , r+1);
    }
    ll query (int node , int node_low , int node_high , int query_low , int query_high){
        drop(node , node_low , node_high);
        if (node_low >= query_high || query_low >= node_high) return 0;
        if (node_low >= query_low && query_high >= node_high) return tree[node];
        int mid = node_low + node_high >> 1;
        ll ans = query(2 * node +1 , node_low , mid, query_low , query_high);
        ans+= query(2 * node +2 , mid , node_high , query_low , query_high);
        return ans;
    }
    ll query(int l , int r){
        return query(0 , 0 , n , l , r+1);
    }
    ll nxt_one(int node , int node_low , int node_high , int query_low , int query_high){
        drop(node , node_low , node_high);
        if (node_low >= query_high || query_low >= node_high|| !tree[node]) return -1;
        if (node_high - node_low == 1) return node_low;
        int mid = node_low + node_high >> 1;
        ll idx = nxt_one(2 * node +1 , node_low , mid , query_low , query_high);
        if (idx == -1) idx = nxt_one(2 * node+2 , mid , node_high , query_low , query_high);
        return idx;
    }
    ll nxt_one(ll l){
        return nxt_one(0 , 0 , n , l , n);
    }
    ll nxt_z(int node , int node_low , int node_high , int query_low , int query_high){
        drop(node , node_low , node_high);
        if (node_low >= query_high || query_low >= node_high|| tree[node]== node_high - node_low) return -1;
        if (node_high - node_low == 1) return node_low;
        int mid = node_low + node_high >> 1;
        ll idx = nxt_z(2 * node +1 , node_low , mid , query_low , query_high);
        if (idx == -1) idx = nxt_z(2 * node+2 , mid , node_high , query_low , query_high);
        return idx;
    }
    ll nxt_z(ll l){
        return nxt_z(0 , 0 , n , l , n);
    }
    ll last_one(int node , int node_low , int node_high , int query_low , int query_high){
        drop(node , node_low , node_high);
        if (node_low >= query_high || query_low >= node_high|| !tree[node]) return -1;
        if (node_high - node_low == 1) return node_low;
        int mid = node_low + node_high >> 1;
        ll idx = last_one(2 * node +2 , mid , node_high, query_low , query_high);
        if (idx == -1) idx = last_one(2 * node+1 , node_low , mid  , query_low , query_high);
        return idx;
    }
    ll last_one(ll l){
        return last_one(0 , 0 , n , l , n);
    }
};


struct T{
    vector <ll> sum , lazy , mn , mx; int n;
    void S(int _n){
        n = _n;
        while (popcount(n) != 1)++n;
        lazy = vector <ll > (2* n , -1);
        mn = sum  = vector <ll> (2* n);
    }

    void drop (int node , int node_low , int node_high){
        if (lazy[node] == -1) return;
        sum [node] = (node_high - node_low ) * lazy[node];
        mn [node] = lazy[node];
        if (node_high - node_low -1)
            lazy[2 * node +2] = lazy[ 2* node +1] = lazy[node];
        lazy[node] = -1;
    }


    void upd (ll data , int node , int node_low , int node_high , int query_low , int query_high){
        drop(node , node_low , node_high);
        if (node_low >= query_high || query_low >= node_high ) return;
        if (node_low >= query_low && query_high >= node_high){
            lazy[node] = data;
            drop(node , node_low , node_high);
            return;
        }
        int mid = node_low + node_high >> 1;
        upd(data , 2* node +1 , node_low , mid , query_low , query_high);
        upd(data , 2 * node +2 , mid , node_high , query_low , query_high);
        mn [node] = min(mn[2* node+1] , mn[2* node+2]);
        sum[node] = sum[2 * node +2] + sum[ 2 * node+1];
    }
    void upd (int l , int r , int data){
        upd(data , 0 , 0 , n , l , r+1);
    }
    ll first(int data , int node , int node_low , int node_high , int query_low , int query_high){ // first element <= data
        drop(node , node_low , node_high);
        if (node_low >= query_high || query_low >= node_high ||mn[node] >= data) return -1;
        if (node_high - node_low == 1) return  node_low;
        int mid = node_low + node_high >> 1;
        ll ans = first(data , 2* node +1 , node_low , mid , query_low , query_high);
        if (ans == -1) ans = first(data , 2* node +2 , mid , node_high , query_low , query_high);
        return ans;
    }
    ll first (int l , int r , int c){
        return first(c , 0 , 0 , n , l , r+1);
    }

    ll kill (int node , int node_low , int node_high , int query_low , int query_high , ll& s){
        drop(node , node_low , node_high);
        if (node_low >= query_high || query_low >= node_high ||mn[node] > s) return 0;
        if (node_low >= query_low && query_high >= node_high&& s >= sum[node]){
            s-=sum[node];
            return node_high - node_low;
        }
        int mid = node_low + node_high >> 1;
        ll ans = kill(2* node+1 , node_low , mid , query_low , query_high , s);
        ans+= kill(2* node+2 , mid , node_high , query_low , query_high , s);
        return ans;
    }


};


for (int k = 2; k < n; ++k){
int j = k-1;
for (int i = 0; i +1< k ; ++i) tree.upd(id(a[i] * a[j]) , 1);
for (int r = k+1; r < n; ++r){
ll p = x/ a[k] / a[r];
ll cnt = upper_bound(all(b) , p) -b.begin()-1;
ans+= tree.query(0 , cnt);

}
}
cout << ans << endl;


struct dsu{
    vector <int > par;
    vector <int > sz;
    int n ;
    void init(int _n){
        n = _n;
        sz = vector <int > (n+5 , 1);
        par = vector <int > (n+5);
        iota(all(par) , 0);
    }
    int findp( int node){
        if (node == par[node]) return node;
        return par[node] = findp(par[node]);
    }
    bool _union(int u , int v){
        u = findp(u);
        v = findp(v);
        if (u == v) return 0;
        if (sz[u] < sz[v]) swap(u , v);
        sz[u]+=sz[v];
        par[v] = u;
        return 1;

    };
};


mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
ll rand(ll l , ll r) {
    return uniform_int_distribution<ll>(l, r)(rng);
}


vector < vector <int > > g , at;
vector <int > heavy , par , dep ,root , tin , sz , inv;
int dfn;
int nn;
void init(){
    inv = sz = dep = tin = vector <int > (nn+5);
    g = at = vector <vector <int > > (nn+5);
    heavy = par = root= vector <int > (nn+5 , -1);
    dfn = 0;
}

struct ass{
    vector < vector <int > > tree; int n;
    void S (int _n){
        n = _n;
        while (popcount(n) != 1) ++n;
        tree = vector < vector <int > > (2 *n);
    }
    vector <int > merge(vector <int > & u , vector <int > & v){
        vector <int > ret;
        int l , r; l = r = 0;
        while ((int)ret.size() < 10){
            if (l >= (int)u.size() && r >= (int)v.size()) break;
            else if (l >= (int)u.size()) ret.emplace_back(v[r++]);
            else if (r >= (int)v.size()) ret.emplace_back(u[l++]);
            else if (u[l] < v[r]) ret.emplace_back(u[l++]);
            else ret.emplace_back(v[r++]);
        }
        return ret;
    }
    void build (int node , int node_low , int node_high){
        if (node_high - node_low == 1){
            if (node_low < nn) tree[node] = at[inv[node_low]];
            return ;
        }
        int mid = node_low + node_high >> 1;
        build(2 * node +1 , node_low , mid);
        build(2* node +2 , mid , node_high);
        tree[node] = merge(tree[2 * node +1] , tree[2* node +2]);
    }
    void build (){
        build(0  , 0 , n);
    }
    vector <int > query (int node , int node_low , int node_high , int query_low , int query_high){
        if (node_low >= query_high || query_low >= node_high) return {};
        if (node_low >= query_low && query_high >= node_high) return tree[node];
        int mid = node_low + node_high >> 1;
        vector <int > L = query(2 * node+1 , node_low , mid , query_low , query_high);
        vector <int > R = query(2* node+2 , mid , node_high , query_low , query_high);
        return merge(L , R);
    }
    vector <int > query(int l , int r){
        return query(0 , 0 , n , l , r+1);
    }
};

ass T;
void pre_dfs(int node){
    sz[node] = 1;
    root[node] = node;
    for (auto &ch : g[node]){
        if (ch == par[node]) continue;
        par[ch] = node;
        dep[ch] = 1 + dep[node];
        pre_dfs(ch);
        sz[node]+= sz[ch];
        if (heavy[node] == -1 || sz[ch] > sz[heavy[node]])
            heavy[node] = ch;
    }
}
void hld(int node){
    tin[node] = dfn;
    inv[dfn++] = node;
    /// cout << node << endl;
    if (heavy[node] != -1){
        root[heavy[node]] = root[node];
        hld(heavy[node]);
    }

    for (auto &ch : g[node]){
        if (ch == par[node] || heavy[node] == ch) continue;
        hld(ch);
    }
}

vector <int > ans(int u , int v){
    vector <int > ret;
    while (root[u] != root[v]){
        if (dep[root[u]] < dep[root[v]]) swap(u , v); // u lower
        vector <int > temp = T.query(tin[root[u]] , tin[u]);
        ret = T.merge(ret , temp);
        u = par[root[u]];
    }
    if (dep[u] < dep[v]) swap(u , v); // u lower

    vector<int > temp = T.query(tin[v] , tin[u]);
    ret = T.merge(ret , temp);
    return ret;

}
void hi(int tc){
    ll m , q; cin >>nn >> m >> q;
    init();
    for (int u , v , i = 1; i < nn; ++i){
        cin >> u >> v;
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }
    for (int u , i = 1; i <= m; ++i){
        cin >> u;
        at[u].emplace_back(i);
    }
    for (int i = 1; i <= nn; ++i) while ((int)at[i].size() > 10) at[i].pop_back();
    pre_dfs(1);hld(1); T.S(nn+5);
    T.build();
    for (int u , v , aa , i = 1; i <= q; ++i){
        cin >> u >> v >> aa;
        vector <int > out = ans(u , v);
        int mn = min(aa , (int)out.size());
        if (!mn) {cout << mn << nd;continue;}
        cout << mn << " ";
        for (int ii = 0; ii < mn; ++ii) cout << out[ii] <<" \n"[ii+1 == mn];
    }



}


struct ass{
    vector <ll > lazy , tree; int n;
    void S(int _n){
        n = _n;
        while(popcount(n) != 1) ++n;
        tree = lazy = vector <ll > (2 * n);
    }
    void relax (int node , int nl , int nr){
        if (!lazy[node]) return;
        tree[node]+= (nr - nl) * lazy[node];
        if (nr -nl -1)lazy[2* node +1] += lazy[node] ,lazy[2 * node +2]+= lazy[node];
        lazy[node] = 0;
    }
    void upd (int node , int nl, int nr , int ql , int qr , int data){
        relax(node , nl , nr);
        if (nl >= qr || ql >= nr) return;
        if (nl >= ql && qr >= nr){
            lazy[node] += data;relax(node , nl , nr); return;
        }
        int mid =nl + nr  >> 1;
        upd(2 * node +1 , nl , mid , ql , qr , data);
        upd(2 * node +2 , mid , nr , ql , qr , data);
        tree[node] = tree[2 * node +1] + tree[2* node +2];
    }
    void upd (int l , int r , int v){
        upd(0 , 0 , n , l , r+1 , v);
    }
    ll qu(int node , int nl , int nr , int ql , int qr){
        relax(node , nl , nr);
        if (nl >= qr || ql >= nr) return 0;
        if (nl >= ql && qr >= nr) return tree[node];
        int mid = nl + nr >> 1;
        ll ans = qu(2 * node +1 , nl , mid , ql , qr);
        ans+= qu(2 * node +2 , mid , nr , ql , qr);
        return ans;
    }
    ll qu (int l , int r){
        return qu(0 , 0 , n , l , r+1);
    }
};
struct BLR{
    vector <ll > B1 , B2; int n;
    void S(int _n){
        n = _n+10;
        B1 = B2 = vector <ll > (n+50);
    }
    ll qu(ll b){
        ll ans = 0;
        for (int i = b ; i; i-= i & -i) ans+= B1[i];
        ans = ans * b;
        for (int i = b; i; i-= i & -i) ans-=B2[i];
        return ans;
    }
    void upd(ll l , ll r , ll v){
        ++l; ++r;
        for (int i = l ; i <= n; i+= i & -i) B1[i]+=v;
        for (int i = l; i <= n; i+= i & -i) B2[i]+=(l-1) *v;
        for (int i = r+1; i <= n; i+= i & -i) B1[i]-=v;
        for (int i = r+1; i <= n; i+= i & -i) B2[i]-= v *r;
    }

    ll qu(int l , int r) {
        ++l , ++r;
        return qu(r) - qu(l-1);
    }
};


vector < vector <int > > g , d; int n;
vector <int > dep , heavy , par , sz , tin , root ,inv; int dfn;
void init(){
    d = g = vector < vector <int > > (n+5);
    par = heavy = root = vector <int > (n+5 , -1);
    inv = dep = sz = tin = vector <int > (n+5);
    dfn = 0;
}
void pre_dfs(int node){
    sz[node] = 1; root[node] = node;
    for (auto &ch : g[node]){
        par[ch] = node;
        dep[ch] = 1 + dep[node];
        pre_dfs(ch);
        if (heavy[node] == -1 || sz[heavy[node]] < sz[ch]) heavy[node] = ch;
        sz[node]+=sz[ch];
    }
    d[dep[node]].emplace_back(node);
}
void hld(int node){
    tin[node]  = dfn;
    inv[dfn++] = node;
    if (heavy[node] != -1) root[heavy[node]] = root[node] ,hld(heavy[node]);
    for (auto &ch : g[node]){
        if (ch == par[node] || ch ==heavy[node]) continue;
        hld(ch);
    }
}

struct BLR{
    vector <ll > B1 , B2; int n;
    void S(int _n){
        n = _n+10;
        B1 = B2 = vector <ll > (n+50);
    }
    ll qu(ll b){
        ll ans = 0;
        for (int i = b ; i; i-= i & -i) ans+= B1[i];
        ans = ans * b;
        for (int i = b; i; i-= i & -i) ans-=B2[i];
        return ans;
    }
    void upd(ll l , ll r , ll v){
        ++l; ++r;
        for (int i = l ; i <= n; i+= i & -i) B1[i]+=v;
        for (int i = l; i <= n; i+= i & -i) B2[i]+=(l-1) *v;
        for (int i = r+1; i <= n; i+= i & -i) B1[i]-=v;
        for (int i = r+1; i <= n; i+= i & -i) B2[i]-= v *r;
    }

    ll qu(int l , int r) {
        ++l , ++r;
        return qu(r) - qu(l-1);
    }
};
BLR T;



ll qu(int u , int v){
    ll ans = 0;
    while (root[u] != root[v]){
        if (dep[root[u]] < dep[root[v]]) swap(u , v); // u is lower
        ans+= T.qu(tin[root[u]] , tin[u]);
        u = par[root[u]];
    }
    if (dep[v] > dep[u]) swap(u , v);
    ans+= T.qu(tin[v] , tin[u]);
    return ans;
}
void upd(int u , int v , int val){
    while (root[u] != root[v]){
        if (dep[root[u]] < dep[root[v]]) swap(u , v); // u is lower
        T.upd(tin[root[u]] , tin[u] , val);
        u = par[root[u]];
    }
    if (dep[v] > dep[u]) swap(u , v);
    T.upd(tin[v] , tin[u] , val);
}
void hi(int tc){
    cin >> n;
    int rt = -1;
    init();
    for (int u , i = 1; i <= n; ++i){
        cin >> u;
        if (!u) rt = i;
        else g[u].emplace_back(i);
    }
    pre_dfs(rt); hld(rt);
    vector <ll > ans(n+5);
    T.S(n+5);
    for (int i = 1; !d[i].empty(); ++i){
        for (auto &u : d[i]) upd(rt , par[u] , 1);
        for (auto &u : d[i])ans[u] = ans[par[u]] + qu(rt , par[u]);
        for (auto &u : d[i])upd(rt , par[u] , -1);
    }
    for (int i = 1; i <= n; ++i) cout << ans[i] <<" \n"[i == n];


}



ll jump (int u , int v , int k){

    vector <pair<int , int > > uu , vv;
    int cnt = 0;
    while (root[u] != root[v]){
        if (dep[root[u]] < dep[root[v]]) {
            swap(u ,v);
            swap(uu , vv);
            cnt++;
        }
        uu.emplace_back(tin[root[u]] , tin[u]);
        u = par[root[u]];
    }
    if (dep[v] > dep[u]){
        cnt++;
        swap(u , v);
        swap(uu , vv);
        uu.emplace_back(tin[v] , tin[u]);
    }
    else uu.emplace_back(tin[v] , tin[u]);
    if (cnt & 1) swap(uu , vv);
    k-=1;
    for (auto &i : uu){
        if (k >= i.second-i.first+1){
            k-=i.second-i.first+1;
        }
        else return inv[i.second-k];
    }
    reverse(all(vv));
    for (auto &i : vv){
        // cout << k <<" "<<i.second<<" "<<i.first<<" "<<inv[i.first]<<" "<<inv[i.second]<< endl;
        if (k >= i.second-i.first+1){
            k-=i.second-i.first+1;
        }
        else return inv[i.first+k];
    }
    assert(0);
}



vector <ll> a;
void work(){
    vector<ll> c = a;
    sort(all(c));
    c.resize(unique(all(c))-c.begin());
    for (ll &i : a) i = lower_bound(all(c) , i)-c.begin();
}
vector < vector <int > > g , anc;
vector <int > cnt , tin , tout  , inv , dep , ans , seen;
int l , r , dfn , n , m;
void init(){
    g = vector < vector <int > > (n+5);
    anc = vector < vector <int > > (n+5 , vector <int > (LOG+1));
    dfn = 0;
    seen = ans = tin = tout = inv = cnt = dep = vector <int > (4*n+5);
    a = vector <ll > (n+5);
    l = 0; r = -1;
}
struct query{
    int lc , L , R , idx;
    bool operator < (const query & rhs) const {
        if (L/SQ == rhs.L/SQ) return R < rhs.R;
        return L < rhs.L;
    }
};
vector < query> q;
void dfs (int node , int p){
    dep[node]  = 1 + dep[p];
    anc[node][0] = p;
    for (int i = 1; i < LOG; ++i) anc[node][i] = anc[anc[node][i-1]][i-1];
    inv[++dfn] = node; // one based
    tin[node] = dfn;
    //   cout <<"OO "<< endl;
    for (auto &ch : g[node]){
        if (ch == p) continue;
        dfs(ch , node);
    }
    inv[++dfn] = node;
    tout[node] = dfn;
}
int kth (int node , int k){
    for (int i = LOG-1; ~i; --i) if (k & (1 << i)) node = anc[node][i];
    return node;
}
int lca (int u , int v){
    if (dep[v] > dep[u]) swap(u , v);
    u = kth(u , dep[u]- dep[v]);
    if (u == v) return u;
    for (int i = LOG-1; ~i ; --i) if (anc[u][i] != anc[v][i]) u = anc[u][i] , v = anc[v][i];
    assert(u ^v && anc[u][0] == anc[v][0]);
    return anc[u][0];
}
void hi(int tc){
    cin >> n >> m; init();
    for (int i = 1; i <= n; ++i) cin >> a[i];
    work();
    for (int u , v , i = 1; i < n; ++i){
        cin >> u >> v;
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }
    dfs(1 , 1);

    for (int u , v , i = 1 ; i <= m; ++i){
        cin >> u >> v;
        int lc = lca(u , v); q.emplace_back();
        auto &cp = q.back(); cp.lc = lc; cp.idx = i;
        if (tin[u] > tin[v]) swap(u , v);
        if (lc == u) cp.L = tin[u] , cp.R = tin[v];
        else cp.L = tout[u] , cp.R = tin[v];
    }
    sort(all(q));
    //   for (int i = 1; i <= n ; ++i){
    // cout << i <<" "<< tin[i] <<" "<< tout[i] <<" "<<a[i] << endl;
    // }
    l = 1 , r = 0;
    int tot = 0;

    auto add =[&](int t){
        int node = inv[t];
        if (++seen[node] & 1) tot+= (++cnt[a[node]] == 1);
        else tot-= (!--cnt[a[node]]);
    };

    auto del =[&](int t){
        int node = inv[t];
        if (++seen[node] & 1) tot+= (++cnt[a[node]] == 1);
        else tot-= (!--cnt[a[node]]);

    };

    for (auto &qr : q) {
        while (r < qr.R) add(++r);
        while (l > qr.L) add(--l);
        while (l < qr.L) del(l++);
        while (r > qr.R) del(r--);

        ans[qr.idx] = tot + (qr.lc != inv[qr.L] && !cnt[a[qr.lc]]);

        // cout << inv[qr.L] <<" "<< qr.L <<" "<< a[qr.lc]<<" "<< cnt[a[qr.lc]]<<" "<< qr.lc << endl;
    }

    for (int i = 1; i <= m; ++i) cout << ans[i] << nd;



}




struct RT {
    vector < vector < int > > anc , g;
    vector <int > val , par , id  , st  , en, dep ;
    int dfn  , n;
    void dfs (int node , int p ){
        st[node] = dfn+1;
        anc[node][0] = p;
        dep[node] = 1 + dep[p];
        for (int L = 1; L < LOG; ++L) anc[node][L] = anc[anc[node][L-1]][L-1];
        for (auto &ch : g[node]) dfs(ch , node);
        if (st[node] == dfn+1) id[++dfn] = node;
        en[node] = dfn;
    }
    int findp (int node){
        if (node == par[node]) return node;
        //cout << node << endl;
        return par[node] = findp(par[node]);
    }
    void build (vector < array<int , 3 > > & e){
        dfn = 0;
        n = (int) e.size()+1;
        anc = vector < vector <int > > (2 * n+5 , vector <int > (LOG+1));
        en = dep = st = par = val = id = vector <int > (2 * n+5);
        g = vector < vector <int > > (2 * n+5);
        sort(all(e)); iota(all(par) , 0);
        val[0] = 2e9;
        for (int i = 0; i +1 < n; ++i){
            int u = findp(e[i][1]) , v = findp(e[i][2]);
            int nu = n +i+1;
            par[u] = par[v] = nu;
            g[nu].emplace_back(u);
            g[nu].emplace_back(v);
            val[nu] = e[i][0];
        }
        dfs(2 * n -1 , 2 *n-1);
        assert(dfn == n);
    }

    int jump (int node , int mx){
        for (int i = LOG-1; ~i ; --i) if (val[anc[node][i]] <= mx)  node = anc[node][i];
        return node;
    }
    int kth (int u , int k){
        for (int i = 0; i < LOG; ++i) if (k & (1 << i)) u = anc[u][i];
        return u;
    }
    int lca (int u , int v){ // be care full path the nodes not the starting time
        if (dep[u] < dep[v]) swap(u , v);
        u = kth(u  , dep[u] - dep[v]);
        if (u == v) return u;
        for (int i = LOG -1; ~i ; --i) if (anc[u][i] ^ anc[v][i]) u = anc[u][i] , v = anc[v][i];
        assert(u ^ v && anc[u][0] == anc[v][0]);
        return anc[u][0];
    }
    int query(int u , int v){
        return val[lca(u , v)];
    }

};
struct dsu {
    vector <int > par , sz; int n;
    void init(int _n){
        n = _n +10;
        par = sz = vector <int > (n +10 , 1);
        iota(all(par) , 0);
    }
    int findp (int node){
        if (node == par[node]) return node;
        return par[node] = findp(par[node]);
    }
    bool _union(int u , int v){
        u = findp(u); v= findp(v);
        if (u == v) return 0;
        if (sz[v] > sz[u]) swap(u , v);
        par[v] = u;
        sz[u]+= sz[v];
        return 1;
    }
};
vector <int > a;
using Node = array<int , 2> ;
Node nu {int(2e9) , 0};
struct Tree{
    vector<Node> rT , vir; int n; // mn , mx
    vector <int > lazy;
    void S (int _n){
        n = _n;
        while (popcount(n) != 1) ++n;
        vir = rT = vector <Node> (2* n);
        lazy = vector <int > (2 *n , -1);
        build(0 , 0 , n);
    }
    Node merge (Node& u , Node& v){
        Node ans = nu;
        ans[0] = min(u[0] , v[0]);
        ans[1] = max(u[1] , v[1]);
        return ans;
    }
    void build (int node , int nl , int nr){
        rT[node] = nu;
        if (nr - nl == 1){
            //  cout << nl <<" "<< vir[node][0] <<" "<< vir[node][1] << endl;
            if (nl < (int)a.size())vir[node]= {a[nl] , a[nl]};
            return;
        }
        int mid = nl + nr >> 1;
        build(2 * node +1 , nl , mid);
        build(2 * node +2 , mid , nr);
        vir[node] = merge(vir[2* node+1] , vir[2* node +2]);
    }
    void drop (int node , int nl , int nr){ // 0 close // 1 open
        if (lazy[node] == -1) return;
        if (lazy[node] == 1) rT[node] = vir[node];
        else rT[node] = nu;
        if (nr - nl > 1) lazy[2 *node+1] = lazy[2 * node +2] = lazy[node];
        lazy[node] = -1;
    }
    Node query (int node , int nl , int nr , int ql , int qr){
        drop(node , nl , nr);
        if (nl >= qr || ql >= nr) return nu;
        if (nl >= ql && qr >= nr) return rT[node];
        int mid = nl + nr >> 1;
        Node L = query(2 * node +1 , nl , mid , ql , qr);
        Node R = query(2 * node +2 , mid , nr , ql ,qr);
        return merge(L , R);
    }
    Node query (int l , int r){
        return query(0 , 0 , n ,l , r+1);
    }
    void upd (int node , int nl , int nr  , int ql , int qr ,int op){
        drop(node , nl , nr);
        if (nl >= qr || ql >= nr) return ;
        if (nl >= ql && qr >= nr) {
            lazy[node] = op;
            drop(node , nl , nr);
            return;
        }
        int mid = nl + nr >> 1;
        upd(2* node +1 , nl , mid , ql , qr , op);
        upd(2 * node +2 , mid , nr , ql , qr , op);
        rT[node] = merge(rT[2 * node +1] , rT[2 * node +2]);
    }
    void upd (int l , int r , int op){
        upd(0 , 0 , n , l , r+1 , op);
    }

};


struct RT {
    vector < vector < int > > anc , g;
    vector <int > val , par , id  , st  , en, dep ;
    int dfn  , n;
    void dfs (int node , int p ){
        st[node] = dfn+1;
        anc[node][0] = p;
        dep[node] = 1 + dep[p];
        for (int L = 1; L < LOG; ++L) anc[node][L] = anc[anc[node][L-1]][L-1];
        for (auto &ch : g[node]) dfs(ch , node);
        if (st[node] == dfn+1) id[++dfn] = node;
        en[node] = dfn;
    }
    int findp (int node){
        if (node == par[node]) return node;
        //cout << node << endl;
        return par[node] = findp(par[node]);
    }
    void build (vector < array<int , 3 > > & e){
        dfn = 0;
        n = (int) e.size()+1;
        anc = vector < vector <int > > (2 * n+5 , vector <int > (LOG+1));
        en = dep = st = par = val = id = vector <int > (2 * n+5);
        g = vector < vector <int > > (2 * n+5);
        sort(all(e)); iota(all(par) , 0);
        val[0] = 2e9;
        for (int i = 0; i +1 < n; ++i){
            int u = findp(e[i][1]) , v = findp(e[i][2]);
            if (u == v) continue;
            int nu = n +i+1;
            par[u] = par[v] = nu;
            g[nu].emplace_back(u);
            g[nu].emplace_back(v);
            val[nu] = e[i][0];
        }
        dfs(2 * n -1 , 2 *n-1);
        assert(dfn == n);
    }

    int jump (int node , int mx){
        for (int i = LOG-1; ~i ; --i) if (val[anc[node][i]] <= mx)  node = anc[node][i];
        return node;
    }
    int kth (int u , int k){
        for (int i = 0; i < LOG; ++i) if (k & (1 << i)) u = anc[u][i];
        return u;
    }
    int lca (int u , int v){ // be care full path the nodes not the starting time
        if (dep[u] < dep[v]) swap(u , v);
        u = kth(u  , dep[u] - dep[v]);
        if (u == v) return u;
        for (int i = LOG -1; ~i ; --i) if (anc[u][i] ^ anc[v][i]) u = anc[u][i] , v = anc[v][i];
        assert(u ^ v && anc[u][0] == anc[v][0]);
        return anc[u][0];
    }
    int query(int u , int v){
        return val[lca(u , v)];
    }

};
vector <int > a;

void hi(int tc){
    ll n , qs , x; cin >> n;
    vector <array<int , 3 > > e(n-1);
    for (auto &i : e) cin >> i[1] >> i[2]>> i[0];
    RT rt;
    rt.build(e);
    a = vector <int > (n+1);
    for (int i = 1; i <= n; ++i) a[i] = rt.st[i];
    deque<array<ll , 2> > q;
    cin >> qs >> x;
    set < pair<pair<int , int > , int  > > st;
    st.insert({{1 , n} , 1});
    auto upd =[&](ll L , ll R , ll d)->ll{
        ll ans = 0;
        auto temp = st.lower_bound({{L , 0} , 0});
        if (temp != st.begin()){
            //lol;
            --temp;
            auto p = * temp;
            if (p.first.second >= L){
                //  py;
                st.erase(temp);
                st.insert({{p.first.first , L-1} , p.second});
                if (p.first.second <= R) ans+= (p.first.second - L +1) * (d >= p.second);
                else{
                    st.insert({{R+1 , p.first.second} ,p.second });
                    ans+= (R-L+1) * (d >= p.second);
                }
            }
        }
        while (!st.empty()){
            auto it = st.lower_bound({{L , 0} , 0});
            int nl = it->first.first; int nr = it->first.second;
            int D = it->second;
            if (it == st.end() || nl > R) break;
            st.erase(it);
            if (nr <= R) ans += (nr - nl + 1) * (d >= D);
            else{
                ans+= (R - nl +1) * (d >= D);
                st.insert({{R+1 , nr}, D});
            }
        }
        st.insert({{L , R} , d+x});
        return ans;
    };
    for (int d , u , k , i = 1; i <= qs; ++i){
        cin >> d >> u >> k;
        u = rt.jump(u , k);
        int L = rt.st[u]; int R = rt.en[u];
        ll ans = upd(L , R , d);
        cout << ans << nd;
    }


}



struct rT{ // count number of zeros in ranges L & R  and support updates
    vector < array<int  ,2 > > T;
    vector <int > lazy; int n;
    void S (int _n){
        n = _n;
        while (popcount(n) != 1) ++n;
        lazy = vector <int > (2 * n);
        T = vector < array<int , 2 > > (2 *n);
        build(0 , 0 , n);
    }
    array<int  , 2 > merge (array<int , 2 > & u , array<int  , 2 > & v){
        if (u[0] != v[0]) return min(u , v);
        return {u[0] , u[1] +v[1]};
    }
    void build (int node , int nl , int nr){
        T[node]= {0 , nr - nl};
        if (nr - nl == 1) return;
        int mid = nl + nr >> 1;
        build(2 * node +1 , nl , mid);
        build(2 * node +2 , mid , nr);
        T[node] = merge(T[2 * node+1] , T [2 * node +2]);
    }
    void drop (int node , int nl , int nr){
        T[node][0]+= lazy[node];
        if (nr - nl -1) lazy[2 * node+2]+= lazy[node] , lazy[2 * node +1]+= lazy[node];
        lazy[node] = 0;
    }
    void upd (int node , int nl , int nr , int ql , int qr , int val){
        drop(node , nl , nr);
        if (nl >= qr || ql >= nr) return;
        if (nl >= ql && qr >= nr){
            lazy[node]  = val;
            drop(node , nl , nr);
            return;
        }
        int mid = nl + nr >> 1;
        upd(2 * node +1 , nl , mid , ql , qr , val);
        upd(2 * node +2 , mid , nr , ql , qr , val);
        T[node] = merge(T[2 * node +1] , T[2 * node +2]);
    }
    void upd (int l , int r , int val){
        upd(0 , 0 , n , l , r+1 , val);
    }
    array<int  ,2 >  query(int node , int nl , int nr , int ql , int qr){
        drop(node , nl , nr);
        if (nl >= qr || ql >= nr) return {int(2e9) , 0};
        if (nl >= ql && qr >= nr) return T[node];
        int mid = nl + nr >> 1;
        auto L = query(2 * node +1 , nl , mid , ql , qr);
        auto R = query(2 * node +2 , mid , nr , ql , qr );
        return merge(L , R);
    }
    array <int  , 2 > query (int l , int r){
        return query(0 , 0 , n , l ,r+1);
    }

};

// https://ioi2018.jp/wp-content/tasks/contest1/werewolf.pdf
// Submit at https://contest.yandex.com/ioi/contest/8916/standings/


struct dsu{
    vector <ll > sz , par  , lazy , sub; int n;
    void init(int _n){
        n = _n+10;
        par = sz = vector <ll > (n, 1);
        iota(all(par) , 0);
        sub = lazy= vector <ll> (n);
    }
    int findp(int node){
        if (node == par[node]) return node;
        return findp(par[node]);
    }

    bool _union(int u , int v){
        u = findp(u); v = findp(v);
        if (u == v) return 0;
        if (sz[v] > sz[u]) swap(u , v);
        sub[v] = lazy[u];
        par[v] = u;
        sz[u]+=sz[v];
        return 1;
    }
    ll get (int u){
        if (par[u] == u) return lazy[u];
        ll ans = lazy[u] - sub[u];
        ans+= get(par[u]);
        return ans;
    }
};

struct fT{
    int dfn ;
    vector < vector <int > > anc , fake; int n , root , totSz;
    vector < vector <pair <int ,  int > > > g;
    vector <int > dep , tin , tout , sz , st , marked , nodes;
    vector <ll > sum;

    void init(int _n){
        dfn = 0; n = _n;
        anc = vector < vector <int > > (n+5 , vector <int > (LOG+1));
        fake = vector < vector <int > > (n+5);
        g = vector < vector <pair <int , int > > > (n+5);
        sum = vector <ll > (n+5);
        sz = marked = tin = tout = dep = vector <int > (n+5);
    }

    void dfs (int node , int p = 0){
        anc[node][0] = p;
        tin[node] = ++dfn;
        for (int L = 1 ; L < LOG; ++L) anc[node][L] = anc[anc[node][L-1]][L-1];
        for (auto &ch : g[node]) {
            if (ch.first ==p) continue;
            sum[ch.first] = sum[node] + ch.second ;
            dep[ch.first] = 1 + dep[node];
            dfs(ch.first  , node);
        }
        tout[node] = dfn;
    }

    int dist (int u , int v){
        return sum[u] + sum[v] - 2* sum[lca(u , v)] ;
    }

    bool is_anc(int u , int v){
        return tin[u] <= tin[v] && tout[u] >= tout[v];
    }

    int kth (int u , int k){
        for (int i = 0; i < LOG; ++i) if (k & (1 << i)) u = anc[u][i];
        return u;
    }
    int lca (int u , int v){
        if (dep[u] < dep[v]) swap(u , v);
        u = kth(u  , dep[u] - dep[v]);
        if (u == v) return u;
        for (int i = LOG -1; ~i ; --i) if (anc[u][i] ^ anc[v][i]) u = anc[u][i] , v = anc[v][i];
        assert(u ^ v && anc[u][0] == anc[v][0]);
        return anc[u][0];
    }

    void read(vector <int > a){
        totSz= (int)a.size();
        for (auto &i : nodes) sz[i] = marked[i] = 0 , fake[i].clear();
        nodes = a;
        sort(all(nodes) , [&] (int u , int v){return tin[u] < tin[v];});
        for (auto &i : nodes) marked[i]++;
        build();
    }
    void build (){
        for (int i= 1; i < totSz; ++i) nodes.emplace_back(lca(nodes[i] , nodes[i-1]));
        sort(all(nodes) , [&] (int u , int v){return tin[u] < tin[v];});
        nodes.resize(unique(all(nodes))- nodes.begin());
        st.emplace_back(nodes[0]);
        for (int i = 1; i <(int)nodes.size(); ++i){
            while ((int)st.size() > 1 && !is_anc(st.back() , nodes[i])){
                fake[st[(int)st.size()-2]].emplace_back(st.back());
                st.pop_back();
            }
            st.emplace_back(nodes[i]);
        }
        while ((int)st.size() > 1){
            fake[st[(int)st.size()-2]].emplace_back(st.back());
            st.pop_back();
        }
        assert(!st.empty());
        root = st.back();
        st.pop_back();
    }
    ll solve (int node , int p = 0){
        ll ans = 0;
        sz[node] = marked[node];
        for (auto &ch : fake[node]){
            if (ch == p)continue;
            ans+= solve(ch , node);
            sz[node]+= sz[ch];
        }
        if (p) ans+= (sum[node] - sum[p]) * sz[node] * 1ll*(totSz - sz[node]);
        // cout << node <<" "<< sum[node]<<" "<< sum[p] <<" "<<p <<" "<< ans <<" "<<sz[node]<< endl;
        return ans;
    }

};



//https://www.hackerrank.com/challenges/subtrees-and-paths/problem
//https://www.hackerrank.com/contests/world-codesprint-13/challenges/dynamic-trees
ll n , qs , dfn;
vector <int > st , en , dep , blo , par ,  inv , root , lazy;
vector < vector <int > > g , e;
vector <ll > a , mx , ans ;
void init(){
    dfn = 0;
    lazy = root = inv = par = st = en = dep = blo = vector <int > (n+5);
    e = g = vector < vector <int > > (n+5);
    ans = mx = a = vector <ll > (n+5);
}

void build(int node , int p = 1){
    par[node] = p;
    inv[st[node]= ++dfn] = node;
    blo[node] = st[node]/SQ;
    e[blo[node]].emplace_back(node);
    for (auto &ch : g[node]){
        if (ch == p) continue;
        build(ch , node);
    }
    en[node] = dfn;
    //cout << node <<" "<< st[node] <<" "<< en[node] << endl;
}

void dfs (int node){
    for (auto &ch : g[node]){
        root[ch] = root[node];
        dep[ch] = 1 + dep[node];
        ans[ch] = max(a[ch] , ans[node]);
        dfs(ch);
    }
}

void work (int B){
    for (auto & node : e[B]){
        if (par[node] == node|| blo[par[node]] != B)  {
            dep[node] = 0; root[node] = node; ans[node] = a[node];
            dfs(node);
        }
    }
}
void upd (int L , int R , int d){
    ll Bl = L/SQ;
    for (auto &node : e[Bl]) if (st[node] >= L && st[node] <= R) a[node]+= d;
    work(Bl);
    ll Br = R/SQ;
    if (Bl != Br){
        for (auto &node : e[Br]) if (st[node] >= L && st[node] <= R) a[node]+= d;
        work(Br);
    }
    for (int i = Bl+1 ; i < Br ; ++i) lazy[i]+=d;
}

ll query(int u , int v){
    ll ret = - inf * inf;
    while (root[u] != root[v]){
        if (st[u] < st[v]) swap(u , v);
        ret = max(ret , ans[u]+lazy[blo[u]]);
        u = par[root[u]];
    }
    int B = blo[u];
    while (u != v){
        if (dep[u] < dep[v]) swap(u , v);
        if (dep[u] == dep[v]){
            ret = max(ret , max(a[u] , a[v])+lazy[B]);
            u= par[u]; v = par[v];
        }
        else ret = max(ret , a[u]+lazy[B]) , u = par[u];
    }
    assert(u == v);
    ret = max(ret , a[u]+ lazy[B]);
    return ret;
}
void main_(int tc){
    cin >> n; init();
    for (int u , v , i = 1; i < n; ++i){
        cin >> u >> v;
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }
    build(1);
    assert(dfn == n);
    for (int i = 1; i <= n; ++i ) g[i].clear();
    for (int i = 2; i <= n; ++i) if (blo[i] == blo[par[i]]) g[par[i]].emplace_back(i);
    // process block
    for (int i = 0; i <= n; i+=SQ) work(i/SQ);
    cin >> qs;
    string s; int u , v;
    while (qs--){
        cin >> s >> u >> v;
        if (s[0] == 'a') upd(st[u] , en[u] , v);
        else {
            cout << query(u , v) << nd;
        }
    }

}
ll dp[1005][1005];
for (int i = 1; i <= 1000; ++i) dp[i][0] = 1;
dp[1][1] = 1;
for (int n = 2; n <= 1000; ++n)
for (int k = 1; k <= n; ++k )
dp[n][k] = add(dp[n-1][k] , dp[n-1][k-1]);

/*
 *
 * https://www.hackerrank.com/contests/world-codesprint-13/challenges/dynamic-trees
 *  https://www.codechef.com/problems/TRS
 *  https://atcoder.jp/contests/abc133/tasks/abc133_f
 *  https://codeforces.com/blog/entry/46843
 *  https://codeforces.com/blog/entry/68231
 *  https://www.codechef.com/problems/UPDTREE
 *  https://codeforces.com/contest/219/problem/D
 *  https://codeforces.com/contest/1187/problem/E
 *  https://www.codechef.com/problems/MXMN
 *  // https://codeforces.com/contest/1386/problem/C
 *  // https://codeforces.com/blog/entry/83467
 *   https://codeforces.com/contest/613/problem/D
 *   https://codeforces.com/contest/786/problem/B
 *   https://cses.fi/problemset/task/1136
 *   https://cses.fi/problemset/task/2080
 *   https://cses.fi/problemset/task/2081
 *   https://www.codechef.com/problems/BTREE?tab=statement // https://discuss.codechef.com/t/btree-editorial/7647
 *   https://www.codechef.com/problems/QUERY
 *   https://www.codechef.com/problems/OAK?tab=statement
 *   https://www.codechef.com/practice/tags/persistent-segment-trees
 *
 *  ///// done
 *  https://ioi2018.jp/wp-content/tasks/contest1/werewolf.pdf
 *  https://www.codechef.com/problems/TULIPS
 *  https://www.hackerrank.com/contests/worldcupsemifinals/challenges/wccity // 2 ways to solve
 *  https://www.hackerrank.com/challenges/subtrees-and-paths/problem
 *  https://cses.fi/problemset/task/1132
 *   https://cses.fi/problemset/task/1133
 *
 *
 */

vector < vector <int > > g , dist;
vector <int > sz , del , par , u , v , dep;
ll n , m , nodes , root ;

void init(){
    g = vector < vector <int > > (n+10);
    dep = sz = u= v = par = del = vector <int > (n+10);
    dist = vector < vector <int > > (LOG+1, vector <int > (n+10));
    root = n + 5;
}
void dfs_sz(int node , int p){
    sz[node] = 1; nodes++;
    for (auto &e : g[node]){
        int ch = node ^ u[e]  ^ v[e];
        if (ch== p || del[e]) continue;
        dfs_sz(ch , node);
        sz[node]+= sz[ch];
    }
}
int find_c(int node , int p){
    //cout <<"PPP "<< endl;
    for (auto &e : g[node]){
        int ch = node ^ u[e]  ^ v[e];
        if (ch == p || del[e]) continue;
        if (sz[ch] > nodes/ 2) return find_c(ch , node);
    }
    return node;
}

void add_edge(int p , int ch){
    par[ch] = p;
    dep[ch] = 1 + dep[p];
}
void dfs (int node , int p , int d){
    //cout <<"OOO "<< endl;
    for (auto &e : g[node]){
        int ch = u[e] ^ v[e] ^ node;
        if (del[e] || ch == p) continue;
        dist[d][ch] = 1 + dist[d][node];
        dfs(ch , node , d);
    }
}
void decompose(int node  , int rt = root){
    nodes = 0;
    dfs_sz(node , rt);
    int cent = find_c(node , node);
    add_edge(rt , cent);
    dfs(cent , cent , dep[cent]);

    for (auto &e : g[cent]){
        if (del[e]) continue;
        del[e] = 1;
        int nu = u[e] ^ v[e] ^ cent;
        decompose(nu , cent);
    }
}

int solve (int a , int b){
    int lc = dep[a];
    int _a = a; int _b = b;
    while (a != b){
        if (dep[b] > dep[a]) swap(a , b);
        a = par[a];
        lc = dep[a];
    }
    return dist[lc][_a] + dist[lc][_b];
}


vector < vector <int > > g;
vector <int > dep , par , sz , del , primes , lp , cnt;
ll n , root , nodes , sum;
void go (){
    for (ll i = 2; i <= 5e4; ++i){
        if (!lp[i]) lp[i] = i , primes.emplace_back(i);
        for (auto &p : primes){
            if (p * i > 5e4  || p > lp[i]) break;
            lp[p * i] = p;
        }
    }
}

void init(){
    root = n +5; sum = nodes = 0;
    g = vector < vector <int > > (n+10);
    del =  par = sz = dep = vector <int > (n+10);
    cnt = lp = vector <int > (int(6e4)); go();
    cnt[0] = 1;
}
void dfs_sz(int node , int p){
    sz[node] = 1; nodes++;
    for (auto &ch : g[node]){
        if (ch == p || del[ch]) continue;
        dfs_sz(ch , node);
        sz[node]+=sz[ch];
    }
}
int find_c (int node , int p){
    for (auto &ch : g[node]){
        if (ch == p || del[ch]) continue;
        if (sz[ch] > nodes / 2) return find_c(ch , node);
    }
    return node;
}

void upd(int node , int p , int val , int d = 1){
    cnt[d]+=val;
    for (auto &ch : g[node]){
        if (ch == p || del[ch]) continue;
        upd(ch , node , val , d+1);
    }
}

void get(int node , int p , int d = 1){
    for (auto &pr : primes) if (pr >= d) sum+=cnt[pr- d];
    for (auto &ch : g[node]){
        if (ch == p || del[ch]) continue;
        get(ch , node , d+1);
    }
}

void decompose(int node){
    nodes = 0;
    del[node] = 1;
    for (auto & ch :g[node]){
        if (del[ch]) continue;
        get(ch , ch);
        upd(ch , node , 1);
    }
    for (auto & ch :g[node]){
        if (del[ch]) continue;
        upd(ch , node , -1);
    }

    for (auto & ch :g[node]){
        if (del[ch]) continue;
        dfs_sz(ch , ch);
        int cent = find_c(ch , ch);
        decompose(cent);
    }

}

void centroid(int node){
    nodes = 0;
    dfs_sz(node , node);
    int cent = find_c(node , node);
    decompose(cent);

}



ll pw[N] , pw2[N] , inv[N] , inv2[N];
void init(){
    pw2[0] = inv2[0] = pw[0] = inv[0] = 1;
    ll Inv = modInv(P1 , mod);
    ll Inv2 = modInv(P2 , mod2);
    for (ll i = 1; i < N; ++i){
        pw[i] = mul(pw[i-1] , P1 , mod);
        inv[i] = mul(inv[i-1] , Inv , mod);
        pw2[i] = mul(pw2[i-1] , P2 , mod2);
        inv2[i] = mul(inv2[i-1] , Inv2 , mod2);
    }
}


struct Hash{
    int n; vector <array<ll,2 > > pre;
    void build(string & s){
        n = (int)s.size();
        pre = vector <array<ll,2 > > (n+5);
        pre[0][0] = pre[0][1]= s[0] - '0'+1;
        for (int i = 1; i < n; ++i){
            pre[i][0] = add(pre[i-1][0] , mul(s[i]-'0'+1 , pw[i] , mod) , mod);
            pre[i][1] = add(pre[i-1][1] , mul(s[i]-'0'+1 , pw2[i] , mod2) , mod2);
        }
    }
    array<ll , 2 > query(ll l , ll r){
        array<ll,2 > ans;
        ans[0] = add(pre[r][0] , (l ? -pre[l-1][0] : 0) , mod);
        ans[1] = add(pre[r][1] , (l ? - pre[l-1][1] : 0) , mod2);
        ans[0] = mul(ans[0] , inv[l] , mod);
        ans[1] = mul(ans[1] , inv2[l] , mod2);
        return ans;
    }

};


struct heavy_dsu{
    int n , version;
    vector <vector <array<int , 2 > > > sz , par;
    heavy_dsu(int _n){
        n = _n +5; version = 0;
        par = sz = vector < vector <array<int , 2 > > > (n+10);

        for (int i = 1; i <= n; ++i){
            sz[i].push_back({version , 1});
            par[i].push_back({version , i});
        }
    }

    int get_root(int u , int ver){
        int L = 0 , R = (int)par[u].size()-1;
        while (L <= R){
            int md = L + R >> 1;
            if (par[u][md][0] <= ver) L = md +1;
            else R = md -1;
        }

        if (par[u][R][1] == u) return par[u][R][1];
        return get_root(par[u][R][1] , ver);
    }

    int get_sz (int u , int ver){
        int L = 0 , R = (int)sz[u].size()-1;
        while (L <= R){
            int md = L + R >> 1;
            if (sz[u][md][0] <= ver) L = md +1;
            else R = md -1;
        }
        return sz[u][R][1];
    }

    int merge(int u , int v , int ver){
        u = get_root(u , ver); v = get_root(v , ver);
        if (u == v) return 0;
        int szu = sz[u].back()[1]; int szv = sz[v].back()[1];
        version = ver;
        if (szv > szu) swap(u , v);
        par[v].push_back({version , u});
        sz[u].push_back({version , szu+szv});
        return version;
    }

    bool same(int u , int v  , int ver){
        u = get_root(u , ver); v = get_root(v , ver);
        return u == v;
    }


};

/*
 * ll n;
vector < vector <int > > g;
vector <int > a , freq , ans;
set<array<ll , 2 > > hashes;
vector < array<ll, 2 > > dp;
void init(){
    g = vector < vector <int > > (n+10);
    freq = a = vector <int > (n+10);
    dp = vector < array<ll, 2 >  > (n+10);
}
void dfs(int node , int pa){
    array<ll, 2 > me ={0 , 0};
    for (auto &ch : g[node]){
        if (ch == pa) continue;
        dfs(ch , node);
        me = me + dp[ch];
        me[0] %= mod;
        me[1] %=mod2;
    }
    dp[node][0] = add(1 , mul(me[0] , B1 , mod) , mod);
    dp[node][1] = add(1 , mul(me[1] , B2 , mod2) , mod2);
}
void find_ans(int node , int p , array<ll, 2 > h){
    auto temp = dp[node];
    array<ll, 2 >  adds = {mul(h[0] , B1 , mod) , mul(h[1] , B2 , mod2)};
    temp = temp + adds;
    temp[0]%= mod;
    temp[1]%=mod2;
    if (hashes.find(temp) != hashes.end()) ans.emplace_back(node);

    for (auto &ch : g[node]){
        if (ch == p) continue;
        temp[0] = add(dp[node][0] , - dp[ch][0] * B1 , mod);
        temp[1] = add(dp[node][1] , - dp[ch][1] * B2 , mod2);
        array<ll, 2 > v;
        v[0]= mul(h[0] , B1 , mod);
        v[1] = mul(h[1] , B2 , mod2);
        auto s = v + temp;
        s[0]%= mod;s[1]%=mod2;
        find_ans(ch , node , s);
    }
}
void main_(int tc){
    cin >> n; init();
    for (int u , i = 1; i < n; ++i) cin >> a[i] ,freq[a[i]]++;
    for (int u , v , i = 1; i < n; ++i){
        cin >> u >> v;
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }

    array<ll, 2 > h = {0 , 0};
    for (int i = 0; i < n; ++i){
        h[0]+= mul(Fp(B1 , i , mod) , freq[i] , mod);
        h[1]+= mul(Fp(B2 , i , mod2) , freq[i] , mod2);
        h[0] %= mod; h[1] %=mod2;
    }
    for (int i = 0; i < n; ++i){
        auto temp = h;
        temp[0]+= Fp(B1 , i , mod);
        temp[1]+= Fp(B2 , i , mod2);
        temp[0]%=mod;
        temp[1]%=mod2;
        hashes.insert(temp);
    }
    dfs(1 , 1); find_ans(1 , 1 , {0 , 0});
    for (auto &i : ans) cout << i <<" ";



}

 */

struct myT{
    vector <ll > tree ; int parent ;
    void S (int n){
        parent = n;
        while (popcount(parent) != 1)++ parent;
        tree = vector <ll> (2 * parent , int(1e8));
    }
    void upd(int i , ll p , int node , int node_low , int node_high ){
        if (node_high- node_low == 1) {
            tree[node] = p;return;
        }
        int mid = node_low+ node_high >> 1;
        i <  mid  ?  upd(i , p  , 2*node+1 , node_low , mid ) : upd(i , p, 2* node+2 , mid  , node_high );
        tree[node] = min(tree[2* node+1] , tree[2* node+2]);
    }
    void upd(int i , ll v){
        return upd(i , v , 0 , 0 , parent);
    }
    ll query (int node , int node_low , int node_high  , int query_low , int query_high){
        if (node_low >= query_high || query_low >= node_high) return int(1e8);
        if (node_low >= query_low && query_high >= node_high) return tree[node];
        int mid = node_low + node_high >> 1;
        auto op1= query(2* node+1 , node_low , mid , query_low , query_high);
        auto op2 = query(2* node+2 , mid , node_high , query_low , query_high);
        return min(op1 , op2);
    }
    int query (int l , int r){
        return query(0 , 0 , parent , l , r+1);
    }
};

vector <ll > a; // 8 50
int sz;
struct ass{
    int n;
    vector <array<ll, 2 > > t; // sum ^ 2 //  sum
    vector <ll > lazy;
    void _s(int _n) {
        n = _n;
        while (popcount(n) != 1)++n;
        lazy = vector<ll>(2 * n);
        t = vector <array<ll, 2 > > (2 * n);
        build(0 , 0 , n);
    }
    array<ll, 2 > merge (array<ll, 2 > & u , array<ll, 2 > & v){
        array<ll, 2 > ans = {0 , 0};
        ans[1] = add(u[1]  , v[1] , mod);
        ans[0] = add(u[0] , v[0] , mod);
        return ans;
    }
    void build (int node , int nl , int nr){
        if (nr - nl == 1){
            if (nl < sz){
                t[node][1] = a[nl];
                t[node][0] = a[nl] * a[nl];
            }
            return;
        }
        int mid = nl + nr >> 1;
        build(2 * node +1 , nl , mid);
        build(2* node +2 , mid , nr);
        t[node] = merge(t[2* node +1] , t[2 * node +2]);
    }

    void drop (int node , int nl , int nr){
        if (!lazy[node]) return;
        ll nu = lazy[node];
        t[node][0] = add(t[node][0] ,  mul(t[node][1] , 2 * nu , mod) , mod);
        //cout <<"oo "<<t[node][0] <<" ";
        t[node][0] = add(t[node][0] , mul(nr-nl , mul(nu , nu , mod) , mod) , mod);
        // cout << t[node][0] << endl;
        t[node][1] = add(t[node][1] , mul(nr-nl , nu , mod) , mod);
        if (nr - nl -1) {lazy[2 *node +1] += nu , lazy[2* node +2] += nu; }
        lazy[node]= {};
    }

    void upd(int node , int nl , int nr , int ql , int qr , ll nu) {
        drop(node , nl , nr);
        if (nl >= qr || ql >= nr) return ;
        if (nl >= ql && qr >= nr){ // (a +b)^ 2 = a^ 2 + 2 * a * b + b ^ 2
            lazy[node] = nu;
            drop(node , nl , nr);
            //  cout << nl <<" "<< nr <<" "<< t[node][1] <<" "<< t[node][0] << endl;
            return;
        }
        int mid = nl + nr >> 1;
        upd(2 * node +1 , nl , mid , ql , qr , nu);
        upd(2 * node +2 , mid , nr , ql , qr , nu);
        t[node] = merge(t[2* node +1] , t[2* node +2]);
    }
    void upd(int l , int r , ll add){
        upd(0 , 0 , n , l , r+1 , add);
    }

    array<ll, 2 >  query (int node , int nl , int nr , int ql , int qr){
        drop(node , nl , nr);
        if (nl >= qr || ql >= nr) return {0 , 0};
        if (nl >= ql && qr >= nr) return t[node];
        int mid = nl + nr >> 1;
        auto L = query(2 * node +1 , nl , mid , ql , qr);
        auto R = query(2 * node +2 , mid , nr , ql , qr);
        return merge(L , R);
    }
    ll ask(ll l ,ll r){
        return query(0 , 0 , n , l , r+1)[0];
    }

};


///////////////////
int Log[N]; vector<int > a; int nn;
array<ll, 3 > nu = {-inf , inf , -inf}; // mx  , mn , ans
array<ll, 3 > table[N][LOG+1];
ll getMx(ll l , ll r){
    int L = Log[r-l+1];
    return max(table[l][L][0] , table[1+r- (1 << L)][L][0]);
}
ll getMn(ll l , ll r){
    int L = Log[r -l+1];
    return min(table[l][L][1] , table[1+r- (1 << L)][L][1]);
}
ll getBeauty(ll l , ll r){
    int L = Log[r - l+1];
    int sz = r - l +1;
    if (!(sz & (sz-1))) return table[l][L][2];
    return max({table[l][L][2] , table[1 + r -(1 << L)][L][2] ,
                getMx(l+(1<<L) , r) - getMn(l , r-(1<<L))});
}
struct T{
    int n;
    vector <array<ll, 3 > > t;
    vector <ll> lazy; //k
    void S(int _n){
        n = _n;
        while (popcount(n) != 1) ++n;
        t = vector <array<ll, 3 > > (2 * n , nu);
        lazy = vector <ll > (2 * n ,-1);
        build(0 , 0 , n);
    }
    array<ll, 3 > merge(array<ll, 3 > u  , array<ll, 3 > v){
        array<ll, 3 > ans = {max(u[0] , v[0]) , min(u[1] , v[1]) , 0};
        ans[2] = max({u[2] , v[2] , v[0] - u[1]});
        return ans;
    }
    void drop (int node , int nl , int nr){
        if (lazy[node] == -1) return;
        int kth = lazy[node];
        int L = nr - nl -1;
        int mid = nl + nr >> 1;
        t[node][0] = getMx(kth , kth+L);
        t[node][1] = getMn(kth , kth+L);
        t[node][2] = getBeauty(kth , kth+L);
        L = mid - nl ;
        if (nr - nl -1){ lazy[2 * node +1]  = kth; lazy[2 * node +2]  = kth+L; }
        lazy[node] = -1;
    }

    void build(int node , int nl , int nr){
        if (nr - nl == 1){
            if (nl < nn) t[node] = {a[nl] , a[nl] , 0} ;
            return;
        }
        int mid= nl + nr >> 1;
        build(2* node +1 , nl , mid);
        build(2* node +2 , mid , nr);
        t[node] = merge(t[2 * node +1] , t[2 * node +2]);
    }

    void upd(int node , int nl , int nr , int ql , int qr , int kth ){
        drop(node , nl , nr);
        if (ql >= nr || nl >= qr) return ;
        if (nl >= ql && qr >= nr){
            lazy[node] = (kth + nl - ql) % nn; drop(node , nl , nr) ;
            return;
        }
        int mid = nl + nr >> 1;
        upd(2 * node +1 , nl , mid , ql , qr , kth);
        upd(2 * node +2 , mid , nr , ql , qr , kth);
        t[node] = merge(t[2 * node +1] , t[2 * node +2]);
    }
    void upd (int l , int r , int k ){
        return upd(0 , 0 , n , l , r+1 , k);
    }
    array<ll, 3 > query(int node , int nl , int nr , int ql , int qr){
        drop(node , nl , nr);
        if (ql >= nr || nl >= qr) return nu;
        if (nl >= ql && qr >= nr) return t[node];
        int mid = nl + nr >> 1;
        auto op1 = query(2 * node +1 , nl , mid , ql , qr);
        auto op2 = query(2 * node +2 , mid , nr , ql , qr);
        return merge(op1 , op2);
    }
    ll ask(ll l , ll r){
        return query(0 , 0 , n , l , r+1)[2];
    }
};
void main_(int tc) {
    ll qs; cin >> nn >> qs;
    for (int i = 2; i < N;++i) Log[i] = 1 + Log[i >> 1];
    vector <int >b(nn);
    a = vector <int > (nn);
    for (auto &i : a) cin >> i;
    for (int i = 0; i < nn; ++i) {
        cin >> b[i];
        table[i][0] = table[i+nn][0] = {b[i] , b[i] , 0};
    }

    for (int j = 1; j < LOG; ++j){
        for (int i = 0; i + (1 << j) <=2 *nn; ++i){
            table[i][j][0] = max(table[i][j-1][0] , table[i+(1 << (j-1))][j-1][0]);
            table[i][j][1] = min(table[i][j-1][1] , table[i+(1 << (j-1))][j-1][1]);
            table[i][j][2] = max({table[i][j-1][2] , table[i+(1 << (j-1))][j-1][2]
                                         , table[i+(1 << (j-1))][j-1][0] - table[i][j-1][1]});
        }
    }

    T t; t.S(nn);

    for (int op , l , r , k , i = 1; i <= qs; ++i){
        cin >> op >> l >> r;
        if (op == 2) cout << t.ask(l , r) << nd;
        else{ cin >> k;
            t.upd(l , r , k);
            cout << t.ask(0 , nn-1) << nd;
        }
    }


}


struct dsu {
    int n ;
    vector <int > par , sz , dep ;
    void init(int _n){
        n = _n +10;
        par = sz = vector <int > (n +5 , 1);
        dep = vector <int > (n+5);
        iota(all(par) , 0);
    }
    int findp (int node){
        if (node == par[node]) return node;
        return par[node] = findp(par[node]);
    }
    int get_root(int node){
        if (node == par[node]){
            dep[node] = 0;
            return node;
        }
        int root = get_root(par[node]);
        dep[node]+= dep[par[node]];
        return par[node] = root;
    }
    bool _union(int u , int v){
        u = findp(u); v= findp(v);
        if (u == v) return 0;
        if (sz[u] < sz[v]) swap(u , v);
        par[v] = u;
        sz[u]+= sz[v];
        return 1;
    }
    bool work(int u , int v){
        u = get_root(u); v = get_root(v);
        if (u == v) return 0;
        dep[v] =1;
        par[v] = u;
        return 1;
    }
};

struct dsu{
    int n , count ;
    vector <int > sz , par;
    vector <pair<int & , int  > > st;
    void init(int _n) {
        count = _n;
        n = _n + 10;
        sz = par = vector<int>(n + 5, 1); iota(all(par), 0);
    }
    int findp(int node){
        if (node == par[node]) return node;
        return findp(par[node]);
    }
    bool _union(int u , int v){
        u = findp(u) , v = findp(v);
        if (u == v) return 0;
        if (sz[u] < sz[v]) swap(u , v);
        st.emplace_back(par[v] , par[v]); st.emplace_back(sz[u] , sz[u]);
        par[v] = u; count-=1;
        sz[u]+=sz[v];
        return 1;
    }
    int current(){
        return (int)st.size();
    }
    void undo(int need){
        while ((int)st.size() > need){
            count+=1;
            for (int i = 0; i < 2; ++i){
                assert(!st.empty());
                st.back().first = st.back().second;
                st.pop_back();
            }
        }
    }
};




void main_(int tc){
    ll n , k; cin >> n >> k;
    vector <ll > a(n) , b(n);
    for (ll &i : a) cin >> i;
    for (ll &i : b) cin >> i;
    vector<ll>cost(n+5) , dist(n+5) , pre(2 * n+1);

    for (int i = 0; i < 2 * n ; ++i) pre[i+1] = pre[i] + a[i % n];

    int cnt = 0;
    for (int i = 2 * n -1; i >= 0; --i){
        if (i < n){
            if (b[i] == 2 || (b[i] == 1 && !cnt)){
                dist[i] = 1;
                cost[i] = b[i] * a[i];
            }
            else {
                assert(b[i] == 1 && cnt);
                int L = i , R = i + cnt;
                int ans = i + cnt+1; // one to the lenght of the segment
                while (L <= R){
                    ll md = L + R >> 1;
                    if (pre[md]-pre[i] >= k) R = (ans = md) -1;
                    else L = md +1;
                }
                assert(ans > i);
                dist[i] = ans - i;
                if (pre[ans] - pre[i] <= k) cost[i] = pre[ans] - pre[i];
                else cost[i] = 2 * (pre[ans] - pre[i]) - k;

            }
        }
        if (b[i % n] == 2) cnt+=1;
        else cnt = 0;
    }

    vector < vector <ll > > jump_d , jump_c;
    jump_c = jump_d = vector < vector <ll > > (n+5 , vector <ll > (LOG+1));

    for (int i = 0; i < n; ++i) jump_d[i][0] = dist[i] , jump_c[i][0] = cost[i];

    for (int L = 1; L < LOG; ++L){
        for (int i = 0; i < n; ++i){
            jump_d[i][L] = jump_d[i][L-1] + jump_d[(i+ jump_d[i][L-1]) % n][L-1];
            jump_c[i][L] = jump_c[i][L-1] + jump_c[(i+ jump_d[i][L-1]) % n][L-1];
        }
    }

    for (int i = 0; i < n; ++i){
        int pos = i;
        int tot = 0;
        ll ans = 0;
        for (int L = LOG-1; ~L ; -- L){
            if (tot+jump_d[pos][L] <= n){
                ans+= jump_c[pos][L];
                tot+=jump_d[pos][L];
                pos = (pos + jump_d[pos][L]) % n;
            }
        }
        if (tot < n){
            assert(pre[i+n] - pre[i + tot] <= k);
            ans+= (pre[i + n] - pre[i + tot]) * b[(i+tot) % n];
        }
        cout << ans <<" \n"[i == n-1];
    }


}


const int k = 21;
const array<int, 4> rotateDelta = { 3, 0, 0, 1 };
ll plz(int x, int y, int pow, int rotate) {
    if (pow == 0) {
        return 0;
    }
    int hpow = 1 << (pow - 1);
    int seg = (x < hpow) ? ((y < hpow) ? 0 : 3) : ((y < hpow) ? 1 : 2);
    seg = (seg + rotate) & 3;
    int nx = x & (x ^ hpow), ny = y & (y ^ hpow);
    int nrot = (rotate + rotateDelta[seg]) & 3;
    ll subSquareSize = 1ll << (2 * pow - 2);
    ll ans = seg * subSquareSize;
    ll add = plz(nx, ny, pow - 1, nrot);
    ans += (seg == 1 || seg == 2) ? add : (subSquareSize - add - 1);
    return ans;
}
ll order(int x, int y){
    return plz(x, y, k, 0);
}



vector<vector<array<int , 2 > >  > t; // u , v  , connected
int temp ;
vector <int > ans;
dsu ds;

void upd(int node , int nl , int nr , int ql , int qr , array<int , 2 > d){
    if (nl >= qr || ql >= nr) return;
    if (nl >= ql && qr >= nr) {
        t[node].push_back(d);
        return;
    }
    int mid = nl + nr >> 1;
    upd(2* node +1 , nl , mid , ql , qr , d);
    upd(2* node +2 , mid , nr , ql , qr , d);
}

void get(int node = 0 , int nl = 0 , int nr = temp){
    int cur = ds.current();
    for (auto &v : t[node]) ds._union(v[0] , v[1]);
    if (nr - nl == 1) ans[nl] = ds.count;
    else {
        int mid = nl + nr >> 1;
        get(2 * node + 1, nl, mid);
        get(2 * node + 2, mid, nr);
    }
    ds.undo(cur);
}
int n , qs;
void init(){
    ds.init(n);
    temp = qs;
    while (popcount(temp) != 1) temp+=1;
    t = vector < vector <array<int , 2 > > > (2 * temp);
    ans = vector <int > (temp);
}
void main_(int tc){
    char c; cin >> n >> qs; init();
    map<array<int , 2 >  , int > mp;
    vector <int > ask;
    auto go =[&](int L , int R , array<int , 2 > d) {
        return  upd(0 , 0 , temp , L , R , d);
    };
    array<int , 2 > u;
    for (int i = 0; i < qs; ++i){
        cin >> c;
        if (c == '?') ask.emplace_back(i);
        else if (c == '+'){
            cin >> u[0] >> u[1]; if (u[0] > u[1]) swap(u[0] , u[1]);
            mp[u] =i;
        }
        else {
            cin >> u[0] >> u[1]; if (u[0] > u[1]) swap(u[0] , u[1]);
            assert(mp.count(u)); go(mp[u] , i , u);
            mp.erase(mp.find(u));

        }
    }
    for (auto &i : mp) go(i.second , qs , i.first);
    get();
    for (auto &i : ask) cout << ans[i] << nd;

}


const int M = 2e5+100;
vector<int > primes;
int lp[N] , P[N] , d[N] , pre[N] , inp[N] , a[M] , cnt[N];
vector<array<int , 2 > > allP[N];
void init(){
    pre[0] = inp[0] =  1;
    for (ll i = 2; i <= 1e6; ++i){
        if (!lp[i]) {
            lp[i] = i ; primes.emplace_back(i);
            P[i] = add(1 , -modInv(i , mod) , mod) ;  // 1 - 1 / p
            d[i] = modInv(P[i], mod) ;
        }
        for (auto &p : primes){
            if (p > lp[i] || i * p > 1e6) break;
            lp[i *p] = p;
        }
    }
}


const int k = 21;
const array<int, 4> rotateDelta = { 3, 0, 0, 1 };
ll plz(int x, int y, int pow, int rotate) { // use LL
    if (!pow) return 0;
    int hpow = 1 << (pow - 1);
    int seg = (x < hpow) ? ((y < hpow) ? 0 : 3) : ((y < hpow) ? 1 : 2);
    seg = (seg + rotate) & 3;
    int nx = x & (x ^ hpow), ny = y & (y ^ hpow);
    int nrot = (rotate + rotateDelta[seg]) & 3;
    ll subSquareSize = 1ll << (2 * pow - 2);
    ll ans = seg * subSquareSize;
    ll add = plz(nx, ny, pow - 1, nrot);
    ans += (seg == 1 || seg == 2) ? add : (subSquareSize - add - 1);
    return ans;
}
ll order(int x, int y){
    return plz(x, y, k, 0);
}


vector<array<int , 2 > > factorize(ll n){
    vector<array<int , 2 > > ans;
    while (n > 1){
        if (ans.empty() || ans.back()[0] != lp[n]) ans.push_back({lp[n] , 1});
        else ans.back()[1]+=1;
        n/=lp[n];
    }
    return ans;
}
int n , qs , ans[M];
void main_(int tc){
    cin >> n; init();
    for (int i = 1; i <= n; ++i){
        cin >> a[i];
        pre[i] = mul(pre[i-1] , a[i] , mod);
        if (allP[a[i]].empty()) allP[a[i]] = factorize(a[i]);
    }
    inp[n] = modInv(pre[n] , mod);
    for (int i = n-1; i ; --i) inp[i] = mul(inp[i+1] , a[i+1] , mod);
    cin >> qs;
    struct query{
        ll L , R , idx , LOL;
        void read(int _idx){
            cin >> L >> R;
            idx = _idx; LOL = order(L , R);
        }
        bool operator < (const query & rhs ) const{
            return LOL < rhs. LOL;
        }
    };
    vector<query > q; q.reserve(qs+10);
    for (int i = 1; i <= qs ; ++i){
        q.emplace_back();
        auto &b = q.back();
        b.read(i);
    }
    sort(all(q));
    int L = 1 , R = 0;
    ll times = 1;
    auto aa =[&](array<int , 2 > p){
        if (!cnt[p[0]]) times = mul(times , P[p[0]] , mod);
        cnt[p[0]]+=p[1];
    };
    auto rr = [&](array<int , 2 > p){
        cnt[p[0]]-=p[1];
        if (!cnt[p[0]]) times = mul(times , d[p[0]] , mod);
    };
    auto add =[&](int idx){ for (auto &p : allP[a[idx]]) aa(p);
    };

    auto del =[&] (int idx){ for (auto &p : allP[a[idx]]) rr(p);
    };
    for (auto & qr : q){
        while (R < qr.R) add(++R);
        while (L > qr.L) add(--L);
        while (R > qr.R) del(R--);
        while (L < qr.L) del(L++);
        ans[qr.idx] = mul(pre[qr.R] , inp[qr.L-1] , mod);
        ans[qr.idx] = mul(ans[qr.idx] , times , mod);
    }
    for (int i = 1; i <= qs; ++i) cout << ans[i] << nd;



}


int sz[N] , par[N] , id[N] , a[N];
map <int , int > d;

void init(){
    for (int i = 1; i <= 1e6; i+=1){
        par[i] = i;
        sz[i] = 1;
    }
}

int findp(int u){
    if (u == par[u]) return u;
    return par[u] = findp(par[u]);
}

bool _union(int u , int v){
    u = findp(u) , v = findp(v);
    if (u == v) return 0;
    if (sz[u] < sz[v]) swap(u , v);
    sz[u]+=sz[v]; par[v] = u;
    return 1;
}


void add (int i , int h){
    auto it = d.find(h);
    if (it != d.end()){
        _union(i , it->second);
        it->second = findp(i);
        a[it->second] = h;
    }
    else a[i] = h , d[h] = i;
}
void work(int L , int R , int w){
    auto it = d.lower_bound(L);
    while (it != d.end() && it->first <= R){
        add(it->second , w);
        it = d.erase(it);
    }
}
int n , qs;
void main_(int tc){
    cin >> n; init();
    for (int i = 1; i <= n; ++i){
        cin >> a[i]; id[i] = i;
        add(i , a[i]);
    }
    cin >> qs;
    for (int op ,L  ,R , i = 1; i <= qs; i++){
        cin >> op >> L;
        if (op == 2){ cout << a[findp(id[L])] << nd; continue; }
        cin >> R;
        if (op == 1) add(id[L] = ++n , R);
        else{
            assert(op == 3);
            int mid = L + R >> 1;
            work(L , mid , L-1);
            work(mid+1 , R , R+1);
        }

    }


}


ll pw[N] , pw2[N] , inv[N] , inv2[N];
void init(){
    pw2[0] = inv2[0] = pw[0] = inv[0] = 1;
    ll Inv = modInv(P1 , mod);
    ll Inv2 = modInv(P2 , mod2);
    for (ll i = 1; i < N; ++i){
        pw[i] = mul(pw[i-1] , P1 , mod);
        inv[i] = mul(inv[i-1] , Inv , mod);
        pw2[i] = mul(pw2[i-1] , P2 , mod2);
        inv2[i] = mul(inv2[i-1] , Inv2 , mod2);
    }
}


struct Hash{
    int n;
    vector <array<ll,2 > > pre;
    void build(string & s){
        n = (int)s.size(); pre.reserve(n+7);
        pre = vector <array<ll,2 > > (n+5);
        pre[0][0] = pre[0][1]= s[0] - 'a'+1;
        for (int i = 1; i < n; ++i){
            pre[i][0] = add(pre[i-1][0] , mul(s[i]-'a'+1 , pw[i] , mod) , mod);
            pre[i][1] = add(pre[i-1][1] , mul(s[i]-'a'+1 , pw2[i] , mod2) , mod2);
        }
    }
    array<ll , 2 > query(ll l , ll r){
        array<ll,2 > ans;
        ans[0] = add(pre[r][0] , (l ? -pre[l-1][0] : 0) , mod);
        ans[1] = add(pre[r][1] , (l ? - pre[l-1][1] : 0) , mod2);
        ans[0] = mul(ans[0] , inv[l] , mod);
        ans[1] = mul(ans[1] , inv2[l] , mod2);
        return ans;
    }

};


int phi[N] , np[N];
void init(){
    np[1] = phi[1] =  1;
    for (int i = 1; i < N ; ++i) phi[i] = i;
    for (int i = 2; i < N; ++i)
        if (!np[i]) for (int j = i; j < N; j+=i) np[j] = 1 , phi[j]-=phi[j]/i;

}
struct ds{
    ll L , R , data;
    ds(){ L = R = data = 0;}
    ds(ll _L , ll _R , ll _v){ L = _L; R = _R; data = _v; }
    bool operator < (const ds & rhs) const{
        return L < rhs.L;
    }
    void print(){
        cout << L <<" "<< R <<" "<< data << endl;
    }
};
set<ds> st;
struct dragon{
    int n;
    vector <ll > lazy;
    vector<array<ll, 3 > > t; // sum  , mx , mn
    void init(int _n){
        n = _n;
        while (popcount(n) != 1)++n;
        t = vector <array<ll, 3 >  > (2 *n);
        lazy = vector <ll > (2 * n , -1);
    }
    void drop (int node , int nl , int nr){
        if (lazy[node] == -1) return;
        t[node][0] = lazy[node] *  (nr - nl);
        t[node][1] = t[node][2] = lazy[node];
        if (nr - nl -1){ lazy[2 * node +1] = lazy[2 * node +2] = lazy[node];}
        lazy[node] = -1;
    }

    array <ll, 3 > merge(array<ll, 3 >  v , array<ll, 3 >  u){
        array<ll, 3 > ans;
        ans[0] = u[0] + v[0];
        ans[1] = max(u[1] , v[1]);
        ans[2] = min(u[2] , v[2]);
        return ans;
    }
    void upd (int node , int nl , int nr , int ql , int qr ,int v){
        drop(node , nl , nr);
        if (nl >= qr || ql >= nr) return;
        if (nl >= ql && qr >= nr){
            lazy[node] = v;
            drop(node , nl , nr);
            return;
        }
        int mid = nl + nr >> 1;
        upd(2 * node +1 , nl , mid , ql , qr , v);
        upd(2 * node +2 , mid , nr , ql , qr , v);
        t[node] = merge(t[2 * node +1] , t[2 * node +2]);
    }
    void upd (int l , int r , int v){
        upd(0 , 0 , n , l , r+1 , v);
    }
    array<ll, 3 >  query (int node , int nl , int nr , int ql , int qr){
        drop(node , nl , nr);
        if (nl >= qr || ql >= nr ) return {0 , 0 , inf};
        if (nl >= ql && qr >= nr) return t[node];
        int mid = nl + nr >> 1;
        auto L= query(2 * node +1 , nl , mid , ql , qr);
        auto R = query(2 * node + 2 , mid , nr , ql , qr);
        return merge(L , R);
    }
    array<ll, 3 >  query (int l , int r){
        return query(0 , 0 , n , l , r+1);
    };
};
void main_(int tc){
    int n , qs; cin >>n>>qs;
    vector <ll > a(n);
    for (int i = 0; i <n; ++i) cin >> a[i];
    int lastL = -1;
    for (int i = 0; i <n; ++i){
        if (i&& a[i] != a[i-1]){
            st.insert({lastL+1 , i-1 , a[i-1]});
            lastL = i-1;
        }
    } st.insert({lastL+1 , n-1 , a[n-1]});

    dragon t; t.init(n+5);
    for (auto ch : st) t.upd(ch.L , ch.R , ch.data);
    auto solve = [&](int L , int R , int v){
        auto itl = st.lower_bound({L , -1 , -1});
        vector<ds > upd;
        if (itl != st.begin()){
            itl--;
            auto cc = *itl;
            if (cc.R >= L){
                st.erase(itl);
                st.insert({cc.L, L - 1, cc.data});
                if (R >= cc.R) upd.push_back({L, cc.R, cc.data});
                else{
                    st.insert({R+1 , cc.R , cc.data});
                    upd.push_back({L , R , cc.data});
                }
            }
        }
        while (!st.empty()){
            itl = st.lower_bound({L , -1 , -1});
            auto cc = *itl;
            if (itl == st.end() || cc.L > R) break;
            if (R >= cc.R){ upd.push_back(cc);st.erase(itl);}
            else{ st.erase(itl); st.insert({R+1 , cc.R , cc.data}); upd.push_back({cc.L , R , cc.data}); }
        }
        if (v) st.insert({L , R , v});
        for (auto &cur : upd) t.upd(cur.L , cur.R, v ? v : phi[cur.data]);
        // << v <<" iii :" << L <<" "<< R << endl;
    };


    auto work = [&] (int L , int R){
        solve(L , R , 0);
        while (L <= R){
            auto have = t.query(L , L);
            // cout << L <<" "<< R <<" "<< have[0] <<" "<<have[1] <<" "<<have[2] << endl;
            assert(have[0] == have[1] && have[1] == have[2]);
            int last = t.get(L , R , have[0]);
            //  cout << last << endl;
            if (last == -1){
                st.insert({L , R , have[0]});
                L = R +1;
            }
            else{
                st.insert({L , last-1 , have[0]});
                L = last;
            }
        }

    };

    for (int op , l , r , i = 1; i <= qs; ++i){
        cin >>op >> l >> r; l-=1; r-=1;
        if (op == 3) cout << t.query(l , r)[0] << nd;
        else if (op == 2) cin >> op , solve(l , r , op);
        else work(l , r);
        //  cout << i <<" "; pp;
        //  for (auto ch : st) ch.print();
    }


}


struct Hash{
    int n;
    vector<array<int, 2 > > h , suf;
    void build(string & s){
        n = (int)s.size();
        suf = h = vector <array<int, 2 > > (n+5 , {0 , 0});
        h[0][0] = h[0][1] = s[0] -'a' +1;
        for (int i = 1; i < n; ++i) {
            h[i][0] = add(h[i - 1][0], mul(s[i] - 'a' + 1, pw[i], mod), mod);
            h[i][1] = add(h[i - 1][1], mul(s[i] - 'a' + 1, pw2[i], mod2), mod2);
        }
        suf[n-1][0] = suf[n-1][1] = s[n-1]-'a'+1;
        for (int i = n-2; i >= 0; --i){
            int p = n -i-1;
            suf[i][0] = add(suf[i+1][0] , mul(s[i]-'a'+1 , pw[p] , mod) , mod);
            suf[i][1] = add(suf[i+1][1] , mul(s[i]-'a'+1 , pw2[p] , mod2) , mod2);
        }
    }
    array<int, 2 > query(int L , int R){
        array<int, 2 > ans = h[R];
        ans[0] = add(ans[0] , (L ? -h[L-1][0] : 0) , mod);
        ans[1] = add(ans[1] , (L ? -h[L-1][1] : 0) , mod2);
        ans[0] = mul(ans[0] , inv[L] , mod);
        ans[1] = mul(ans[1] , inv2[L] , mod2);
        return ans;
    }

    array<int , 2 > get_suf (int L , int R){
        array<int , 2 > ans = suf[L];
        int p = n - R -1;
        ans[0] = add(ans[0] , -suf[R+1][0] , mod);
        ans[1] = add(ans[1] , -suf[R+1][1]  , mod2);
        ans[0] = mul(ans[0] , inv[p] , mod);
        ans[1] = mul(ans[1] , inv2[p] , mod2);
        return ans;
    }

};


int n , dfn;
vector <int > a , sz , st , en , inv;
vector < vector <int > > g;
vector <ll > ans;
void init(){
    inv = st = en = sz = a = vector <int > (n+5);
    g = vector < vector <int > > (n+5);
    ans = vector <ll > (n+5);
}
void dfs_sz(int node , int p = -1){
    inv[st[node] = ++dfn] = node;
    sz[node] = 1; for (auto &ch : g[node]) if (ch != p)dfs_sz(ch , node) , sz[node]+=sz[ch];
    en[node] = dfn;
}
ll cnt[N] , sum[N];

struct ass{
    ll ans , mx;
    void init(){ans = mx = 0; }

    void add(int v){
        cnt[v]++;
        sum[cnt[v]]+=v;
        if (cnt[v] > mx) mx = cnt[v];
        ans= sum[mx];
    }

    void del(int v){
        sum[cnt[v]]-=v;
        cnt[v]-=1;
        if (!sum[mx]) mx-=1;
        ans = sum[mx];
    }
};
ass ds;

void dfs(int node , int p = -1 , bool keep = 0){
    int heavy = -1;
    for (auto &ch : g[node])
        if (ch != p && (heavy == -1 || sz[ch] > sz[heavy]))
            heavy = ch;

    for (auto & ch : g[node])
        if (ch != p && ch != heavy)
            dfs(ch , node , 0);

    if (heavy != -1) dfs(heavy , node , 1);
    ds.add(a[node]);
    for (auto &ch : g[node]) if (ch != p && ch != heavy) for (int L = st[ch] ; L <= en[ch]; ++L) ds.add(a[inv[L]]);
    ans[node] = ds.ans;
    if (!keep)
        for (int L = st[node] ; L <= en[node]; ++L) ds.del(a[inv[L]]);

}


vector<array<int , 5> > a;
struct ass{
    int n;
    vector < array<int , 2 > > t;
    void init(int _n){
        n = _n;
        while (popcount(n) != 1) ++n;
        t = vector < array<int , 2 > > (2 *n);
    }
    void upd (int node , int nl , int nr , int idx , array<int , 2 > d){
        if (nr - nl == 1){ t[node] = max(t[node] , d);return; }
        int mid = nl + nr >> 1;
        if (idx < mid)upd(2 * node +1 , nl , mid , idx , d);
        else upd(2 * node +2 , mid , nr , idx , d);
        t[node] = max(t[2 * node +1] , t[2 * node +2]);
    }

    void upd (int idx , array<int , 2 > v){
        upd(0 , 0 , n , idx , v);
    }

    array<int , 2 > query(int node , int nl , int nr , int ql , int qr){
        if (nl >= qr || ql >= nr) return {0 , 0};
        if (nl >= ql && qr >= nr) return t[node];
        int mid = nl + nr >> 1;
        auto L = query(2 * node +1 , nl , mid , ql , qr);
        auto R = query(2* node +2 , mid , nr , ql  , qr);
        return max(L , R);
    }

    array<int , 2 > query(int l , int r){
        return query(0 , 0 , n , l , r+1);
    }

    int find(int node , int nl , int nr , int ql , int qr , int R){
        if (nl >= qr || ql >= nr || R > t[node][0]) return -1;
        if (nr - nl == 1) return t[node][1];
        int mid= nl + nr >> 1;
        int ans = find(2 * node +1 , nl , mid , ql , qr , R);
        if (ans == -1) ans = find(2 * node +2 , mid , nr , ql , qr , R);
        return ans;
    }
    int find(int l , int r , int v){
        return find(0 , 0 , n ,l , r+1 ,  v);
    }
};
void main_(int tc){
    int n , m; cin >> n >> m; a.reserve(n+m+5);
    map<int , int > mp; int c = 0;
    for (int i = 0; i < n + m; ++i){ a.emplace_back();
        auto &b = a.back();
        cin >> b[0] >> b[1] >> b[2];
        if (i < n) b[4] = 1 , b[3] = i+1;
        else b[4] = 2 , b[3] = i - n +1;
        mp[b[2]];
    }
    for (auto &x : mp) x.second = ++c; for (auto &i : a) i[2] = mp[i[2]];
    vector <int > ans(m+5 , -1);
    int sz = (int)mp.size();
    ass t; t.init(sz+5);

    sort(all(a) , [&](array<int , 5> & x , array<int , 5 > & y){
        if (x[0] == y[0]) return x[4] < y[4];
        return x[0] < y[0];
    });


    for (auto &i : a){ // l , r , v , idx , tp
        if (i[4] == 1) t.upd(i[2] , {i[1] , i[3]});
        else ans[i[3]] = t.find(i[2] , sz , i[1]);
    }
    for (int i = 1; i <= m; ++i) cout << ans[i] <<" ";

}


struct ass{
    priority_queue< array<int , 2 >  > in , out;
    bool empty(){
        while (!out.empty() && out.top() == in.top()) out.pop() , in.pop();
        return in.empty();
    }
    array<int , 2 >  top (){
        bool b = empty();assert(!b);
        return in.top();
    }
    void emplace(array<int , 2 >  v) {in.emplace(v);}
    void pop(array<int , 2 >  v){out.emplace(v);}
};
ass blo[N/SQ];
ass my[N];
vector <int > s , f , t , l , r , b;
int n , m;
void init(){
    s = f = t = vector <int > (n);
    l = r = b = vector <int > (m);
}
void main_(int tc){
    cin >> n >> m; init();
    map<int , int > mp; int c = 0;
    for (int i= 0; i < n; ++i) cin >> s[i] >> f[i] >> t[i], mp[f[i]];
    for (int i = 0; i < m; ++i) cin >> l[i] >> r[i] >> b[i] , mp[r[i]];
    for (auto &x : mp) x.second = ++c;
    for (int i = 0; i <n; ++i) f[i] = mp[f[i]];
    for (int i = 0; i < m; ++i) r[i] = mp[r[i]];

    vector <int >it(n);iota(all(it) , 0); sort(all(it) , [&](int x , int y){ return t[x] < t[y]; });
    vector <int > ib(m); iota(all(ib) , 0); sort(all(ib) , [&](int x , int y){ return b[x] < b[y];});

    vector <int > ans(m , -1);
    int L = 0;
    for (int i = 0; i < n; ++i){
        int R = L;
        while (R < m && t[it[i]] >= b[ib[R]]){
            int idx = ib[R];
            blo[r[idx]/ SQ].emplace({l[idx] , idx});
            my[r[idx]].emplace({l[idx] , idx});
            R+=1;
        }
        int idx = it[i];
        int last = f[idx];

        for (int v = 0; v <= last;){
            if (v % SQ == 0 && v + SQ-1 <= last){
                int B = v/ SQ;
                while (!blo[B].empty()){
                    auto temp = blo[B].top();
                    if (s[idx] > temp[0]) break;
                    ans[temp[1]] = idx+1;
                    blo[B].pop(temp);
                    my[r[temp[1]]].pop(temp);
                }
                v+=SQ;
            }
            else{
                while (!my[v].empty()){
                    auto temp = my[v].top();
                    if (s[idx] > temp[0]) break;
                    ans[temp[1]] = idx+1;
                    my[v].pop(temp);
                    blo[v/ SQ].pop(temp);
                }
                v+=1;
            }
        }

        L = R;
    }
    print(ans);

}


bool dfs(int node , int p , int fa){
    seen[node] = 1;
    bool found = binary_search(all(g[fa]) , node);
    if (found && p != fa) { cycle.emplace_back(fa); return 1; }

    for (auto &ch: g[node]){
        if (seen[ch] == -1)
            if (dfs(ch , node , fa)) {
                cycle.emplace_back(ch);
                return 1;
            }
    }
    return 0;
}

int n , m;
vector <int > g[N] , e[N] , q[N];
int deg[N] , in_deg[N] , inDeg[N] , b[N] , ans[N] , mn[N];

void run(){
    deque <int > q;
    for (int node = 1; node <= n; ++node){
        inDeg[node] = deg[node]; mn[node] = b[node];
        if (!inDeg[node])
            q.emplace_back(node) ;
    }
    assert(!q.empty());
    while (!q.empty()){
        int node = q.front(); q.pop_front();
        for (auto &anc : g[node]){
            mn[anc] = min(mn[anc] , mn[node]-1);
            if (!--inDeg[anc])
                q.emplace_back(anc);
        }
    }


}
bool check(){
    run();
    for (int node = 1; node <= n; ++ node){
        inDeg[node] = in_deg[node];
        if (!inDeg[node])
            q[mn[node]].emplace_back(node);
    }
    int place = 1;
    for (int v = 0; v <= n; ++v){
        while (!q[v].empty()){
            int node = q[v].back();q[v].pop_back();
            ans[node] = place++;
            for (auto &ch : e[node])
                if (!--inDeg[ch])
                    q[mn[ch]].emplace_back(ch);
        }
    }
    for (int i = 1; i <= n; ++i)
        if (ans[i] > b[i]) return 0;
    return 1;
}
void main_(int tc){
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> b[i];
    for (int u , v , i = 1; i <= m; ++i){
        cin >> u >> v;
        deg[u]++; g[v].emplace_back(u);
        in_deg[v]++; e[u].emplace_back(v);
    }


    for (int node = 1; node <= n; ++ node){
        int temp = b[node];

        int L = 1 , R = temp , res = temp;
        while (L <= R){
            int md = L + R >> 1;
            b[node] = md;
            if (check()) R = (res = md)-1;
            else L = md +1;
        }
        cout << res << " ";

        b[node] = temp;
    }



}
///https://docs.google.com/document/d/16p_rcE-bYOG_ZwBh7LqaCXZjdYqbJo_SCnEHa_au-Y4/edit?fbclid=IwAR1XXwWmhKiBsO3eEsuJVknoLBz4spGWNsLGo6Mg8FQTHrxutLhCzsCJ-OQ
// Kosarajus algorithm
struct ass{
    int n , mood;
    vector < array<ll, 2 > > t;
    array<ll, 2 > merge(array<ll, 2 > u , array<ll, 2 > v){
        return mood ? max(u , v) : min(u , v);
    }
    void init(int _n , int tp){
        mood= tp; n = _n;
        while (popcount(n) != 1) ++n;
        t  = vector < array<ll, 2 > > (2 *n , del());
    }
    array<ll, 2 > del(){
        array<ll, 2 > x = {0 , 0};
        array<ll, 2 > y = {inf , inf};
        return mood ? x : y;
    }
    void upd(int node , int nl , int nr , int p , array<ll, 2 > d){
        if (nl +1 == nr){
            t[node] = d; return;
        }
        int mid = nl + nr >> 1;
        if (p < mid) upd(2 * node +1 , nl , mid , p , d);
        else upd(2 * node +2 , mid , nr , p , d);
        t[node] = merge(t[2 * node +1] , t[2 * node +2]);
    }
    void upd(int p , array<ll, 2 > d){
        return upd(0 , 0 , n , p , d);
    }
    array<ll, 2 > query(int node , int nl , int nr , int ql , int qr){
        if (nl >= qr || ql >= nr) return del();
        if (nl >= ql && qr >= nr) return t[node];
        int mid = nl + nr >> 1;
        auto L = query(2 * node +1 , nl , mid , ql , qr);
        auto R = query(2 * node +2 , mid , nr , ql , qr);
        return merge(L , R);
    }

    array<ll, 2 > query(int L , int R){
        return query(0 , 0 , n , L , R+1);
    }
};
int n , T , sz;
vector < vector <int > > a;
vector < bool > done , inStack;
ass t[3]; // 01 // 02 // 12
vector <int > lo , st , dfn , comp , order;
void init(){
    inStack = done  = vector < bool > (n+5);
    a = vector < vector <int > > (n+5 , vector < int > (3));
    for (int i = 0; i < 3; ++i) t[i].init(n+5 , 1);
    lo = dfn = comp = vector <int > (n+5 , -1);
}


int fromLtoR(int u){
    auto p1 = t[0].query(a[u][0]+1 , n+1);// 01
    auto p2 = t[1].query(a[u][0]+1 , n+1); // 0 2
    auto p3 = t[2].query(a[u][1]+1 , n+1);// 1 2
    if (p1[0] > a[u][1]) return p1[1];
    if (p2[0] > a[u][2]) return p2[1];
    if (p3[0] > a[u][2]) return p3[1];

    return -1;
}
void dfs_F(int node){
    t[0].upd(a[node][0] , t[0].del()) ;
    t[1].upd(a[node][0] , t[1].del());
    t[2].upd(a[node][1] , t[2].del());
    done[node] = 1;
    int nx = -1;
    while ((nx = fromLtoR(node)) != -1){
        dfs_F(nx);
    }
    order.push_back(node);
}

int fromRtoL (int u){
    auto p1 = t[0].query(0 , a[u][0]-1); //0 1
    auto p2 = t[1].query(0 , a[u][0]-1); // 0 2
    auto p3 = t[2].query(0 , a[u][1]-1); // 1 2
    if (p1[0] < a[u][1]) return p1[1];
    if (p2[0] < a[u][2]) return p2[1];
    if (p3[0] < a[u][2]) return p3[1];
    return -1;
}

struct dsu{
    int n;
    vector <int > par , sz;
    void init(int _n){
        n = _n+5;
        sz = par = vector <int > (n+5, 1);
        iota(all(par) , 0);
    }
    int findp(int u){
        if (par[u] == u) return u;
        return par[u] = findp(par[u]);
    }
    bool _union(int u , int v){
        u = findp(u) , v = findp(v);
        if (u == v) return 0;
        if (sz[v] > sz[u]) swap(u , v);
        par[v] = u;
        sz[u]+=sz[v];
        return 1;
    }
}; dsu ds;
void dfsB(int node){
    t[0].upd(a[node][0] , t[0].del()) ;
    t[1].upd(a[node][0] , t[1].del());
    t[2].upd(a[node][1] , t[2].del());
    done[node] = 1;
    int nx = -1;
    while ((nx = fromRtoL(node)) != -1){
        ds._union(nx , node);
        dfsB(nx);
    }
}


void main_(int tc) {
    cin >> n; init(); ds.init(n+5);
    for (int i = 1; i <= n; ++i){
        for (int x = 0; x < 3; ++x) cin >> a[i][x];
        t[0].upd(a[i][0] , {a[i][1] , i}); //0 1
        t[1].upd(a[i][0] , {a[i][2] , i}); //0 2
        t[2].upd(a[i][1] , {a[i][2] , i});// 1 2
    }

    for (int node = 1; node <= n; ++ node)
        if (!done[node]) dfs_F(node);

    for (int i = 0; i < 3; ++i) t[i].init(n+5 , 0);
    done = vector <bool > (n+5);
    for (int i = 1; i <= n; ++i){
        t[0].upd(a[i][0] , {a[i][1] , i}); //0 1
        t[1].upd(a[i][0] , {a[i][2] , i}); //0 2
        t[2].upd(a[i][1] , {a[i][2] , i});// 1 2
    }
    reverse(all(order));
    for (auto & node : order)
        if (!done[node]) dfsB(node);

    map<int , vector <int > > p;
    for (int node = 1; node <= n; ++ node)
        p[ds.findp(node)].emplace_back(node);

    for (auto &x : p){
        cout << x.first <<" ii "<< endl;
        print(x.second);
        pp;
    }


    int qs; cin >> qs;
    for (int u  , v , i = 1; i <= qs; ++i){
        cin >> u >> v;
        int c = 0;
        for (int x = 0; x < 3; ++x) c+= (a[u][x] < a[v][x]);
        if (c > 1 || ds.findp(u) == ds.findp(v) ) py
        else pn
    }

}



ll mul(ll a, ll b, ll M) {
    ll ret = a * b - M * ll(1.L / M * a * b);
    return ret + M * (ret < 0) - M * (ret >= (ll)M);
}
ll Fp(ll b, ll e, ll mod) {
    ll ans = 1;
    for (; e; b = mul(b, b, mod), e /= 2)
        if (e & 1) ans = mul(ans, b, mod);
    return ans;
}

bool isPrime(ll n) {
    if (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;
    ll A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},
            s = __builtin_ctzll(n-1), d = n >> s;
    for (ll a : A) {   // ^ count trailing zeroes
        ll p = Fp(a%n, d, n), i = s;
        while (p != 1 && p != n - 1 && a % n && i--)
            p = mul(p, p, n);
        if (p != n-1 && i != s) return 0;
    }
    return 1;
}

ll pollard(ll n) {
    auto f = [n](ull x) { return mul(x, x, n) + 1; };
    ll x = 0, y = 0, t = 30, prd = 2, i = 1, q;
    while (t++ % 40 || __gcd(prd, n) == 1) {
        if (x == y) x = ++i, y = f(x);
        if ((q = mul(prd, max(x,y) - min(x,y), n))) prd = q;
        x = f(x), y = f(f(y));
    }
    return __gcd(prd, n);
}

vector<ll> factor(ll n) {
    if (n == 1) return {};
    if (isPrime(n)) return {n};
    ull x = pollard(n);
    auto l = factor(x), r = factor(n / x);
    l.insert(l.end(), all(r));
    return l;
}



int par[N] , sz[N] , lastL;
int a[3][int(5e5+10)];
int n , m , p , ans;
vector < pair<int & , int  > > st;
vector <int > t;
void init(){
    n = 3;
    for (int i = 0; i < 2e7-500; ++i) par[i] = i , sz[i] = 1;
    p = m;
    while (popcount(p) != 1) ++p;
    t = vector <int > (2 *p);
}

int h(int d, int i , int j){ // depth , row , col
    return d * n * m + i * m +j;
}
int findp(int u){
    if (u == par[u]) return u;
    return findp(par[u]);
}
bool work(int u , int v , bool save = 0){
    u = findp(u) , v = findp(v);
    if (u == v) return 0;
    if (sz[v] > sz[u]) swap(u , v);
    if (save) st.emplace_back(par[v] , par[v]) , st.emplace_back(sz[u] , sz[u]);
    sz[u]+=sz[v] , par[v] = u;
    return 1;
}
void rollback(){
    while (!st.empty()){
        st.back().first = st.back().second;
        st.pop_back();
    }
}
void build(int dep , int node , int nl , int nr){
    if (nl +1 == nr){
        for (int r = 0; r < 3; ++r) {
            for (int c = nl; c < nr; ++c){
                t[node]+=a[r][c];
                if (r && a[r][c] && a[r-1][c]) t[node]-= work(h(dep , r-1 , c) , h(dep , r , c));
                if (c > nl && a[r][c-1] && a[r][c]) t[node]-= work(h(dep , r , c-1) , h(dep , r , c));
            }
        }
        return;
    }
    int mid = nl + nr >> 1;
    build(dep+1 , 2 * node +1 , nl , mid);
    build(dep+1 , 2 * node +2 , mid , nr);
    for (int r = 0; r < 3; ++r) {
        for (int c = nl; c < nr; ++c){
            t[node]+=a[r][c];
            if (r && a[r][c] && a[r-1][c]) t[node]-= work(h(dep , r-1 , c) , h(dep , r , c));
            if (c > nl && a[r][c-1] && a[r][c]) t[node]-= work(h(dep , r , c-1) , h(dep , r , c));
        }
    }
    //  pp;
    //cout << nl <<" "<< nr <<" "<< dep <<" "<<t[node]<< endl;
}

int query(int d , int node , int nl , int nr , int ql , int qr){
    if (nl >= qr || ql >= nr) return 0;
    if (nl >= ql && qr >= nr){
        if (lastL >= 0) {
            for (int r = 0; r < 3; ++r)
                if (a[r][nl - 1] && a[r][nl]) ans += work(h(lastL, r, nl - 1), h(d, r, nl), 1);
        }
        lastL = d;
        return t[node];
    }

    int mid = nl + nr >> 1;
    int cc = query(d+1 , 2 * node +1 , nl , mid , ql , qr);
    cc += query(d+1 , 2 * node +2 , mid , nr , ql , qr);
    return cc;
}


ll gcd(ll r0 , ll r1){
    while (r1){
        ll nxt = r0 % r1;
        r0 = r1;
        r1= nxt;
    }
    return r0;
}


ll ecuild(ll a , ll b , ll &x0 , ll & y0){
    auto nxt =[&](ll &x , ll &y , ll q){
        ll next = x - q * y;
        x = y;
        y = next;
    };
    ll r0 , r1 , x1 , y1;
    r0 = a , r1 = b ;
    x0 = y1 = 1 ;
    y0 = x1 = 0;
    while (r1){
        ll q = r0 / r1;
        nxt(r0 , r1 , q);
        nxt(x0 , x1 , q);
        nxt(y0 , y1 , q);
    }
    return r0;
}


ll de(ll a , ll b , ll c , ll &x0 , ll &y0){
    ll g = ecuild(abs(a) , abs(b) , x0 , y0);
    if (c % g) return -1;
    x0*= c/g;
    y0*= c/g;
    a >= 0 ? x0*=1 : x0*=-1;
    b >= 0 ? y0*=1 : y0*=-1;
    return g;
}

ll modInv(ll n , ll m){ ll c , no;
    ll g = ecuild(n , m , c , no);
    if (g != 1) return -1;
    /* 11 -- > mod //  -4 %11 = -4 but it mst be 7
   n = bq +r // -4 = 0 *11 -4
   but another solution is // -4 = -1*11 +7
    */
    return (c  % m + m ) % m;
}
vector <ll > solve_congruence(ll a , ll b , ll m){ // a x = b % m
    ll x , y;
    ll g = de(a , m , b , x , y);
    vector <ll > ans;
    if (g == -1) return ans;
    x = (x % m + m ) % m;
    for (ll k = 0; k < min(10ll , g ); ++k){
        ll nu = x + k * m / g;
        nu = (nu % m + m) % m;
        ans.push_back(nu);
    }
    sort(all(ans));
    return ans;
}

/*  the system is solvable if and only if
 *  case 1) all mods are pairwise gcd
 *  case 2) every ai is congruent to aj mod gcd(ni , nj)
 */
ll solve_relative_primes(vector <ll > & mods , vector <ll > & rems){ // if and only if all mods are pairwise gcd
    ll lc = 1;
    for (auto &c : mods) lc*= c;
    ll x = 0;
    for (int i = 0; i < (int)mods.size(); ++i) x+= lc/ mods[i] * rems[i] * modInv(lc/ mods[i] , mods[i]);
    return x % lc;
}

ll solve(vector <ll > & mods , vector <ll > & rems){ // every ai is congruent to aj mod gcd(ai , agj) // nasted
    ll rem = rems[0]; ll Mod = mods[0];
    // T is congruent to x Mod n which means T % n is equal to x % n
    // T is congruent to y mod m
    // T = k * n + x // T = p * m + y
    // k * n + x = p * m + y
    // k * n - p * m = y - x
    for (int i = 1; i < (int)mods.size(); ++i){
        ll x , y , a  = Mod , b = -mods[i] , c = rems[i] - rem;
        ll g = de(a , b , c , x , y); if (g == -1 || rem % g != rems[i] % g) return -1;
        assert(x * a + b * y == c);
        rem+= x * Mod;
        Mod = Mod / g * mods[i];  // new mod is the lcm
        rem = (rem % Mod + Mod) % Mod;
    }
    return rem;

}
void main_(int tc) {
    ll n; cin >> n;
    vector <ll > a(n);
    for (ll &i : a) cin >> i , cnt[i]+=1;
    sort(all(a));
    a.resize(unique(all(a))-a.begin());
    n = (int)a.size();
    ll power = 1;
    ll m1 = (mod-1) / 2;
    for (int i = 0; i < n; ++i) power = mul(power , cnt[a[i]]+1 , m1);


    // check product
    int idx = -1 , c = 0;
    for (int i = 0; i < n; ++i) if (cnt[a[i]] & 1) idx = i , c++;
    ll out = 1;
    for (int i = 0; i < n; ++i){
        ll x = mul(power , modInv(cnt[a[i]]+1 , m1) , m1) , rem = 0;
        // ans is congruent to x mod m1
        // ans is congrunet to rem mod 2
        if (!c || (c == 1 && idx == i)) rem = 1;

        vector <ll > mods = {m1 , 2};
        vector<ll > rems ={x , rem};
        ll ans = solve_relative_primes(mods , rems);
        assert(ans == solve(mods , rems));
        ll p = mul(ans , cnt[a[i]] * 1ll *(cnt[a[i]] +1) / 2 , mod-1);
        out = mul(out , Fp(a[i] , p , mod) , mod);
    }
    cout << out << nd;


}

// a ( x0 + k * b/g ) + b (y0 - k * a/g ) = n
pair<int , array<ll, 2 > > get_range(ll a , ll b ){
    ll x0 , y0;
    ll g = de(a , b , n, x0 , y0);
    if (g == -1) return {0 , {-1 , -1}};
    // mn 0 , mx = n
    a/=g , b/=g;
    // mnx - x0 <= k * b <= mxx-x0
    ll lx = ceil(-x0/1.0 / b);
    ll rx = floor((n-x0) *1.0 / b);
    // -mny +y0 >=  k * a >= -mxy +y0
    ll ly = ceil((y0 -n) *1.0 / a);
    ll ry = floor(y0 *1.0/a); // u must use floor cuz of negative integers
    ll L = max(lx , ly);
    ll R = min(rx , ry);
    if (L > R) return {0 , {-1 , -1}};
    return {1 , {L , R}};
}

vector <int > a7a( pair<array<int , 2>  , vector <array<int , 3 > > > input ){
    int n , m; cin >> n >> m;
    vector < array<ll,3 > > p;
    for (int idx , L , R , i = 1; i <= m; ++i){
        cin  >> idx >> L >> R;
        p.push_back({L , -1 , idx});
        p.push_back({R , 1 , idx});
    }
    for (int i = 1; i <= n; ++i) dp[i] = -1 , edges[i].clear() , cnt[i] = 0;
    sort(all(p));
    set<int > st;
    for (auto &temp : p){
        int L  , R; L = R = -1;
        int idx = temp[2];
        auto it = st.lower_bound(idx);
        if (it != st.end() && *it == idx){
            auto nx = next(it);
            if (nx != st.end()) R = *nx;
            if (it != st.begin()) L = *prev(it);
        }
        else{
            if (it != st.begin()) L = *prev(it);
            if (it != st.end()) R = *it;
        }


        if (temp[1] == -1) {
            if (cnt[idx]++ == 0) {
                st.insert(idx);
                if (L != -1) edges[L].emplace_back(idx);
                if (R != -1) edges[idx].emplace_back(R);
            }
        }
        else{
            if (--cnt[idx] == 0) {
                st.erase(idx);
                //  if (L != -1) edges[L].emplace_back(idx);
                //if (R != -1) edges[idx].emplace_back(R);
                if (L != -1 && R != -1) edges[L].emplace_back(R);
            }
        }

    }

    int head = p.front()[2];
    int mx = dfs(head);
    for (int node = 1; node <= n; ++ node) if (dfs(head) < dfs(node)) head = node;
    vector <bool > deleted(n+5 , true);
    while (dp[head] > 1){
        deleted[head] = false;
        for (auto &ch : edges[head]){
            if (dp[ch] +1 == dp[head]){
                head = ch; break;
            }
        }
    }
    deleted[head] = false;
    vector <int > ans;
    for (int node = 1; node <= n; ++ node) if (deleted[node]) ans.emplace_back(node);
    return ans;
}


ll phi(ll n){
    ll ans = n;
    for (ll i = 2; i * i <= n; ++i){
        if (n % i == 0){
            ans-=ans/i;
            while (n % i == 0) n/=i;
        }
    }
    if (n > 1) ans-=ans/n;
    return ans;
}
ll dp[60][60][60];

ll solve(ll n , ll k , ll m){
    if (k > n) return dp[n][k][m] = 0;
    if (!k|| k == n) return dp[n][k][m] = 1;
    if (dp[n][k][m] != -1) return dp[n][k][m];
    ll ch1 = solve(n-1 , k-1 , m);
    ll ch2 = solve(n-1 , k , m);
    return dp[n][k][m] = add(ch1 , ch2 , m);
}

bool is(ll n){
    for (ll i = 2; i * i <= n; ++i) if (n % i == 0) return 0;
    return 1;
}
ll locus(ll n , ll k , ll m){
    ll ans = 1;
    while (n && k){
        ll dn = n % m;
        ll dk = k % m;
        ans = mul(ans , solve(dn , dk , m) , m);
        n/=m; k/=m;
    }
    return ans;
}

ll ecuild(ll a , ll b , ll &x0 , ll & y0){
    auto nxt = [&](ll &x , ll &y , ll q){
        ll next = x - q * y;
        x = y;
        y = next;
    };
    ll r0 , r1 , x1 , y1;
    r0 = a , r1 = b;
    x0 = y1 = 1;
    y0 = x1 = 0;
    while (r1){
        ll q = r0 / r1;
        nxt(r0 , r1 , q);
        nxt(x0 , x1 , q);
        nxt(y0 , y1 , q);
    }
    return r0;
}

ll ecuildInv(ll n , ll m){ ll c , no;
    ll g = ecuild(n , m , c , no);
    if (g != 1) return -1;
    return (c % m + m) % m;
}
ll Inv(ll a , ll m){
    return Fp(a , phi(m)-1 , m);
}
ll solve_relative_primes(vector <ll >& mods , vector <ll > & rems){
    ll lc = 1;
    for (auto &x : mods) lc *= x;
    ll x = 0;
    for (int i = 0; i < (int)mods.size(); ++i)
        x+= lc/ mods[i] * rems[i] * Inv(lc/ mods[i] , mods[i]);
    return x % lc;
}
void main_(int tc) {

    ll n , k , m; cin >> n >> k >> m;
    if (m == 1){ cout << 0 << nd;return; }
    vector <ll > mods;
    for (ll i = 2; i <= 50; ++i)
        if (is(i) && m % i == 0)
            mods.emplace_back(i);

    vector <ll > rems;

    for (auto &x : mods) rems.emplace_back(locus(n , k , x));

    cout << solve_relative_primes(mods , rems) << nd;


}

void build(){
    for (int j = 1; j < LOG; ++j)
        for (int i = 1; i + (1 << j) <= n+1; ++i)
            anc[i][j] = func(anc[i][j-1] , anc[i+ (1 << (j-1))][j-1]);
}

int func(int u , int v){
    return dep[u] < dep[v] ? u : v;
}
int lca(int u , int v){
    if (u == v) return u;
    if ((u = st[u]) < (v = st[v])) swap(u , v);
    int L = Log[u - (++v)+1];
    return par[func(anc[v][L] , anc[u - (1 << L)+1][L])];
}

Info merge(Info u , Info  v){
    Info ans; ans.clear();
    ans.ans = u.ans + v.ans;
    ans.sum =(u.sum + v.sum) % 3;
    for (int m = 0; m < 3; ++m) {
        ans.ans+= u.suf[m] * 1ll * v.pre[(3 - m) % 3];
        ans.pre[(m +u.sum) % 3]+= v.pre[m];
        ans.suf[(m+v.sum) % 3]+= u.suf[m];
        ans.pre[m]+=u.pre[m];
        ans.suf[m]+=v.suf[m];
    }
    return ans;
}

struct DataLOL {// zero based
    int n, m;
    vector<vector<int>> bit;

    DataLOL(int n = 0, int m = 0) : n(n), m(m) {
        bit.resize(n + 1, vector<int>(m + 1, 0));
    }

    int get(int x, int y) {
        int sum = 0;
        for (int i = x; i; i -= i & -i)
            for (int j = y; j; j -= j & -j)
                sum += bit[i][j];

        return sum;
    }

    int get_sum(int x1, int y1, int x2, int y2) {
        // cout << "get_sum " << x1 << ' ' << y1 << ' ' << x2 << ' ' << y2 << endl;
        x2++, y2++;
        // cout << get(x2, y2) << ' ' << get(x2, y1) << ' ' << get(x1, y2) << ' ' << get(x1, y1) << endl;
        return get(x2, y2) - get(x2, y1) - get(x1, y2) + get(x1, y1);
    }

    void add(int x, int y) { // update all the points of square zero based
        // cout << "increasing " << x << ' ' << y << endl;
        for (int i = x + 1; i <= n; i += i & -i)
            for (int j = y + 1; j <= m; j += j & -j)
                bit[i][j]++;
    }
    /*
       fuck.increase(x, y);
        fuck.increase(x, y + l - 1);
        fuck.increase(x + k - 1, y);
        fuck.increase(x + k - 1, y + l - 1);
     */
    void add(int x1 , int y1 , int x2 , int y2){
        add(x1 , y1);
        add(x1 , y2);
        add(x2 , y1);
        add(x2 , y2);

    }
};



int n , qs;
vector <int > sz , par , id;
vector <ll > sum;
void init(){
    id = sz = par = vector <int > (n+1 , 1);
    sum = vector <ll > (n+1);
    for (int i = 0; i <= n; ++i) sum[i] = par[i] = id[i] = i;
}

int findp(int u){
    if (u == par[u]) return u;
    return par[u] = findp(par[u]);
}
int add(int u){
    int nu = (int)par.size();
    sz.push_back(1);
    sum.push_back(u);
    par.push_back(nu);
    return nu;
}

bool work (int u , int v){
    u = findp(u) , v = findp(v);
    if (u == v) return 0;
    if (sz[u] < sz[v]) swap(u , v);
    par[v] = u;
    sz[u]+=sz[v];
    sum[u]+=sum[v];
    return 1;
}
void main_(int tc){
    cin >> n >> qs; init();
    for (int op , u , v , i = 1; i <= qs; ++i) {
        cin >> op >> u;
        if (op == 3) {
            u = findp(id[u]);
            cout << sz[u] << " " << sum[u] << nd;
        }
        else {
            cin >> v;
            if (op == 1) work(id[u] , id[v]);
            else{
                // move u
                if (u == v) continue;
                int pu = findp(id[u]);
                sum[pu]-=u;
                sz[pu]-=1;
                id[u] = add(u);
                work(id[u] , id[v]);
            }
        }
    }


}

/*
// get redoff inertsected segments but may segments contains each other
    vector<vector<int> > newSeg;
    set<int> cur;
    while (!seg.empty()) {
        int l = seg.begin()->first;
        int r = seg.begin()->second;
        cur.insert(r);
        seg.erase(seg.begin());

        while (!cur.empty() && *cur.begin() < l) {
            cur.erase(cur.begin());
        }
        if (!cur.empty() && *cur.begin() <= r) {
            int newL = l;
            int newR = *cur.begin();
            newSeg.push_back({newR - newL + 1, newL, newR});
            l = newR + 1;
            if (l <= r) {
                seg.insert({l, r});
            }
        }
    }


 */

int catLan(int n) {
    if (n % 2)return 0;
    n /= 2;
    return 1ll * fac[2 * n] * (1ll * inv[n] * inv[n + 1] % mod) % mod;
}


long long get_kh_Min(node * root , int k){ // check big root size > k
root->push_down();
int L = root->ch[L]->sz;
if (k < L) return get_kh_Min(root->ch[LF] , k);
L+=root->sz;
if (k >= L) return get_kh_Min(root->ch[RT] , k-L);
return root->data;
}




struct nod{
    ll mx , preMn , preMx , sufMn , sufMx , sum , mn;
    nod(int s = 0) {
        sum = s;
        mx = preMx = sufMx = max(0 , s);
        mn = preMn = sufMn = min(0 , s);
    }

};


nod merge(nod L , nod R){
    nod ans ;
    ans.sum = L .sum + R.sum;
    ans.preMx = max(L.preMx , L.sum + R.preMx);
    ans.sufMx = max(R.sufMx , R.sum + L.sufMx);
    ans.mx = max({L.mx , R.mx , L.sufMx + R.preMx});

    ans.preMn = min(L.preMn , L.sum + R.preMn);
    ans.sufMn = min(R.sufMn , R.sum+L.sufMn);
    ans.mn = min({L.mn , R.mn , L.sufMn+R.preMn});
    return ans;
}



struct nod{
    ll mx , preMn , preMx , sufMn , sufMx , sum , mn;
    nod(int s = 0) {
        sum = s;
        mx = preMx = sufMx = max(0 , s);
        mn = preMn = sufMn = min(0 , s);
    }

};
nod merge(nod L , nod R){
    nod ans ;
    ans.sum = L .sum + R.sum;
    ans.preMx = max(L.preMx , L.sum + R.preMx);
    ans.sufMx = max(R.sufMx , R.sum + L.sufMx);
    ans.mx = max({L.mx , R.mx , L.sufMx + R.preMx});

    ans.preMn = min(L.preMn , L.sum + R.preMn);
    ans.sufMn = min(R.sufMn , R.sum+L.sufMn);
    ans.mn = min({L.mn , R.mn , L.sufMn+R.preMn});
    return ans;
}
int n;
vector< vector <int > > anc , g;
vector <int > dep , value_of;
vector <  vector < nod > > ans;
void init(){
    g = vector < vector <int > > (n+5);
    anc = vector < vector <int > > (n+5 , vector <int > (LOG+1));
    ans = vector < vector < nod > > (n+5 , vector < nod > (LOG+1));
    value_of = dep = vector <int > (n+5);
}
void dfs(int node){
    ans[node][0] = nod(value_of[node]);
    for (auto &ch : g[node]){
        dep[ch] = 1 + dep[node];
        anc[ch][0] = node;
        dfs(ch);
    }
}

int kth (int node , int k){
    for (int i = LOG-1; ~i; --i) if (k & (1 <<i)) node = anc[node][i];
    return node;
}
int lca(int u , int v){
    if (dep[u] < dep[v]) swap(u , v);
    u = kth(u , dep[u] - dep[v]);
    if (u == v) return u;
    for (int i = LOG-1; ~i; --i) if (anc[u][i] != anc[v][i]) u = anc[u][i] , v = anc[v][i];
    assert(anc[u][0] == anc[v][0] && u ^ v);
    return anc[u][0];
}
nod jump (int u , int k){
    nod nu;
    for (int i = LOG-1; ~i ; --i) if (k & (1 << i))nu = merge(nu, ans[u][i]), u = anc[u][i];
    return nu;
}
void main_(int tc) {
    cin >> n; init();
    value_of[1] = 1;
    int last = 1;
    vector < array<int , 3 > > q;
    for (int i = 1; i <= n; ++i){
        char c; cin >> c;
        if (c == '?') {
            int u, v, x;
            cin >> u >> v >> x;
            q.push_back({u, v, x});
        }
        else{
            int nu , u , x; cin >> u >> x;
            nu = ++last;
            g[u].emplace_back(nu);
            value_of[nu] = x;
        }
    }
    dfs(1);
    for (int i = 1; i < LOG; ++i){
        for (int node = 1; node <= n+1; ++ node) {
            int p = anc[node][i - 1];
            anc[node][i] = anc[p][i - 1];
            auto R = ans[node][i - 1];
            auto L = ans[p][i - 1];
            ans[node][i] = merge(L , R);
        }
    }
    for (auto &qr : q){
        int u = qr[0] , v= qr[1] , x = qr[2];
        if (dep[u] > dep[v]) swap(u, v);
        int lc = lca(u , v);
        if (u == lc){
            auto res = jump(v , dep[v] - dep[lc]);
            res = merge(res , ans[lc][0]);
            if (x >= res.mn && x <= res.mx)py
            else pn
        }
        else{
            auto a = jump(u , dep[u] - dep[lc]);
            a = merge(a , ans[lc][0]);
            auto b = jump(v , dep[v] -dep[lc] );
            swap(b.preMn , b.sufMn);
            swap(b.preMx , b.sufMx);
            auto res = merge(a , b);
            if (x >= res.mn && x <= res.mx)py
            else pn

        }
    }

}

const int mn = 1e5 *75;
int lc[mn] , rc[mn] , val[mn];
stack <int > memo; int nodes ;

int extend(){
    if (memo.empty()) return ++ nodes;
    int cur = memo.top(); memo.pop();
    return cur;
}

void pull(int u){
    val[u] = val[lc[u]] + val[rc[u]];
}
void upd (int & x , int nl , int nr , int p , int v){
    if (!x) x = extend();
    if (nl+1 == nr){ val[x] = v;return; }
    int md = nl + nr >> 1;
    if (p < md) upd(lc[x] , nl , md , p , v);
    else upd(rc[x] , md , nr , p , v);
    pull(x);
}
void give(int x){
    memo.emplace(x);
    val[x] = lc[x] = rc[x] = 0;
}
int merge(int u , int v , int nl , int nr){
    if (!u || !v) return u | v;
    if (nl +1 == nr){
        val[u]+=val[v];
        give(v);
        return u;
    }
    int md = nl + nr >> 1;
    lc[u] = merge(lc[u] , lc[v] , nl , md);
    rc[u] = merge(rc[u] , rc[v] , md , nr);
    pull(u) , give(v);
    return u;
}

void split(int u , int &v , int k){
    if (!u) return v = 0 , void();
    if (!v) v = extend();
    if (k < val[lc[u]]) swap(rc[u] , rc[v]) , split(lc[u] , lc[v] , k);
    else if (val[lc[u]] == k) swap(rc[u] , rc[v]);
    else split(rc[u] , rc[v] , k-val[lc[u]]);
    val[v] = val[u] - k , val[u] = k;
}

struct seq{
    int L , R , root , type;
    bool operator < (const seq & rhs) const{
        return L < rhs.L;
    }
};


int find(int node , int nl , int nr , int k){
    if (nl+1 == nr) return nl;
    int md = nl + nr >> 1;
    if (k <= val[lc[node]]) return find(lc[node] , nl , md , k);
    return find(rc[node] , md , nr , k - val[lc[node]]);
}
set<seq > ds;
int nl , nr , n;


void split(int p = 0){
    if (!p || p == n) return;

    auto it = --ds.upper_bound({p, n , 0 , 0});
    if (it->R == p) return;
    int type = it->type;
    int oldRoot = it->root;
    int oldL = it->L , oldR = it->R;
    int nuR = 0;
    ds.erase(it);
    if (!type) split(oldRoot , nuR , p - oldL +1);
    else split(oldRoot , nuR , oldR -p) , swap(oldRoot , nuR);
    ds.insert({oldL , p , oldRoot , type});
    ds.insert({p+1 , oldR , nuR , type});
}
void main_(int tc){
    int qs; cin >> n >> qs;
    nl = 0 , nr = 30;
    for (int i = 1; i <= n; ++i){
        char c; cin >> c;
        int t = c -'a'+1;
        int root = 0;
        upd(root , nl , nr , t , 1);
        ds.insert({i , i , root , 0});
    }
    // 0 , inc , 1 dec
    for (int i = 1; i <= qs; ++i){
        int tp  , L , R;
        cin >> L >> R >> tp; tp^=1;
        split(L-1); split(R);
        int nuR = 0;
        while (!ds.empty()){
            auto it = ds.lower_bound({L , 0 , 0 , 0});
            if (it == ds.end() || it->L > R) break;
            nuR = merge(nuR , it->root , nl , nr);
            ds.erase(it);
        }
        ds.insert({L , R , nuR , tp});
    }
    for (int i = 1 ; i <= n; ++i){
        auto it = --ds.upper_bound({i , n , 0 , 0});
        int tp = it->type;
        int R = it->root;
        int me = !tp ? i - it->L +1 : it->R-i+1;
        int ans = find(R , nl , nr , me);
        cout << char('a'+ ans-1);
    }

}

int n;
vector <int > sz, par , len;
void init(){
    sz = par = len = vector <int > (n+5);
    for (int i = 0; i <= n+1; ++i) par[i] = i , sz[i] = 1;
}

int findp (int u){
    if (u == par[u]) return u;
    int p = findp(par[u]);
    len[u] ^= len[par[u]];
    return par[u] = p;
}

bool work(int u , int v){
    int x = u , y = v;
    u = findp(u) , v= findp(v);
    if (u == v) return 0;
    if (sz[u] < sz[v]) swap(u , v);
    par[v] = u ,sz[u]+=sz[v];
    len[v] = (len[x] ^ 1 ^ len[y]);
    return 1;
}


int work(int u , int v){
    int x = u , y = v;
    u = findp(u) , v= findp(v);
    if (u == v) return len[x] == len[y] ? -1 : 0;
    if (sz[u] < sz[v]) swap(u , v);
    par[v] = u ,sz[u]+=sz[v];
    len[v] = (len[x] ^ 1 ^ len[y]);
    return 1;
}
/*
vector <int > build;
deque <int > path;
path.emplace_back(1);
vector <bool > in_que(n+5);
in_que[1] = 1;
while (!path.empty()){
int u = path.front(); path.pop_front();
for (auto &[ch , w , idx] : g[u]){
if (in_que[ch]) continue;
if (d[ch] == d[u] + w){
build.emplace_back(idx);
in_que[ch] = 1;
path.emplace_back(ch);
}
}
}
*/

int dist[M][M] , path[M][M];


void build (int st , int en){
    if (path[st][en] == -1) { // repeating somme nodes
        cout << st <<" "<< en << nd;
        return;
    }
    build(st , path[st][en]);
    build(path[st][en] , en);
}

auto work =[&] (int i , int j)->ld{
    if (a[i][2] > a[j][2]) swap(i , j);
    auto vi = v(i);
    auto vj = v(j);
    if (a[i][1]+ a[j][1] > U) return vj[0] - vi[1];
    if (vi[1] > vj[0]) return abs(vi[2] - vj[2]);
    return get({vi[2] , vi[1]} , {vj[2] , vj[0] });
};
void bellmanFord(int src , vector < array<int , 3 > > edges){ // directed
    int n;
    vector <ll > dist(n+5 , 1e18);
    dist[src] = 0;
    for (int it = 1; it  <= n; ++it){ // update in the nth iterations = -ve cycle
        bool up = 0;
        for (auto &[u , v , w] : edges){
            if (dist[v] > dist[u] + w){
                dist[v] = w + dist[u];
                up = 1;
            }
        }
        if (!up) break;
        if (up && it == n) return -1;
    }
}

void floyed(){
    for (int i = 1; i <= n; ++i) dist[i][i] = 0;
    for (int k = 1; k <= n; ++k) {
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                int relax = dist[i][k] + dist[k][j];
                if (dist[i][j] > relax) {
                    dist[i][j] = relax;
                    path[i][j] = k;
                }
            }
        }
    }
}

int head[N] , nxt[N] , to[N] , ne , n;
void init(){
    memset(head , -1 ,n * sizeof head[0]);
    ne = 0;
}

void add_edge(int f , int t){
    to[ne] = t;
    nxt[ne] = head[f];
    head[f] = ne++;
}

void add_Bi_edge(int u , int v){
    add_edge(u , v);
    add_edge(v , u);
}

int n , qs; cin >> n >> qs;
vector <int > a(n);
for (auto &i : a) cin >> i;
int SQ = sqrt(n) +1;
int B = (n+ SQ-1) / SQ;
vector <int > nxt(n+5) , dp(n+5) , last(n+5);

auto id =[&] (int i)->int{
    return i >= n ? B : i / SQ;
};

auto upd = [&] (int i){
    int nx = i + a[i];
    if (id(nx) == id(i)){
        last[i] = last[nx];
        nxt[i] = nxt[nx];
        dp[i] = 1 + dp[nx];
        return ;
    }
    last[i] = i;
    dp[i] = 1;
    nxt[i] = min(n , nx);
};

for (int i = n-1; i >= 0; --i) upd(i);

for (int i = 1; i <= qs; ++i){
int t , idx; cin >> t >> idx; --idx;
if (!t){
cin >> a[idx];
for (int b = idx; b >= idx / SQ * SQ; --b) upd(b);
}
else{
int ans = 0;
int la = -1;
for (int jump = idx; jump < n; jump = nxt[jump]){
ans+= dp[jump] , la = last[jump];
}
cout << ++la <<" "<< ans << nd;
}
}

struct dragon{
    int n , low;
    vector <int > t;
    void init(int _n){
        n = _n * 2;
        t = vector <int > (n+5);
        low = 31 - clz(n); low = 1 << low;
    }
    void upd (int i , int v){
        for ( ; i <= n ; i += i & -i) t[i]+=v;
    }
    int lower(int k){
        int pos = 0;
        for (int sz = low; sz && k ; sz >>= 1)
            if (pos + sz <= n && t[pos+sz] < k) k-=t[(pos+= sz)];
        return pos+1;
    }
};


int n , qs , k , dfn , szs , root;
vector <int > sz , a , dep , used , st  , par;
vector < vector <int > > g , dist ;

void init(){
    par = sz = a = dep = used  = vector <int > (max(n , k)+5);
    mn = vector <int > (n+5 , 1e7);
    g = vector < vector <int > > (n+5);
    dist = vector < vector <int > > (LOG+1, vector <int > (n+5));
    dfn = szs = 0; root = n +2;
    st[0] = 1;
}


void dfs_sz(int node , int p){
    szs+=1; sz[node] = 1;
    for (auto &ch : g[node]) if (!used[ch] && ch ^ p) dfs_sz(ch , node) ,sz[node]+=sz[ch];
}


int find_c (int node , int p){
    for (auto &ch : g[node])
        if (!used[ch] && ch ^ p && sz[ch] > szs / 2) return find_c(ch , node);
    return node;
}

void add_edge(int u , int ch){
    par[ch] = u;
    dep[ch] = 1 + dep[u];
}

void dfs(int node , int p , int d){
    for (auto &ch : g[node]){
        if (ch ^ p && !used[ch]){
            dist[d][ch] = dist[d][node]+1;
            dfs(ch , node , d);
        }
    }
}
ll ans = 0;
void get(int node , int p , int d = 1){
    if (k >= d) ans+= st[k -d];
    for (auto &ch : g[node]){
        if (!used[ch] && ch != p)
            get(ch , node , d+1);
    }
}

void upd (int node , int p, int t , int d = 1){
    st[d]+=t;
    for (auto &ch : g[node]) if (!used[ch] && ch ^ p) upd(ch , node , t , d+1);
}

void decompose (int node , int rt){
    szs = 0;
    dfs_sz(node , -1);
    int c = find_c(node , -1);used[c] = 1;
    add_edge(rt , c);
    // dfs(c , -1 , dep[c]);
    for (auto &ch : g[c])
        if (!used[ch]) get(ch , -1) , upd(ch , -1 , 1);
    for (auto &ch : g[c])
        if (!used[ch])
            upd(ch , -1 , -1);
    for (auto & ch : g[c]){
        if (!used[ch])
            decompose(ch , c);
    }
}


int find_L (int nl , int nr , int idx , vector <int > &  cc){
    int sum = 0;
    for (auto &rt : cc) sum+= val[rt];
    if (sum == nr - nl || (nr-nl == 1 && nr == 1)) return -1;
    if (nl+1 == nr) return nl;
    vector <int > L , R;
    for (auto &rt : cc){L.emplace_back(lc[rt]);R.emplace_back(rc[rt]); }
    int md = nl + nr >> 1;
    //  cout << nl <<" "<< nr <<" "<< md << " "<< sum << endl;
    int temp = -1;
    if (idx >= md) temp = find_L(md , nr , idx , R);
    if (temp == -1) temp = find_L(nl , md , idx  , L);
    return temp;
}

int find_R (int nl , int nr , int idx , vector <int > & cc){
    int sum = 0;
    for (auto &rt : cc) sum+=val[rt];
    if (sum == nr - nl) return -1;
    if (nl+1 == nr) return nl;
    vector <int > L , R;
    for (auto &rt : cc){L.emplace_back(lc[rt]);R.emplace_back(rc[rt]); }
    int md = nl + nr >> 1;
    int temp = -1;
    if (idx < md) temp = find_R(nl , md , idx , L);
    if (temp == -1) temp = find_R(md , nr , idx , R);
    return temp;
}

int n ,qs , dfn;
vector <int > head , sz , par , heavy , st , dep;
vector < vector <int > > g ;
vector < stack < array<int , 2 > > > ds;

void init(){
    dep = st = head = heavy = par = sz = vector <int > (n+5);
    g = vector < vector <int > > (n+5);
    ds = vector < stack <array<int , 2 >  > > (n+5);
}

void dfs_sz(int node =1 , int p = 1){
    sz[node] = 1 , head[node]= node;
    for (auto &ch : g[node]){
        if (ch == p) continue;
        par[ch] = node; dep[ch] = 1 + dep[node];
        dfs_sz(ch , node);
        if (sz[ch] > sz[heavy[node]]) heavy[node] = ch;
        sz[node]+=sz[ch];
    }
}
void hld (int node = 1){
    st[node] = ++dfn;
    if (heavy[node]) head[heavy[node]] = head[node] , hld(heavy[node]);
    for (auto &ch : g[node]){
        if (ch == heavy[node] || ch == par[node]) continue;
        hld(ch);
    }
}
void main_(int tc){
    int c; cin >> n >> c >> qs; init();
    for (int u , v , i = 1; i < n; ++i){
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    } dfs_sz();

    vector <int > freq(c+5) , ans(n+5);
    ans[0] = c;

    auto upd =[&](int cc , int v){
        ans[freq[cc]]--;
        freq[cc]+=v;
        ans[freq[cc]]++;
    };

    auto solve =[&] (int u , int C){
        while (u){
            int myP = head[u];
            int dist = dep[u] - dep[myP]+1;
            if(myP == 1) dist-=1;
            int cp = dist;

            while (dist > 0 && !ds[myP].empty()){
                auto [col , D] = ds[myP].top(); ds[myP].pop();
                if (dist >= D) upd(col , -D) , dist-=D;
                else{
                    upd(col , -dist);
                    D-=dist; dist = 0;
                    ds[myP].push({col , D});

                }
            }

            ds[myP].push({C  , cp});
            upd(C , cp);
            u = par[myP];
        }
    };

    for (int u , C , m , i = 1; i <= qs; ++i){
        cin >> u >> C >> m;
        solve(u , C);
        cout << ans[m] << nd;

    }










}
int n , qs, T;
vector<int > a;
vector < vector <array<int , 2 >  > > G;

const int mxn = (2e5+10) *2;
const int mxm = mxn * 32;
vector < array<int , 2 >  > g[mxn];
void init(){
    a = vector <int > (n+5);
    G = vector < vector <array<int , 2 >  > > (n+5);
}

void add_edge(int u , int v , int w){
    g[u].push_back({v , w});
}

void work (int node , int p = -1){
    int temp  , last ; temp = 0;
    for (auto &[ch , w] : G[node]){
        if (ch == p) continue;
        ++temp;
        if (temp == 1){
            add_edge(node , ch , w);
            add_edge(ch , node , w);
            last = node;
        }
        else if (temp == (int)G[node].size() - (node != 1)){
            add_edge(last , ch , w);
            add_edge(ch , last , w);
        }
        else{
            ++T;
            add_edge(last , T , 0);
            add_edge(T , last , 0);
            last = T;
            add_edge(ch , last , w);
            add_edge(last , ch , w);
        }
    }
    for (auto &[ch , w] : G[node]){
        if (ch == p) continue;
        work(ch , node);
    }
}

int nodes , dfn;
bool used[mxn];
int st[mxn]  , en[mxn] , sz[mxn] , root[mxn/ 2];
ll dist[LOG+1][2 * mxn];

void dfs_sz(int node , int p = -1){
    nodes++; sz[node] = 1;
    for (auto &[ch , w] : g[node]){
        if (ch == p || used[ch]) continue;
        dfs_sz(ch , node);
        sz[node]+=sz[ch];
    }
}

int find_c (int node , int p = -1){
    for (auto &[ch , w] : g[node]){
        if (ch == p || used[ch]) continue;
        if (sz[ch] > nodes / 2) return find_c(ch , node);
    }
    return node;
}

void dfs(int node , int p  , int d){
    for (auto &[ch , w] : g[node]){
        if (ch == p || used[ch]) continue;
        dist[d][ch] = dist[d][node] + w;
        dfs(ch , node , d);
    }
}



struct node{
    ll sum , pSum;int id , dep , cc;
    vector <int > ct;
    node(){
        sum = pSum = id = dep = cc = 0;
        ct = vector <int > ();
    }
};
node t[mxm];


int decompose(int node , int dep = 0){
    nodes = 0;
    dfs_sz(node);
    int cent = find_c(node); used[cent] = 1; node = cent;
    st[node] = ++dfn;
    dfs(node , -1 , dep);
    t[node].id = node; t[node].dep = dep;
    for (auto &[ch , w] : g[node]){
        if (used[ch]) continue;
        int Ch = decompose(ch, dep+1);
        t[node].ct.emplace_back(Ch);
    }
    en[node] = dfn;
    return node;
}
bool in_sub(int u , int v){
    u = t[u].id , v = t[v].id;
    return st[u] <= st[v] && en[u] >= en[v];
}
int upd (int cur , int node){ // upd node , in cur tree
    assert(T+1 < mxm); ++T;
    t[T] = t[cur]; cur = T;
    t[cur].cc++;
    t[cur].sum+= dist[t[cur].dep][node];
    for (auto &ch : t[cur].ct){
        if (in_sub(ch , node)){
            ch = upd(ch , node);
            t[ch].pSum+= dist[t[cur].dep][node];
        }
    }
    return cur;

}
ll query(int cur , int u){
    ll ans = 0;
    while (t[cur].id != t[u].id){
        int p = 0;
        for (auto &ch : t[cur].ct) if (in_sub(ch , u)) p = ch ;
        assert(p);
        ans+= t[cur].sum - t[p].pSum;
        ans+= dist[t[cur].dep][t[u].id] *  (t[cur].cc - t[p].cc);
        cur = p;
    }
    ans+= t[cur].sum;
    return ans;
}
void main_(int tc){
    cin >> n >> qs; init();
    for (int i= 1; i <= n; ++i) cin >> a[i];
    for (int u , v , w , i = 1; i < n; ++i){
        cin >> u >> v >> w;
        G[u].push_back({v , w});
        G[v].push_back({u , w});
    }
    T = n;
    work(1 , 1);
    root[0] = decompose(1);
    for (int i = 1; i <= n; ++i) root[i] = upd(root[i-1] , a[i]);

    const int Mod = 1 << 30;
    ll ans = 0;
    for (int _ = 1; _ <= qs; ++_){
        int tp; cin >> tp;
        if (tp == 1){
            int L , R , u ; cin >> L >> R >> u;
            L^= ans;
            R^= ans;
            u^=ans;
            ans = query(root[R],  u) - query(root[L-1] , u);
            cout << ans << nd;
            ans%= Mod;
        }
        else{
            int x; cin >> x;
            x^=ans;
            root[x] = upd(root[x-1] , a[x+1]);
            swap(a[x] , a[x+1]);
        }

    }



}
/*
 *
struct node;
extern node *Empty;
enum DIR{L , R};

struct node{
    node *ch[2], * par;
    ll data , B , sz;
    bool is_rev;
    node(){
        data = sz = is_rev = 0;B= INT_MIN;
        ch[L] = ch[R] = par =  this;
    }
    node(ll val , node * lc = Empty , node * rc = Empty){
        data = val; B = rand(1 , 1e13); is_rev = 0;
        ch[L] = lc , ch[R] = rc; par = Empty;
        push_up();
    }
    void push_up(){
        for (auto i : {0 , 1}) if (ch[i] != Empty) ch[i]->par = this;
        sz = ch[L]->sz +ch[R]->sz + 1;
    }

    void push_down(){
        if (!is_rev) return;
        for (auto i : {0 , 1}) ch[i]->reverse();
        is_rev = 0;
    }
    void reverse(){
        if (this == Empty) return;
        swap(ch[L] , ch[R]);
        is_rev^= 1;
    }

};

node *Empty = new node();

node * merge (node * lc , node * rc){
    if (lc == Empty) return rc;
    if (rc == Empty) return lc;
    lc->push_down();
    rc->push_down();
    if (lc->B > rc->B) {
        lc->ch[R] = merge(lc->ch[R], rc);
        lc->push_up();
        return lc;
    }
    rc->ch[L] = merge(lc , rc->ch[L]);
    rc->push_up();
    return rc;
}

void split(node * root , int lsz ,  node * & lc , node * & rc){
    if (root == Empty){
        lc = rc = Empty;return;
    }
    root->push_down();
    int Lsz = root->ch[L]->sz;
    if (lsz <= Lsz){
        split(root->ch[L] , lsz , lc , root->ch[L]);
        rc = root;
    }
    else{
        split(root->ch[R] , lsz-Lsz-1 , root->ch[R] , rc);
        lc = root;
    }
    root->push_up();
    root->par = Empty;
}

void relax(node * cur){
    if (cur == Empty) return;
    relax(cur->par);
    cur->push_down();
}

int dir (node * par , node *ch){
    return (par->ch[R] == ch);
}
int get_index(node * cur){
    relax(cur);
    int ans = cur->ch[L]->sz;
    while (cur->par != Empty){
        if (dir(cur->par , cur)) ans+= cur->par->ch[L]->sz+1;
        cur = cur->par;
    }
    return ans;
}

node * arr[N];

void work (node * & root , int L , int R){
    node * before , * after;
    split(root , R+1 , root , after);
    split(root , L , before , root);
    root->reverse();
    root = merge(merge(before , root) , after);

}
void main_(int tc){
    int n;
    while (cin >> n  , n) {
        node *root = Empty;
        for (int i = 0; i < n; ++i) {
            int x;
            cin >> x;
            arr[i] = new node(x);
            root = merge(root, arr[i]);
        }
        stable_sort(arr, arr + n, [&](node *x, node *y) {
            return x->data < y->data;
        });

        for (int i = 0; i < n; ++i) {
            int pos = get_index(arr[i]);
            work(root, i, pos);
            cout << pos + 1 << " \n"[i + 1 == n];
        }
    }


}

 struct node{
    node *ch[2], * par;
    ll data , B , sz , lazy , sum;
    node(){
        data = sz = lazy = sum = 0;B= INT_MIN;
        ch[L] = ch[R] = par =  this;
    }
    node(ll val , node * lc = Empty , node * rc = Empty){
        data = val; B = rand(1 , 1e13); lazy = sum = 0;
        ch[L] = lc , ch[R] = rc; par = Empty;
        push_up();
    }
    void push_up(){
        for (auto i : {0 , 1}) if (ch[i] != Empty) ch[i]->par = this;
        sz = ch[L]->sz +ch[R]->sz + 1;
        sum = ch[L]->sum +ch[R]->sum + data;
    }

    void push_down(){
        if (!lazy) return;
        for (auto i : {0 , 1}) ch[i]->add_lazy(lazy);
        lazy = 0;
    }
    void add_lazy(ll x){
        if (this == Empty) return;
        data+=x; lazy+=x;
        sum+= sz * x;
    }
long long get_kh_Min(node * root , int k){ // check big root size > k
root->push_down();
int L = root->ch[L]->sz;
if (k < L) return get_kh_Min(root->ch[LF] , k);
L+=root->sz;
if (k >= L) return get_kh_Min(root->ch[RT] , k-L);
return root->data;
}


};
 */




/*
 *
struct node;
extern  node * Empty;
enum Dir {LF , RT};
struct node{
    long long data , prior;
    int sz , freq;
    node * ch[2];
    node():sz(0) , data(0) , freq(0) , prior(INT_MIN) , ch{this , this}{}
    node(ll v , node * lc = Empty, node * rc = Empty){
        data = v;
        prior = rand(1 , 1e18);
        freq = 1;
        ch[LF] = lc ,  ch[RT] = rc;
        push_up();
    }
    void push_up(){
        sz = freq + ch[0]->sz + ch[1]->sz;
    }
};

node * Empty = new node();

            L                     R
            P                     p
          /   \                 /   \
         a     q               q    c
              /  \            /  \
             b    c          a    b

             q                 q
            /  \              /  \
            p   c             a   p
          /  \                  /  \
          a   b                 b   c
  changes in b par of it become p
  p par of it become q


 void rotate(node * & root , Dir d){
    node * p = root;
    node * q = p->ch[!d];
    p->ch[!d] = q->ch[d];
    q->ch[d] = p;
    p->push_up();
    q->push_up();
    root = q;
}

void balance(node * & root){
    if (root->ch[LF]->prior > root->prior) rotate(root , RT);
    else if (root->ch[RT]->prior > root->prior) rotate(root , LF);
}

void erase(node *& root , const long long & data){
    if (root == Empty) return;

    if (root->data < data) erase(root->ch[RT] , data);
    else if (root->data > data) erase(root->ch[LF] , data);
    else{
        if (root->freq > 1){
            root->freq--;
            root->push_up();
            return;
        }
        array<ll, 2 > p {0 , 0}; // prior , idx
        for (int idx = 0 ; idx < 2; ++idx){
            p = max(p , {root->ch[idx]->prior , idx});
            if (root->ch[idx] == Empty){
                node * temp = root->ch[!idx];
                delete root;
                root = temp;
                return;
            }
        }
        rotate(root , (Dir)!p[1]);
        erase(root , data);
    }
    root->push_up();
}
void insert(node *& root , const long long & data){
    if (root == Empty){
        root = new node(data);
        return;
    }
    if (root->data == data){
        ++root->freq;
        root->push_up();
        return;
    }
    if (root->data < data) insert(root->ch[RT] , data);
    else insert(root->ch[LF] , data);
    root->push_up();
    balance(root);
}
ll get_by_index(node * root , int index){
    int count = root->ch[LF]->sz;
    if (count > index) return get_by_index(root->ch[LF] , index);
    count+=root->freq;
    if (index >= count) return get_by_index(root->ch[RT] , index - count );
    return root->data;
}

int get_count(node * root , const long long data){
    if (root == Empty) return 0;
    if (root->data == data) return root->freq;
    if (root->data < data) return get_count(root->ch[RT] , data);
    return get_count(root->ch[LF] , data);
}

ll count_less(node * root , const long long data){
    if (root == Empty) return 0;
    if (root->data == data) return root->ch[LF]->sz;
    if (root->data > data) return count_less(root->ch[LF] , data);
    return count_less(root->ch[RT] , data)+ root->ch[LF]->sz + root->freq;
}
void main_(int tc) {
    int n , a; cin >> n;
    node * root = Empty;
    for (int i = 1; i <= n; ++i){
        char c; cin >> c >> a;
        if (c ==  'I') {
            if (!get_count(root, a)) insert(root, a);
        }
        else if(c == 'C') {
            cout << count_less(root, a) << nd;
        }
        else if (c == 'K') {
            if (a <= root->sz) cout << get_by_index(root , a-1) << nd;
            else cout << "invalid" << nd;
        }
        else erase(root, a);

    }



}

struct node;
extern node * Empty;
enum {LF , RT};
struct node{
    ll data , sz , prior , freq;
    node * ch[2];
    node(){
        data = sz = freq = 0; prior = -1e18;
        ch[LF] = ch[RT] = this;
    }
    node (ll d , node *lc  = Empty , node * rc = Empty){
        data = d; freq = 1; prior = rand(1 , 1e13);
        ch[LF] = lc , ch[RT] = rc;
        push_up();
    }
    void push_up(){
        sz = freq + ch[LF]->sz + ch[RT]->sz;
    }

};
node * Empty = new node();

void split(node * root , ll data , node * & lc , node * & rc){ // dont path root by ref
    if (root == Empty){
        lc = rc = Empty;
        return;
    }
    if (data < root->data){
        split(root->ch[LF] , data , lc , root->ch[LF]);
        rc = root;
    }
    else{
        split(root->ch[RT] , data , root->ch[RT] , rc);
        lc = root;
    }
    root->push_up();
}

node * merge(node * lc , node * rc){
    if (lc == Empty) return rc;
    if (rc == Empty) return lc;
    if (lc->prior > rc->prior){
        lc->ch[RT] = merge(lc->ch[RT] , rc);
        lc->push_up();
        return lc;
    }
    rc->ch[LF] = merge(lc , rc->ch[LF]);
    rc->push_up();
    return rc;
}

bool contains(node * & root , ll data){
    if (root == Empty) return 0;
    bool ret = false;
    if (root->data == data)
        ret =  root->freq++;
    else if (data <root->data) ret = contains(root->ch[LF] , data);
    else ret = contains(root->ch[RT] , data);
    root->push_up();
    return ret;
}


void insert(node * & root , node * nu){
    if (root == Empty) {
        root = nu;
        return;
    }
    if (nu->prior > root->prior){
        split(root , nu->data , nu->ch[LF] , nu->ch[RT]);
        root = nu;
    }
    else if (nu->data < root->data) insert(root->ch[LF] , nu);
    else insert(root->ch[RT] , nu);
    root->push_up();
}
void insert(node * & root , ll d){
    if (!contains(root , d)) insert(root , new node(d));
}

void erase(node * & root , ll data){
    if (root == Empty) return;
    if (data < root->data) erase(root->ch[LF] , data);
    else if (data > root->data) erase(root->ch[RT] , data);
    else{
        if (root->freq > 1) root->freq--;
        else{
            node * temp = merge(root->ch[LF] , root->ch[RT]);
            delete root ;
            root = temp;
        }
    }
    root->push_up();
}
ll get_kth(node * root , int kth){ // check root ->sz <= index // this ktk
    int count = root->ch[LF]->sz;
    if (count > index) return get_kth(root->ch[LF] , k);
    count+=root->freq;
    if (index >= count) return get_kth(root->ch[RT] , k - count );
    return root->data;
}

int get_count(node * root , const long long data){
    if (root == Empty) return 0;
    if (root->data == data) return root->freq;
    if (root->data < data) return get_count(root->ch[RT] , data);
    return get_count(root->ch[LF] , data);
}

ll count_less(node * root , const long long data){
    if (root == Empty) return 0;
    if (root->data == data) return root->ch[LF]->sz;
    if (root->data > data) return count_less(root->ch[LF] , data);
    return count_less(root->ch[RT] , data)+ root->ch[LF]->sz + root->freq;
}


*/

struct segtree2d { // one based // take care of int
    int n, m;
    vector<vector<int>> seg;

    int neutral() {
        return 1e7;
    }

    int merge(int a, int b) {
        return min(a, b);
    }

    segtree2d(int nn = 1, int mm = 1) {
        n = nn, m = mm;
        seg = vector<vector<int>>(2 * n, vector<int>(2 * m, neutral()));
    }

    int qry(int x1, int y1, int x2, int y2) {
        int ret = neutral();
        int y3 = y1 + m, y4 = y2 + m;
        for (x1 += n, x2 += n; x1 <= x2; ++x1 /= 2, --x2 /= 2) {
            for (y1 = y3, y2 = y4; y1 <= y2; ++y1 /= 2, --y2 /= 2) {
                if (x1 % 2 == 1 and y1 % 2 == 1)
                    ret = merge(ret, seg[x1][y1]);
                if (x1 % 2 == 1 and y2 % 2 == 0)
                    ret = merge(ret, seg[x1][y2]);
                if (x2 % 2 == 0 and y1 % 2 == 1)
                    ret = merge(ret, seg[x2][y1]);
                if (x2 % 2 == 0 and y2 % 2 == 0)
                    ret = merge(ret, seg[x2][y2]);
            }
        }
        return ret;
    }

    void upd(int x, int y, int val) {
        int y2 = y += m;
        for (x += n; x; x /= 2, y = y2) {
            if (x >= n)
                seg[x][y] = val; // change this if u want
            else
                seg[x][y] = merge(seg[2 * x][y], seg[2 * x + 1][y]);
            while (y /= 2)
                seg[x][y] = merge(seg[x][2 * y], seg[x][2 * y + 1]);
        }
    }
};


struct Trie { // take care of int and the number of bits
    static const int B = 35;
    struct node {
        node* nxt[2];
        int sz;
        node() {
            nxt[0] = nxt[1] = NULL;
            sz = 0;
        }
    }*root;
    Trie() {
        root = new node();
    }
    void insert(int val) {
        node* cur = root;
        cur -> sz++;
        for (int i = B - 1; i >= 0; i--) {
            int b = val >> i & 1;
            if (cur -> nxt[b] == NULL) cur -> nxt[b] = new node();
            cur = cur -> nxt[b];
            cur -> sz++;
        }
    }
    int query(int x, int k) { // number of values s.t. val ^ x < k
        node* cur = root;
        int ans = 0;
        for (int i = B - 1; i >= 0; i--) {
            if (cur == NULL) break;
            int b1 = x >> i & 1, b2 = k >> i & 1;
            if (b2 == 1) {
                if (cur -> nxt[b1]) ans += cur -> nxt[b1] -> sz;
                cur = cur -> nxt[!b1];
            } else cur = cur -> nxt[b1];
        }
        return ans;
    }
    int get_max(int x) { // returns maximum of val ^ x
        node* cur = root;
        int ans = 0;
        for (int i = B - 1; i >= 0; i--) {
            int k = x >> i & 1;
            if (cur -> nxt[!k] && cur->nxt[!k]->sz) cur = cur -> nxt[!k], ans <<= 1, ans++;
            else cur = cur -> nxt[k], ans <<= 1;
        }
        return ans;
    }
    int get_min(int x) { // returns minimum of val ^ x
        node* cur = root;
        int ans = 0;
        for (int i = B - 1; i >= 0; i--) {
            int k = x >> i & 1;
            if (cur -> nxt[k] && cur->nxt[k]->sz) cur = cur -> nxt[k], ans <<= 1;
            else cur = cur -> nxt[!k], ans <<= 1, ans++;
        }
        return ans;
    }
void erase (int val) {
    node* cur = root;
    cur -> sz--;
    for (int i = B - 1; i >= 0 && cur ; i--) {
        int b = val >> i & 1;
        if (cur -> nxt[b] == NULL) cur -> nxt[b] = new node();
        cur = cur -> nxt[b];
        cur -> sz--;
    }
}
void del(node* cur) {
    for (int i = 0; i < 2; i++) if (cur -> nxt[i]) del(cur -> nxt[i]);
    delete(cur);
}
};

/*
 *

 */
template <typename T>
struct segment_tree {
    int N;
    T E;
    vector<T> S;
    function<T(T, T)> F;
    segment_tree(int n, T e, function<T(T, T)> f) : N(n), E(e), S(2 * n, e), F(f) {}
    void update(int j, T x) {
        for (S[j += N] = x; j /= 2;) {
            S[j] = F(S[2 * j], S[2 * j + 1]);
        }
    }
    T query(int L, int R) {
        T l = E, r = E;
        for (L += N, R += N; L < R; L /= 2, R /= 2) {
            if (L % 2) {
                l = F(l, S[L++]);
            }
            if (R % 2) {
                r = F(S[--R], r);
            }
        }
        return F(l, r);
    }
};


vector <array<int , 2 >  > g[N];
void add_edge(int u , int v , int w , int d){
    !d ? g[u].push_back({v , w}) : g[v].push_back({u , w});
}

struct sss{
    int n , base , d;
    vector <int > t;
    void init(int _n , int B , int di){
        base = B; n = _n; d = di;
        t = vector <int > (2 * n);
        build(0 , 0 , n);
    }
    void build (int node , int nl , int nr){
        // cout << node <<" "<<nl <<" "<< nr << endl;
        if (nl+1 == nr){
            int cur = node + base;
            add_edge(cur , nl , 0 , d);
            return;
        }
        int md = (nl + nr) >> 1;
        build(2 * node +1 , nl , md);
        build(2 * node +2 , md , nr);
        int cur = node + base;
        int lc = 2 * node +1 + base;
        int rc = 2 * node +2 + base;
        add_edge(cur , lc , 0 , d);
        add_edge(cur , rc , 0 , d);
    }

    void upd(int node , int nl , int nr , int ql , int qr , int u , int w){
        if (nl >= qr || ql >= nr) return;
        if (nl >= ql && qr >= nr){
            int cur = node + base;
            add_edge(u , cur , w , d);
            return;
        }
        int md = (nl + nr) >> 1;
        upd(2 * node +1 , nl , md , ql , qr , u , w);
        upd(2 * node +2 , md , nr , ql , qr , u , w);
    }

    void upd (int L , int R , int u , int w){
        upd(0 , 0 , n , L , R+1 , u , w);
    }

};

void main_(int tc) {
    int n , qs , sc; cin >> n >> qs >> sc;
    sss a , b; a.init(n+1 , n+10 , 0); b.init(n+1 , 5 * n+20  , 1);
    for (int i = 1; i <= qs; ++i){
        int op; cin >> op;
        if (op == 1){
            int u  , v , w; cin >> u >> v >> w;
            add_edge(u , v , w , 0);
        }
        else if (op == 2){
            int u , L , R , w;
            cin >> u >> L >> R >> w;
            a.upd(L , R , u , w);
        }
        else{
            assert(op == 3);
            int u , L , R , w; cin >> u >> L >> R >> w;
            b.upd(L , R , u , w);
        }
    }
    ////////////////////////////////

    min_heap<array<ll, 2 > >q;
    q.push({0 , sc});
    vector <ll > dist(N, 1e18);
    dist[sc] = 0;
    while (!q.empty()){
        auto[w , node] = q.top(); q.pop();
        if (w > dist[node]) continue;
        for (auto &[ch , cost] : g[node]){
            if (dist[ch] > cost + dist[node]){
                dist[ch] = cost + dist[node];
                q.push({dist[ch] , ch});
            }
        }
    }
    for (int i = 1; i <= n; ++i) cout << (dist[i] == 1e18 ? -1 : dist[i]) <<" \n"[i == n];

/*
10 8 7
1 10 7 366692903
1 4 8 920363557
2 7 5 10 423509459
2 2 5 7 431247033
2 7 3 5 288617239
2 7 3 3 175870925
3 9 3 8 651538651
3 4 2 5 826387883
 */



}

int n , qs , dfn , sz , m , r;
vector < vector <int > > g ,anc , e;
vector <int > dep , st , has  , en , dist;
void init(){
    e = g = vector < vector <int > > (n+5);
    anc = vector < vector <int > > (n+5 , vector <int > (LOG+1));
    dist = en = has = st = dep = vector <int > (n+5);
}

void dfs (int node , int p = 0){
    dep[node] = 1 + dep[p]; st[node] = ++dfn; anc[node][0] = p ? p : node;
    for (int L = 1; L < LOG; ++L) anc[node][L] = anc[anc[node][L-1]][L-1];
    for (auto &ch : g[node]){
        if (ch == p) continue;
        dfs(ch , node);
    }
    en[node] = dfn;
}
int kth (int node , int k){
    for (int i = LOG-1; ~i ; --i) if (k & (1 << i)) node = anc[node][i];
    return node;
}
int lca(int u , int v) {
    if (dep[u] < dep[v]) swap(u, v);
    u = kth(u, dep[u] - dep[v]);
    if (u == v) return u;
    for (int i = LOG - 1; ~i; --i) if (anc[u][i] != anc[v][i]) u = anc[u][i], v = anc[v][i];
    assert(u ^ v && anc[u][0] == anc[v][0]);
    return anc[u][0];
}
bool par (int u , int v){
    return st[u] <= st[v] && en[u] >= en[v];
}


ll solve (vector <int > & nodes){
    sort(all(nodes) , [&] (int x , int y){
        return st[x] < st[y];
    });
    for (int i = 1; i < sz; ++i){
        int lc = lca(nodes[i] , nodes[i-1]);
        nodes.emplace_back(lc);
    }
    sort(all(nodes) , [&] (int x , int y){
        return st[x] < st[y];
    });
    nodes.resize(unique(all(nodes))- nodes.begin());
    vector <int > ss {nodes[0]}; // lca of all
    sz = (int) nodes.size();
    for (int i = 1; i < sz; ++i){
        while (!par(ss.back() , nodes[i])){
            int u = ss.back(); int v = ss[(int)ss.size()-2];
            e[u].push_back(v);
            e[v].push_back(u);
            ss.pop_back();
        }
        ss.emplace_back(nodes[i]);
    }
    while ((int)ss.size() > 1){
        int u = ss.back(); int v = ss[(int)ss.size()-2];
        e[u].push_back(v);
        e[v].push_back(u);
        ss.pop_back();
    }
    vector <int > dfs;
    function<void(int  , int) > dfs1 =[&] (int node , int p = 0){
        dfs.emplace_back(node);
        dist[node] = has[node] + dist[p];
        for (auto &ch: e[node]){
            if (ch == p) continue;
            dfs1(ch , node);
        }
    };
    dfs1(r , 0);

    vector <ll > dp(m+5); dp[0] = 1;
    for (auto &u : dfs){
        if (!has[u]) continue;
        vector <ll > cur_dp(m+5);
        for (int j = 1; j <= m; ++j) {
            ll &ret = cur_dp[j];
            ret = add(dp[j - 1], (j - dist[u]) * dp[j] , mod);
        }
        dp = cur_dp;
    }
    ll ans = 0;
    for (int i = 0; i <= m; ++i) ans = add(ans, dp[i] , mod);
    for (auto &cur : nodes) e[cur].clear() , dist[cur]= 0 , has[cur] = 0;
    return ans;
}

void main_(int tc) {
    cin >> n >> qs; init();
    for (int u , v , i = 1; i < n ; ++i){
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1);
    for (int _ = 1; _ <= qs; ++_){
        cin >> sz >> m >> r;
        vector <int >nodes(sz);
        for (auto &i : nodes) cin >> i , has[i] = 1;
        nodes.push_back(r); ++sz;
        cout<< solve(nodes) << nd;
    }


}

ll solve (int r , int c , int rem){
    if (rem <= 0) return bool(rem) * 1e9;
    if (!c) return 1e9;

    ll &ret = dp[r][c][rem];
    if (~ret) return ret;

    ret = solve(0 , 0 , rem - r * c);
    // H
    for (int i = 1; i < r; ++i){
        ll ch1 = c * c+ solve(r - i , c , rem);
        ll ch2 = c * c+ solve(r-i , c , rem - i * c);
        ret = min({ch1 , ch2 , ret});
    }
    // V
    for (int i = 1; i < c; ++i){
        ll ch1 = r *r + solve(r , c - i  , rem);
        ll ch2 = r * r + solve(r , c -i , rem - i * r);
        ret = min({ret , ch1 , ch2} );
    }

    return ret;
}
void main_(int tc) {
    cin >>n >> m >> k;
    cout <<solve(n , m , k) << nd;
}

/*
int solve (int L , int R){
    if (L > R) return 0;
    auto ret = dp[L][R];
    if (~ret) return ret;
    ret = 0;
    for (int k = L; k <= R; ++k){
        int ch = a[L-1] * a[k] * a[R+1];
        int Left = solve(L , k-1);
        int Right = solve(k+1 , R);
        ret = max(ret ,ch + Left + Right);
    }
    return ret;
}
*/

vector<map<ll, ll>> seg;
ll segsz;
map<ll, ll> neuval = {};

vll mergeval(vll x, vll y) { return max(x, y); }

void build(vector<ll> v) {
    ll n = sz(v);
    segsz = 1 << ll(ceil(log2(n)) + 0.5);

    seg.assign(2 * segsz, neuval);


}

void clear(ll x, ll val, ll num) {
    while (x) {
        seg[x][val] -= num;
        if (!seg[x][val])
            seg[x].erase(val);
        x /= 2;
    }
}

void crush(ll x, ll val) {
    if (x >= 2 * segsz)
        return;
    if (!seg[x][val]) {
        seg[x].erase(val);
        return;
    }
    seg[x].erase(val);
    crush(2 * x, val), crush(2 * x + 1, val);
}

void add(ll i, ll val) {
    ll x = segsz + i;
    if (!seg[x].empty())
        clear(x, seg[x].begin()->first, 1);
    seg[x].clear();
    while (x)
        seg[x][val]++, x /= 2;
}

ll demolish(ll lo, ll ro, ll p, ll l = 0, ll r = segsz, ll x = 1) {
    if (l >= ro || r <= lo)
        return 0;
    if (l >= lo && r <= ro) {
        ll ret = 0;
        for (auto it = seg[x].begin(); it != seg[x].end();) {
            ll a = it->first, b = it->second;
            if (a > p)
                break;
            ret += b;
            crush(2 * x, a), crush(2 * x + 1, a);
            clear(x / 2, a, b);
            seg[x].erase(it++);
        }
        return ret;
    }
    ll mid = (l + r) / 2;
    return demolish(lo, ro, p, l, mid, 2 * x) + demolish(lo, ro, p, mid, r, 2 * x + 1);
}

void solve(ll tc) {

    ll n, q;
    cin >> n >> q;
    vector<ll> v(n, 0);
    build(v);
    while (q--) {

        ll c;
        cin >> c;
        if (c == 1) {
            ll i, x;
            cin >> i >> x;
            add(i, x);
        } else {
            ll l, r, p;
            cin >> l >> r >> p;
            cout << demolish(l, r, p) << "\n";
        }
    }

}

void add(string & s){
    int sz = (int)s.size();
    for (int i = sz-1; i >= 0; --i){
        if (s[i] == '9') s[i] = '0';
        else {
            s[i]++;
            return;
        }
    }
    s = '1' + s;
}

int dp[3005][305][2] , n , vis[3005][305][2] , vid;
string ans;
void init(){
    ++vid;
}

int solve (string & L , int sz , int sum , int tight){
    if (sum < 0) return 0;
    if (!sz) return !sum;
    int & ret = dp[sz][sum][tight];
    if (vis[sz][sum][tight] == vid) return ret;
    ret = 0; vis[sz][sum][tight] = vid;
    int lb = tight ? L[n-sz]-'0' : 0;
    for (int j = lb; j <= 9; ++j){
        int ch = solve(L , sz-1 , sum-j , tight & (j == lb));
        ret|= ch;
    }
    return ret;
}

void build (string & L , int sz , int sum , int tight){
    if (!sz) { assert(!sum);return; }
    int lb = tight ? L[n-sz]-'0' : 0;
    for (int j = lb; j <= 9; ++j){
        int ch = solve(L , sz-1 , sum-j , tight & (j == lb));
        if (ch){
            ans.push_back((j+'0'));
            return build(L , sz-1 , sum-j , tight & (j == lb));
        }
    }

}

void main_(int tc){
    int sz; cin >> sz;
    string last = "0";
    for (int i = 1; i <= sz; ++i){
        int a; cin >> a;init();
        add(last); n = (int)last.size(); ans.clear();
        while (!solve(last , n , a , 1)){
            for (int j = 0; j < n; ++j) last[j] = '0';
            last = '1' + last; ++n; init();
        }
        build(last , n , a , 1);
        int j = 0;
        while (ans[j] == '0')++j;
        cout << ans.substr(j)<< nd;
        last = ans;
    }


}
int main() {
    ios_base::sync_with_stdio(0);cin.tie(0); cout.tie(0);
    //  freopen("input.txt", "r", stdin);
    //freopen("output.txt", "w", stdout);
    //init();
    int tt = 1, tc = 0;///cin >> tt;
    while (tt--) main_(++tc);
    return 0;
}

int query(node * LT , node * RT , int nl , int nr , ll p1 , ll p2){
if (nl+1 == nr) return (p1 <= p2 && RT->data[2]- LT->data[2]);
int md = (nl + nr)>> 1;
ll curL = RT->l->data[0] - LT->l->data[0];
ll curR = RT->r->data[1] - LT->r->data[1];
ll gain = RT->l->data[2] - LT->l->data[2];
if (p1 + curL <= p2 + curR)
return gain + query(LT->r , RT->r , md , nr , p1+ curL  , p2);
return query(LT->l , RT->l , nl , md , p1 , p2 + curR);
}


////////////////////////



namespace PollardRho {
    mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
    const int P = 1e6 + 9;
    ll seq[P];
    int primes[P], spf[P];
    inline ll add_mod(ll x, ll y, ll m) {
        return (x += y) < m ? x : x - m;
    }
    inline ll mul_mod(ll x, ll y, ll m) {
        ll res = (x) * y % m;
        return res;
        // ll res = x * y - (ll)((long double)x * y / m + 0.5) * m;
        // return res < 0 ? res + m : res;
    }
    inline ll pow_mod(ll x, ll n, ll m) {
        ll res = 1 % m;
        for (; n; n >>= 1) {
            if (n & 1) res = mul_mod(res, x, m);
            x = mul_mod(x, x, m);
        }
        return res;
    }
    // O(it * (logn)^3), it = number of rounds performed
    inline bool miller_rabin(ll n) {
        if (n <= 2 || (n & 1 ^ 1)) return (n == 2);
        if (n < P) return spf[n] == n;
        ll c, d, s = 0, r = n - 1;
        for (; !(r & 1); r >>= 1, s++) {}
        // each iteration is a round
        for (int i = 0; primes[i] < n && primes[i] < 32; i++) {
            c = pow_mod(primes[i], r, n);
            for (int j = 0; j < s; j++) {
                d = mul_mod(c, c, n);
                if (d == 1 && c != 1 && c != (n - 1)) return false;
                c = d;
            }
            if (c != 1) return false;
        }
        return true;
    }
    void init() {
        int cnt = 0;
        for (int i = 2; i < P; i++) {
            if (!spf[i]) primes[cnt++] = spf[i] = i;
            for (int j = 0, k; (k = i * primes[j]) < P; j++) {
                spf[k] = primes[j];
                if (spf[i] == spf[k]) break;
            }
        }
    }
    // returns O(n^(1/4))
    ll pollard_rho(ll n) {
        while (1) {
            ll x = rnd() % n, y = x, c = rnd() % n, u = 1, v, t = 0;
            ll *px = seq, *py = seq;
            while (1) {
                *py++ = y = add_mod(mul_mod(y, y, n), c, n);
                *py++ = y = add_mod(mul_mod(y, y, n), c, n);
                if ((x = *px++) == y) break;
                v = u;
                u = mul_mod(u, abs(y - x), n);
                if (!u) return __gcd(v, n);
                if (++t == 32) {
                    t = 0;
                    if ((u = __gcd(u, n)) > 1 && u < n) return u;
                }
            }
            if (t && (u = __gcd(u, n)) > 1 && u < n) return u;
        }
    }
    vector<ll> factorize(ll n) {
        if (n == 1) return vector <ll>();
        if (miller_rabin(n)) return vector<ll> {n};
        vector <ll> v, w;
        while (n > 1 && n < P) {
            v.push_back(spf[n]);
            n /= spf[n];
        }
        if (n >= P) {
            ll x = pollard_rho(n);
            v = factorize(x);
            w = factorize(n / x);
            v.insert(v.end(), w.begin(), w.end());
        }
        return v;
    }
}

struct custom_hash{
    static uint64_t splitmix64(uint64_t x) {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
unordered_map<long long, int, custom_hash> mp;

ll c3(ll n) {return n * (n-1) * (n-2);}
ll run(ll x , ll b , ll me){
    if (x % b) return 0;
    ll z = x / b;
    if (b == 1) return c3(mp[me]);
    if (mp.count(x) && mp.count(z)) return 1ll * mp[x] * mp[z] * mp[me];
    return 0;
}

ll ans;

void solve(int i ,int m ,  int sz , vector < pair<int , int >  > & v , ll me){
    if (i == sz) {
        ans+=run(m , me / m , me);
        return;
    }
    solve(i+1 , m , sz , v  , me);
    for (int j = 1;  j <= v[i].second; ++j){
        m*= v[i].first;
        solve(i+1 , m ,sz ,  v , me);
    }
}

void find_divs(int num) {
    vector < pair<int , int >  > ret;
    if (num == 1) return solve(0 , 1 , 0 , ret , num);
    auto v = PollardRho::factorize(num);
    sort(v.begin(), v.end());
    ret = {{v[0], 1}};
    for (int i = 1; i < (int)v.size(); i++) if (v[i] == ret.back().first) ret.back().second++;
        else ret.emplace_back(v[i], 1);
    return solve(0 , 1 ,  (int)ret.size(),ret , num);
}



// E gym  , div1E tor , problem j //  div1 E , div1 D
int dx[] {0 , 0 , -1 , 1 ,-1 , 1 , 1 , -1};
int dy[] {-1 , 1 , 0 , 0 , -1 , 1 , -1 , 1};


void init(){
    mp.clear();
    ans = 0;
}
void main_(int tc){
    vector <int > a; int n; cin >> n; init();
    for (int i = 1; i <= n; ++i){
        int x; cin >> x;
        if (!mp[x]++) a.emplace_back(x);
    }

    for (auto &i : a) find_divs(i);
    cout << ans << nd;






}


int main() {
    ios_base::sync_with_stdio(0);cin.tie(0); cout.tie(0);
    //  freopen("input.txt", "r", stdin);
    //freopen("output.txt", "w", stdout);
    PollardRho::init();
    int tt = 1, tc = 0;cin >> tt;
    while (tt--) main_(++tc);
    return 0;
}


const int M = 2e5 * 90;


ll INF = 1e12;
ll sum (ll n) {return n * (n+1) >> 1;}

int lc[M] , rc[M] , lazy[M] , mn[M] , mx[M], nodes;
int extend(){
    assert(++nodes < M);
    return nodes;
}
void create_left(int node , int nl , int nr) {
    if (!lc[node]) {
        int md = (nl + nr) >> 1;
        int cur = extend();
        lc[node] = cur , mn[cur] = nl , mx[cur] = md-1;
    }
}
void create_right(int node , int nl , int nr){
    if (!rc[node]){
        int md = (nl + nr) >> 1;
        int cur = extend();
        rc[node] = cur , mn[cur] = md , mx[cur] = nr-1;
    }
}
void drop (int node , int nl , int nr){
    if (!lazy[node]) return;
    mn[node]+=lazy[node];
    mx[node]+=lazy[node];
    if (nr - nl -1){
        create_left(node , nl , nr);
        create_right(node , nl , nr);
        lazy[lc[node]]+=lazy[node];
        lazy[rc[node]]+=lazy[node];
    }
    lazy[node] = 0;
}
void upd (int &node , int nl , int nr , int t){
    drop(node , nl , nr);
    if (mn[node] > t){
        lazy[node]-=1;
        drop(node , nl , nr);
        return;
    }
    if (mx[node] < t){
        lazy[node]+=1;
        drop(node , nl , nr);
        return;
    }
    if (mn[node] == mx[node]) return;
    int md = (nl + nr) >> 1;
    create_left(node , nl , nr);
    create_right(node , nl , nr);
    upd(lc[node] , nl , md , t);
    upd(rc[node] , md , nr , t);
    mn[node] = min(mn[lc[node]] , mn[rc[node]]);
    mx[node] = max(mx[lc[node]] , mx[rc[node]]);

}

int query (int node , int nl , int nr , int t){
    drop(node , nl , nr);
    if (nl +1 == nr) {
        assert(mn[node] == mx[node]);
        return mn[node];
    }
    int md = (nl + nr) >> 1;
    if (t < md) {
        create_left(node , nl , nr);
        return query(lc[node] , nl , md , t);
    }
    create_right(node , nl , nr);
    return query(rc[node] , md , nr , t);
}



void init(){
    for (int i = 1; i <= nodes; ++i) lc[i] = rc[i] = mn[i] = mx[i] = lazy[i] = 0;
    nodes = 1;
    mn[1] = 0, mx[1] = 1e9;
}

void main_(int tc){
    int qs; cin >> qs; init();
    int Mx = 1e9+1;
    ll last = 0; int root = 1;
    for (int _ = 1; _ <= qs; ++_){
        int t; cin >> t;
        upd(root , 0 , Mx , t);
        int k; cin >> k;
        for (int i = 1; i <= k; ++i){
            int x; cin >> x;
            x = add(x , last , Mx);
            cout << (last = query(1 , 0 , Mx , x) ) << nd;
        }
    }


}
/*
  int n; cin >> n;
    for (int x , i = 1; i <= n; ++i) {
        cin >> x;
        f[x]++;
    }
    int cur = 2e7;
    for (auto &p : primes){
        for (int j = cur / p; j ; --j){
            f[j]+= f[p * j];
        }
    }
    for (int i = cur; i ; --i){
        if (!f[i]) continue;
        ll &ret = dp[i];
        ret = i * f[i];
        for (auto &p : primes){
            ll to = p * i;
            if (to > cur) break;
            ret = max(ret , dp[to] + i * (f[i] - f[to]));
        }
    }
    cout << dp[1] << nd;

 */

const int M = 3e5 * 50 +5;

ll INF = 1e12;
int nodes = 1;
array<int , 2 > t[M] , sub[M];
void push (int x , array<int , 2 > dp){
    int node = 1;
    for (int b = 29; b >= 0; --b){
        int c = (x >> b) & 1;
        if (!t[node][c]) t[node][c] = ++ nodes;
        node = t[node][c];
        sub[node] = max(sub[node]  , dp);
    }
}
array<int , 2 > query (int v , int k){ // num of values xor with v >= k
    array<int , 2 > ans = {0 , 0};
    int node = 1;
    for (int b = 29; b >= 0; --b){
        int bk = (k >> b) & 1 , bv = (v >> b) & 1;
        if (bk) node = t[node][!bv];
        else{
            ans = max(ans , sub[t[node][!bv]]);
            node = t[node][bv];
        }
        if (!b) ans = max(ans , sub[node]);
    }
    return ans;
}


void main_(int tc){
    int n , k; cin >> n >> k;
    vector <int > a(n+1);
    for (int i = 1; i <= n; ++i) cin >> a[i];
    vector <int > p(n);
    iota(all(p) , 1);
    sort(all(p) , [&](int u , int v){
        return a[u] < a[v];
    });


    vector <int > par(n+5);
    vector <ll > dp(n+5);
    for (auto &i : p){
        auto [dpv , idx] = query(a[i] , k);
        par[i] = idx;
        dp[i] = 1 + dpv;
        push(a[i] , {dp[i] , i});
    }
    int st = 1;
    for (int i = 1; i <= n; ++i) if (dp[i] > dp[st]) st = i;
    if (dp[st] < 2){cout << -1 << nd;;return;}
    vector <int > ans;
    cout << dp[st] << nd;
    while (st){
        ans.emplace_back(st);
        st = par[st];
    }
    print(ans);
}

signed main() {
    ios_base::sync_with_stdio(0);cin.tie(0); cout.tie(0);

    //freopen("trains.in", "r", stdin);
    //freopen("output.txt", "w", stdout);

    int tt = 1, tc = 0 ; // cin >> tt;
    while (tt--) main_(++tc);
#ifndef ONLINE_JUDGE
    cout << "Running Time: " << 1.0 * clock() / CLOCKS_PER_SEC << " s .\n";
#endif
    return 0;
}
ll INF = 1e12;
int idx[M] , nodes;
array<int , 2 > t[M];
void init(){
    for (int i = 1; i <= nodes; ++i) t[i][0] = t[i][1] = idx[i] = 0;
    nodes = 1;
}
void push (int v , int i){
    int node = 1;
    for (int b = 29 ; b >= 0; --b){
        int bv = (v >> b) & 1;
        if (!t[node][bv]) t[node][bv] =  ++ nodes;
        node = t[node][bv];
    }
    idx[node] = i+1;
}

array<int , 2 > solve (int x){
    int node = 1;
    array<int , 2 > ans = {0 , 0};
    for (int b = 29 ; b >= 0; --b){
        int bv = (x >> b) & 1;
        if (t[node][!bv]){
            ans[1] |= (1ll << b);
            node = t[node][!bv];
        }
        else node = t[node][bv];
    }
    ans[0] = idx[node];
    return ans;
}

void main_(int tc){
    int n , k; cin >> n >> k;
    if (!k){
        cout << n << nd;
        for (int i = 1; i <= n; ++i) cout << i <<" \n"[i == n];
        return;
    }
    vector < int > a(n);
    for (auto &i : a) cin >> i;
    vector <int > p(n);
    iota(all(p) , 0);
    sort(all(p) , [&] (int u , int v){
        return a[u] < a[v];
    });
    int bit = 0;
    while ((1 << (bit+1)) <= k) ++bit;
    int L = 0;
    vector <int > ans;
    while (L < n){
        int R = L;
        while (R+1 < n && (a[p[L]] >> bit) == (a[p[R+1]] >> bit)) ++R;
        // a[L] >> bit == a[R] >> bit
        int beg = R +1;
        if (beg < n && (a[p[beg]] >> (bit+1) ) == (a[p[R]] >> (bit+1))){
            int end = beg;
            while (end +1 < n && (a[p[beg]] >> bit) == (a[p[end+1]] >> bit)) ++end;
            init();
            for (int i = L; i <= R; ++i) push(a[p[i]] , p[i]);
            int id = 0;
            for (int i = beg ; i <= end; ++i){
                auto temp = solve(a[p[i]]);
                if (temp[1] >= k){
                    ans.push_back(temp[0]);
                    ans.push_back(p[i]+1);
                    id = 1;
                    break;
                }
            }
            if (!id) ans.emplace_back(p[L]+1);
            L = end +1;
        }
        else{
            ans.emplace_back(p[L]+1);
            L = R +1;
        }
    }
    int sz = (int)ans.size();
    if (sz < 2) cout << -1 << nd;
    else{
        cout << sz << nd;
        print(ans);
    }
}

signed main() {
    ios_base::sync_with_stdio(0);cin.tie(0); cout.tie(0);

    //freopen("trains.in", "r", stdin);
    //freopen("output.txt", "w", stdout);

    int tt = 1, tc = 0 ; // cin >> tt;
    while (tt--) main_(++tc);
#ifndef ONLINE_JUDGE
    cout << "Running Time: " << 1.0 * clock() / CLOCKS_PER_SEC << " s .\n";
#endif
    return 0;
}
